@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990--1995, 1998--1999, 2001--2020 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node 命令循环
@chapter Command Loop
@cindex editor command loop
@cindex command loop

  当你运行Emacs时，它几乎立即进入@dfn{editor command loop}。这个循环读取按键序列
，执行它们的定义，并显示结果。在本章中，我们将描述这些事情是如何完成的，以及允许Lisp程
序完成这些事情的子程序。

@menu
* 命令概述::   命令循环如何读取命令。
* 定义命令::   指定一个函数应该如何读取参数。
* 交互式调用:: 调用一个命令，使其读取参数。
* 区分交互式:: 使一个命令与交互式调用不同。
* 命令循环信息::令循环设置的变量，供你检查。
* 调整点::    命令后调整光标点。
* 输入事件::  读取输入时的样子。
* 读取输入::  从键盘或鼠标读取输入事件的方法。
* 特殊事件::  立即和单独处理的事件。
* 等待::     等待用户的输入或过期的时间。
* 退出::     @kbd{C-g}的工作方式。 如何捕捉或推迟退出。
* 前缀命令参数:: 设置前缀参数的命令如何工作。
* 递归编辑::  进入递归编辑,以及为什么你通常不应该这样做。
* 禁用命令::  命令循环如何处理被禁用的命令。
* 命令历史::  如何设置命令历史，以及如何访问。
* 键盘宏::    键盘宏的实现方式。
@end menu

@node 命令概述
@section Command Loop Overview

  命令循环必须做的第一件事是读取一个按键序列，这是一个转换为命令的输入事件序列，它通过
调用函数@code{read-key-sequence}来完成。Lisp程序也可以调用这个函数（
@pxref{key Sequence Input}）。它们也可以通过@code{read-key}或
@code{read-event}来读取更低层次的输入(@pxref{Reading One Event})，或者用
@code{discard-input}（@pxref{Event Input Misc}）丢弃待定的输入。

  按键序列通过当前活动键位图转化为命令。关于如何做到这一点的信息，请参见
@xref{Key Lookup}。其结果应该是一个键盘宏或一个可交互调用的函数。如果按键是
@kbd{M-x}，那么它就会读取另一个命令的名称，然后调用它。这是由命令
@code{execute-extended-command}（@pxref{Interactive Call}）完成的。

在执行命令之前，Emacs会运行@code{undo-boundary}来创建一个撤销边界。
@xref{Maintaining Undo}。

要执行一个命令，Emacs首先通过调用@code{command-execute}来读取其参数。(
@pxref{Interactive Call})。对于用Lisp编写的命令，@code{interactive}规范规定
了是如何读取参数。 这可能使用前缀参数（@pxref{Prefix Command Arguments}），也可
能在minibuffer中提示读取（@pxref{Minibuffers}）。例如，命令@code{find-file}有
一个@code{interactive}规范，说是使用minibuffer读取文件名。而@code{find-file}
的函数体并没有使用minibuffer，所以如果你从Lisp代码中调用@code{find-file}作为函数
，你必须提供文件名字符串作为普通Lisp函数参数。

如果命令是键盘宏(即字符串或向量)，Emacs会使用@code{execute-kbd-macro}来执行它(
@pxref{Keyboard Macros})

@defvar pre-command-hook
这个正常的钩子是由编辑器命令循环执行每个命令之前运行的。此时，@code{this-command}包
含即将运行的命令，@code{last-command}描述前一个命令。
@xref{Command Loop Info}。
@end defvar

@defvar post-command-hook
这个正常的钩子是在编辑器命令循环执行完每一条命令（包括因退出或错误而提前终止的命令）后
，由编辑器命令循环运行的。此时，@code{this-command}指的是刚刚运行的命令，
@code{last-command}指的是之前的命令。

当Emacs第一次进入命令循环时，也会运行这个钩子（此时@code{this-command}和
@code{last-command}都是@code{nil}）。
@end defvar

  在运行@code{pre-command-hook}和@code{post-command-hook}时，会抑制退出。如
果在执行这些钩子中的一个钩子时发生了错误，并不会终止钩子的执行；相反，错误会被沉默，发
生错误的函数会从钩子中移除。

进入Emacs服务器的请求(
@pxref{Emacs Server,,,emacs,The GNU Emacs Manual})会像键盘命令一样运行这两
个钩子。

@node 定义命令
@section Defining Commands
@cindex defining commands
@cindex commands, defining
@cindex functions, making them interactive
@cindex interactive function

  特殊表单@code{interactive}可以将一个Lisp函数变成一条命令。
@code{interactive}表单必须位于函数体的顶层，通常作为函数体的第一个表单；这适用于
lambda表达式（@pxref{Lambda Expressions}）和@code{defun}表单（
@pxref{Declare Form}）。此表单在实际执行函数的过程中没有任何作用；它的存在作为一个
标志，告诉Emacs命令循环可以交互式调用函数。@code{interactive}表单的参数指定了交互
式调用的参数应该如何读取。
@cindex @code{interactive-form} property
  另外，@code{interactive}表单可以在函数符号的@code{interactive-form}属性中指
定。这个属性的非@code{nil}值优先于函数体中的任何@code{interactive}形式。这个特性
很少被使用。
@anchor{The interactive-only property}
@cindex @code{interactive-only} property
  有时，一个函数只打算被交互式调用，而不是直接从Lisp中调用。在这种情况下，可以给函数一
个非@code{nil}的@code{interactive-only}属性，可以直接地或通过@code{declare}
。(@pxref{Declare Form})。这将导致字节编译器警告说从Lisp调用命令。
@code{describe-function}的输出将包括类似的信息。该属性的值可以是：一个字符串，字
节编译器将在其警告中直接使用该字符串（它应该以句号结束，而不是以大写开始，例如，
@code{"use (system-name) instead."}）；@code{t}；任何其他符号，它应该是
一个Lisp代码中使用的替代函数。

通用函数（@pxref{Generic Functions}）不能通过添加@code{interactive}形式来变成
命令。

@menu
* 使用交互式::  @code{interactive}的一般规则。
* 交互式代码::  各种方式读取参数的标准字母代码。
* 交互式例子::  如何读取交互式参数的例子。
* 通用命令::    在命令替代品中进行选择。
@end menu

@node 使用交互式
@subsection Using @code{interactive}
@cindex arguments, interactive entry
@cindex interactive spec, using

  本节介绍了如何编写@code{interactive}形式，使一个Lisp函数成为可交互调用的命令，
以及如何检查一个命令的@code{interactive}形式。

@defspec interactive arg-descriptor
这个特殊的表单声明一个函数是一个命令，因此它可以被交互式调用（通过@kbd{M-x}或输入一个
与之绑定的键序）。参数@var{arg-descriptor}声明了当命令被交互式调用时，如何计算命令
的参数。

命令可以像其他函数一样从Lisp程序中调用，但这时调用者提供参数，
@var{arg-descriptor}没有任何作用。

@cindex @code{interactive-form}, symbol property
@code{interactive}形式必须位于函数体的顶层，或者位于函数符号的
@code{interactive-form}属性中（@pxref{Symbol Properties}）。它之所以有效果，
是因为命令循环在调用函数之前会寻找它（@pxref{Interactive Call}）。一旦函数被调用
，它的所有主体表单都会被执行；此时，如果@code{interactive}表单发生在主体内，该表单
就会简单地返回@code{nil}，甚至不运算其参数。

按照惯例，你应该把@code{interactive}形式放在函数体中，作为第一个顶层形式。如果在
@code{interactive-form}符号属性和函数体中都有@code{interactive}表单，则前者优
先。可以使用@code{interactive-form}符号属性为现有的函数添加交互式表单，或者改变其
参数的交互式处理方式，而无需重新定义函数。
@end defspec

参数@var{arg-descriptor}有三种可能：

@itemize @bullet
@item
它可以被省略或@code{nil}，然后命令被调用时不需要任何参数。如果命令需要一个或多个参数
，这将很快导致错误。

@item
它可以是一个字符串；它的内容是一个由换行符分隔的元素序列，每个参数一个
@footnote{有些元素实际上提供了两个参数}。每个元素都由一个代码字符（
@pxref{Interactive Codes}）组成，后面可选择地跟着一个提示符（有些代码字符使用，有
些忽略）。下面是一个例子:

@smallexample
(interactive "P\nbFrobnicate buffer: ")
@end smallexample

@noindent
代码字母@samp{P}将命令的第一个参数设置为原始命令前缀（
@pxref{Prefix Command Arguments}）。@samp{bFrobnicate buffer: }用
@samp{Frobnicate buffer: }提示用户输入现有缓冲区的名称，该名称成为第二个也是最后
一个参数。

提示字符串可以使用@samp{%}将之前的参数值（从第一个参数开始）包含在提示中。
这可以通过@code{format-message}来完成。(@pxref{Formatting Strings})。
例如，以下是你可以如何读取一个现有缓冲区的名称，然后给这个缓冲区起一个新的名字:

@smallexample
@group
(interactive "bBuffer to rename: \nsRename buffer %s to: ")
@end group
@end smallexample

@cindex @samp{*} in @code{interactive}
@cindex read-only buffers in interactive
如果@samp{*}出现在字符串的开头，那么如果缓冲区是只读的，就会发出错误信号。

@cindex @samp{@@} in @code{interactive}
如果@samp{@@}出现在字符串的开头，并且如果用于调用命令的键序包括任何鼠标事件，那么在命
令运行之前，与第一个事件相关联的窗口被选中。

@cindex @samp{^} in @code{interactive}
@cindex shift-selection, and @code{interactive} spec
如果@samp{^}出现在字符串的开头，并且如果命令是通过@dfn{shift-translation}调用的
，则在命令运行前设置标记并暂时激活该区域，或者拓展一个已经激活的区域。如果命令是在没有
shift-translation的情况下调用的，并且区域暂时处于活动状态，则在命令运行前停用该区域
。Shift-translation在用户层面由@code{shift-select-mode}控制；参见
@ref{Shift Selection,,,,emacs,The GNU Emacs Manual}。

您可以同时使用@samp{*},@samp{@@},和@code{^}，顺序并不重要。参数的实际读取是由提示
字符串的其余部分控制的（从第一个不是@samp{*},@samp{@@},或@samp{^}的字符开始）。

@item
它可能是一个不是字符串的Lisp表达式；那么它应该是一个表单，通过运算得到要传递给命令的参
数列表。通常这个表单会调用各种函数来读取用户的输入，最常见的是通过迷你缓冲区（
@pxref{Minibuffers}）或直接从键盘（@pxref{Reading Input}）读取。

提供点或标记作为参数值也是很常见的，但如果你这样@emph{和}读输入（无论是否使用迷你缓冲
区），一定要在读完后得到点或标记的整数值。当前缓冲区可能正在接收子进程的输出；如果在命
令等待输入时子进程的输出到达，它可能会重新定位点和标记。

下面是一个@emph{不}要做的例子。

@smallexample
(interactive
 (list (region-beginning) (region-end)
       (read-string "Foo: " nil 'my-history)))
@end smallexample

@noindent
以下是如何避免这个问题，通过阅读键盘输入后检查点和标记：

@smallexample
(interactive
 (let ((string (read-string "Foo: " nil 'my-history)))
   (list (region-beginning) (region-end) string)))
@end smallexample

@strong{Warning:}参数值不应该包含任何不能打印和读取的数据类型。有些设施会将
@code{command-history}保存在一个文件中，以便在以后的会话中读取；如果一个命令的参数
包含了使用@samp{#<@dots{}>}语法打印的数据类型，那么这些设施将无法工作。

不过，也有一些例外：使用有限的一组表达式是可以的，比如@code{(point)}、
@code{(mark)}、@code{(region-beginning)}和@code{(region-end)}，因为Emacs
会特别识别它们，并将表达式（而不是其值）放入命令历史记录中。要查看您写的表达式是否属于
这些例外情况，请运行命令，然后检查 @code{(car command-history)}。

@end itemize

@cindex examining the @code{interactive} form
@defun interactive-form function
这个函数返回@var{function}的@code{interactive}表单。如果@var{function}是一个
可交互调用的函数 (@pxref{Interactive Call})，那么值就是命令的@code{交互式}形式
@code{(interactive @var{spec})}，它指定了如何计算其参数。否则，其值为
@code{nil}。如果@var{function}是一个符号，则使用其函数定义。
@end defun

@node 交互式代码
@subsection Code Characters for @code{interactive}
@cindex interactive code description
@cindex description for interactive codes
@cindex codes, interactive, description of
@cindex characters for interactive codes

  下面的代码字符描述包含一些关键词，在此定义如下：

@table @b
@item Completion
@cindex interactive completion
提供补全。@key{TAB}、@key{SPC}和@key{RET}执行名称补全，因为参数是用
@code{completing-read}读取的。(@pxref{Completion})。@kbd{?}
显示一个可能的完成列表。

@item Existing
要求使用现有对象的名称。不接受无效的名称；如果当前输入无效，退出minibuffer的命令不会
退出。

@item Default
@cindex default argument string
如果用户在minibuffer中没有输入文字，则使用某种默认值。默认值取决于代码字符。

@item No I/O
这个代码信在不读取任何输入的情况下计算一个参数，因此，它不使用提示字符串，你提供的任何
提示符都会被忽略。

即使代码字母没有使用提示字符串，但如果它不是字符串中的最后一个代码字符，你必须在它后面
加上一个新行。

@item Prompt
在代码字符后面紧跟着一个提示符。提示符以字符串的结尾或换行结束。

@item Special
这个代码字符只有在交互式字符串的开头才有意义，它不会寻找提示符或换行符。它是一个单独的
、孤立的字符。
@end table

@cindex reading interactive arguments
下面是与@code{interactive}配合使用的代码字符说明：

@table @samp
@item *
如果当前缓冲区为只读，则发出错误信号。Special。

@item @@
选择调用该命令的键序中第一个鼠标事件中提到的窗口。Special。

@item ^
如果命令是通过移位翻译调用的，则在命令运行前设置标记并暂时激活该区域，或扩展已经激活的
区域。如果命令是在没有移位翻译的情况下调用的，且区域暂时处于活动状态，则在命令运行前停
用该区域。Special。

@item a
一个函数名（比如满足@code{fboundp}的符号）。Existing, Completion, Prompt.

@item b
现有缓冲区的名称。默认情况下，使用当前缓冲区的名称（@pxref{Buffers}）。
Existing, Completion, Prompt。

@item B
缓冲区名称。缓冲区不需要存在。默认情况下，使用当前缓冲区以外的最近使用的缓冲区的名称。
Existing, Completion, Prompt。

@item c
一个字符。光标不会移动到回音区。Prompt.

@item C
一个命令名称（即满足@code{commandp}的符号）。Existing, Completion, Prompt.

@item d
@cindex position argument
点的位置，是一个整数（@pxref{Point}）。No I/O。

@item D
一个目录。默认为当前缓冲区的默认目录，@code{default-directory}。(
@pxref{File Name Expansion})。Existing, Completion, Default, Prompt.

@item e
在调用命令的按键序列中的第一个或下一个非键盘事件。更准确地说，@samp{e}得到的事件是列
表，所以你可以查看列表中的数据。@xref{Input Events}。No I/O。

您可以使用@samp{e}来处理鼠标事件和特殊系统事件（@pxref{Misc Events}）。命令接收
的事件列表取决于事件。@xref{Input Events}，它在相应的小节中描述了每个事件的列表
表单。

您可以在一个命令的交互式规范中使用@samp{e}一次以上。如果调用命令的键序列中有@var{n}
个事件是列表，那么第@var{n}个@samp{e}提供了第@var{n}个这样的事件。不是列表的事件，
例如函数键和 @acronym{ASCII} 字符，在 @samp{e} 中不计算。

@item f
一个现有文件的文件名(@pxref{File Names}).默认目录是@code{default-directory}。
默认目录是@code{default-directory}。Existing, Completion, Default,
Prompt.

@item F
一个文件名。文件不需要存在。 Completion, Default, Prompt.

@item G
一个文件名。该文件不需要存在。如果用户只输入一个目录名，那么值就只是该目录名，不添加目
录内的文件名。 Completion, Default, Prompt.

@item i
一个不相关的参数。此代码总是提供@code{nil}作为参数的值。 No I/O.

@item k
一个键序列（@pxref{Key Sequences}）。这将持续读取事件，直到在当前键映射中找到一条
命令（或未定义的命令）。键序列参数用字符串或向量表示。光标不会移动到回音区。Prompt.

如果@samp{k}读取了一个以向下事件结束的键序列，它也会读取并丢弃下面的向上事件。您可以
使用@samp{U}代码字符来访问该上行事件。

这种输入被@code{describe-key}和@code{global-set-key}等命令使用。

@item K
一个你想改变其定义的键序列。其工作原理如@samp{k}，但对于键中的最后一个输入事件，它抑
制了键序列，通常用于（必要时）将未定义的键转换为定义的键的转换。

@item m
@cindex marker argument
标记的位置，为整数。 No I/O.

@item M
任意文本，使用当前缓冲区的输入方法在minibuffer中读取，并以字符串形式返回（
@pxref{Input Methods,,, emacs, The GNU Emacs Manual}）。 Prompt.

@item n
一个数字，用minibuffer读取。如果输入的不是数字，用户必须再试一次。@samp{n}从不使用
前缀参数。Prompt.

@item N
数字前缀参数；但如果没有前缀参数，则像@kbd{n}一样读取一个数字。值总是一个数字。
@xref{Prefix Command Arguments}.  Prompt.

@item p
@cindex numeric prefix argument usage
数字前缀参数。(注意这个@samp{p}是小写的。) No I/O.

@item P
@cindex raw prefix argument usage
原始前缀参数。(注意，这个@samp{P}是大写的。) No I/O.

@item r
@cindex region argument
点和标记，作为两个数字参数，先小后大。这是唯一一个指定两个连续参数而不是一个参数的代码
字母。如果标记没有设置在缓冲区中，这将发出错误信号，而缓冲区在命令被调用时是当前的。
No I/O.

@item s
任意文本，从迷你缓冲区中读取并以字符串形式返回(@pxref{Text from Minibuffer})。用
以下两种方式终止输入@kbd{C-j}或@key{RET}。(@kbd{C-q}可用于包含输入里两种个之一。
) Prompt.

@item S
在minibuffer中读取一个内部符号的名称。用@kbd{C-j}或@key{RET}终止输入。其他通常终
止符号的字符(如：空格、括号和大括号)在这里不能终止。 Prompt.

@item U
一个按键序列或@code{nil}。可以在@samp{k}或@samp{K}参数之后使用，用来获取被丢弃的
@samp{k}或@samp{K}读取一个向下事件后的上位事件（如果有的话）。如果没有上行事件被丢
弃，则@samp{U}提供@code{nil}作为参数。 No I/O.

@item v
一个声明为用户选项的变量(即满足前提条件@code{custom-variable-p})。这将使用
@code{read-variable}读取变量。@xref{Definition of read-variable}。
Existing, Completion, Prompt.

@item x
一个Lisp对象，用它的读取语法指定，以@kbd{C-j}或@key{RET}结束。该对象没有被评估。
@xref{Object from Minibuffer}。 Prompt.

@item X
@cindex evaluated expression argument
一个Lisp表单的值。@samp{X}像@samp{x}一样读取，然后运算表单，使其值成为命令的参数
。 Prompt.

@item z
一个编码系统名称（一个符号）。如果用户输入为空，参数值为@code{nil}。
@xref{Coding Systems}.  Completion, Existing, Prompt.

@item Z
一个编码系统名称（一个符号），仅当这个命令有前缀参数时。如果没有前缀参数，@samp{Z}提
供@code{nil}作为参数值。 Completion, Existing, Prompt.
@end table

@node 交互式例子
@subsection Examples of Using @code{interactive}
@cindex examples of using @code{interactive}
@cindex @code{interactive}, examples of using

  Here are some examples of @code{interactive}:

@example
@group
(defun foo1 ()              ; @r{@code{foo1} takes no arguments,}
    (interactive)           ;   @r{just moves forward two words.}
    (forward-word 2))
     @result{} foo1
@end group

@group
(defun foo2 (n)             ; @r{@code{foo2} takes one argument,}
    (interactive "^p")      ;   @r{which is the numeric prefix.}
                            ; @r{under @code{shift-select-mode},}
                            ;   @r{will activate or extend region.}
    (forward-word (* 2 n)))
     @result{} foo2
@end group

@group
(defun foo3 (n)             ; @r{@code{foo3} takes one argument,}
    (interactive "nCount:") ;   @r{which is read with the Minibuffer.}
    (forward-word (* 2 n)))
     @result{} foo3
@end group

@group
(defun three-b (b1 b2 b3)
  "Select three existing buffers.
Put them into three windows, selecting the last one."
@end group
    (interactive "bBuffer1:\nbBuffer2:\nbBuffer3:")
    (delete-other-windows)
    (split-window (selected-window) 8)
    (switch-to-buffer b1)
    (other-window 1)
    (split-window (selected-window) 8)
    (switch-to-buffer b2)
    (other-window 1)
    (switch-to-buffer b3))
     @result{} three-b
@group
(three-b "*scratch*" "declarations.texi" "*mail*")
     @result{} nil
@end group
@end example

@node 通用命令
@subsection Select among Command Alternatives
@cindex generic commands
@cindex alternatives, defining

宏@code{define-alternatives}可以用来定义@dfn{generic commands}。这些是交互
式函数，按照用户的喜好，可以从几个备选方案中选择实施。

@defmac define-alternatives command &rest customizations
定义新的命令@var{command}，一个符号。

当用户在第一次运行@kbd{M-x @var{command} @key{RET}}时，Emacs会提示使用命令的
实际表单，并通过自定义变量记录选择。使用前缀参数会重复这个选择过程。

变量@code{@var{command}-alternatives}应该包含一个@var{command}的替代实现的
列表。在这个变量被设置之前，@code{define-alternatives}没有任何作用。

如果@var{customizations}是非@code{nil}，它应该由替代的@code{defcustom}关键
字（通常是@code{:group}和@code{:version}）和值组成，以添加到
@code{@var{command}-alternatives}的声明中。
@end defmac

@node 交互式调用
@section Interactive Call
@cindex interactive call

  在命令循环将一个键序列翻译成命令后，它使用函数@code{command-execute}来调用这个
命令。如果命令是一个函数，那么@code{command-execute}会调用
@code{call-inactively}，后者读取参数并调用命令。你也可以自己调用这些函数。

  请注意，术语"命令"在这里指的是一个可交互调用的函数（或类似函数的对象），或一个键盘
宏。它不是指用于调用命令的键序（@pxref{Keymaps}）。

@defun commandp object &optional for-call-interactively
如果@var{object}是一条命令，则该函数返回@code{t}。否则，返回@code{nil}。

命令包括字符串和向量（被视为键盘宏）、包含顶级@code{interactive}表单的lambda表达
式（@pxref{Using Interactive}）、由这些lambda表达式构成的字节码函数对象、被声
明为交互式的自动加载对象（@code{autoload}的第四个参数非@code{nil}），以及一些原
始函数。另外，如果一个符号有一个非@code{nil}的@code{interactive-form}属性，或者
它的函数定义满足@code{commandp}，第四个参数，那么它就被认为是一个命令。

如果@var{for-call-interactively}是非@code{nil}，那么@code{commandp}只对
@code{call-interactively}可以调用的对象返回@code{t}--因此，不对键盘宏返回。

参见@ref{Accessing Documentation}中的@code{documentation}，这是一个使用
@code{commandp}的实际例子。
@end defun

@defun call-interactively command &optional record-flag keys
这个函数调用可交互调用的函数@var{command}，并根据其交互调用规范提供参数。无论
@var{command}返回什么，它都会返回。

例如，如果你有一个具有以下签名的函数:

@example
(defun foo (begin end)
  (interactive "r")
  ...)
@end example

然后

@example
(call-interactively 'foo)
@end example

将调用@code{foo}，把区域（@code{point}和@code{mark}）作为参数。

如果@var{command}不是函数，或者不能交互调用（即不是命令），就会发出错误信号。请注意
，键盘宏（字符串和向量）即使被认为是命令，也不会被接受，因为它们不是函数。如果
@var{command}是一个符号，那么@code{call-interactively}使用它的函数定义。

@cindex record command history
如果@var{record-flag}是非@code{nil}，那么这条命令和它的参数就会无条件地添加到
@code{command-history}列表中。否则，只有当该命令使用迷你缓冲区读取参数时，才会被
添加到列表中。@xref{Command History}。

如果给定参数@var{keys}，那么它应该是一个向量，用于指定在命令询问哪些事件被用来调用
时要提供的事件序列。如果省略了@var{keys}或@code{nil}，则默认为
@code{this-command-keys-vector}的返回值。
@xref{this-command-keys-vector}。
@end defun

@defun funcall-interactively function &rest arguments
这个函数的工作原理与@code{funcall}类似。(@pxref{Calling Functions})，但它使
调用看起来像一个交互式调用：在@var{function}内调用
@code{called-interactively-p}将返回@code{t}。如果@var{function}不是一个命
令，那么它在被调用时不会发出错误信号。
@end defun

@defun command-execute command &optional record-flag keys special
@cindex keyboard macro execution
这个函数执行@var{command}，参数@var{command}必须满足@code{commandp}谓词，也
就是说，它必须是一个可交互调用的函数或键盘宏。

作为@var{command}的字符串或向量会被@code{execute-kbd-macro}执行。一个函数与
@var{record-flag}和@var{keys}参数一起传递给@code{call-interactively}（见上
文）。

如果@var{command}是一个符号，那么使用它的函数定义。如果一个带有@code{autoload}
定义的符号被声明为代表一个可交互调用的函数，那么这个符号也算作一个命令。这种定义是通过
加载指定的库，然后重新检查符号的定义来处理的。

如果给定参数@var{special}，意味着忽略前缀参数，而且不清除它。这用于执行特殊事件（
@pxref{特殊事件}）。
@end defun

@deffn Command execute-extended-command prefix-argument
@cindex read command name
该函数使用@code{completing-read}从minibuffer中读取命令名。(
@pxref{Completion})。然后它使用@code{command-execute}来调用指定的命令。无论
该命令返回什么，都会成为@code{execute-extended-command}的值。

@cindex execute with prefix argument
如果命令要求使用前缀参数，它将接收@var{prefix-argument}的值。如果交互式地调用了
@code{execute-extended-command}，那么当前的原始前缀参数将被用于
@var{prefix-argument}，从而传递给任何运行的命令。

@c !!!应该是@kindex?
@cindex @kbd{M-x}
@code{execute-extended-command}是@kbd{M-x}的普通定义，所以它使用了字符串
@w{@samp{M-x }}作为提示符。(最好是从调用@code{execute-extended-command}的事
件中获取提示符，但实现起来很麻烦。)如果有的话，对前缀参数值的描述也会成为提示的一部分
。

@example
@group
(execute-extended-command 3)
---------- Buffer: Minibuffer ----------
3 M-x forward-word @key{RET}
---------- Buffer: Minibuffer ----------
     @result{} t
@end group
@end example
@end deffn

@node 区分交互式
@section Distinguish Interactive Calls
@cindex distinguish interactive calls
@cindex is this call interactive

  有时，命令应该只为交互式呼叫显示额外的视觉反馈（如在回音区显示信息信息）。有三种方
法可以做到这一点。测试函数是否通过@code{call-interactively}调用，推荐的方法是给
函数一个可选的参数@code{print-message}，并使用@code{interactive}规范使其在交
互式调用中不@code{nil}。下面是一个例子:

@example
(defun foo (&optional print-message)
  (interactive "p")
  (when print-message
    (message "foo")))
@end example

@noindent
我们使用@code{"p"}，因为数字前缀参数永远不会是@code{nil}。以这种方式定义的函数，
在从键盘宏调用时确实会显示消息。

上面的方法加上额外的参数通常是最好的，因为它允许调用者说"把这个调用当作交互式"。但你
也可以通过测试@code{called-interactively-p}来完成这项工作。

@defun called-interactively-p kind
当使用@code{call-inactively}调用调用函数时，该函数返回@code{t}。

参数@var{kind}应该是符号@code{interactive}或者符号@code{any}。如果是
@code{interactive}，那么@code{called-interactively-p}只有在用户直接调用的情
况下才返回@code{t}--例如，如果用户输入了一个绑定到调用函数的按键序列，但如果用户运
行了一个调用函数的键盘宏(@pxref{Keyboard Macros})，则返回@emph{not}。如果
@var{kind}是@code{any}，则@code{called-interactively-p}返回@code{t}，用于
任何类型的交互式调用，包括键盘宏。

如果有疑问，请使用@code{any}；唯一已知的@code{interactive}的正确用法是当你需要
决定是否在函数运行时显示一个有用的消息。

如果一个函数是通过Lisp运算调用的（或者使用@code{apply}或@code{funcall}），那么
它永远不会被认为是交互式调用的。
@end defun

@noindent
下面是一个使用@code{called-interactively-p}的例子:

@example
@group
(defun foo ()
  (interactive)
  (when (called-interactively-p 'any)
    (message "Interactive!")
    'foo-called-interactively))
@end group

@group
;; @r{Type @kbd{M-x foo}.}
     @print{} Interactive!
@end group

@group
(foo)
     @result{} nil
@end group
@end example

@noindent
下面是另一个例子，将直接和间接调用@code{called-interactively-p}进行对比。

@example
@group
(defun bar ()
  (interactive)
  (message "%s" (list (foo) (called-interactively-p 'any))))
@end group

@group
;; @r{Type @kbd{M-x bar}.}
     @print{} (nil t)
@end group
@end example

@node 命令循环信息
@section Information from the Command Loop
@cindex command loop variables

编辑器命令循环设置了几个Lisp变量来为自己和正在运行的命令保存状态记录。除了
@code{this-command}和@code{last-command}之外，一般来说，在Lisp程序中改变这些
变量是个坏主意。

@defvar last-command
这个变量记录了命令循环执行的前一条命令的名称（当前命令之前的那条）。通常情况下，值是一
个带有函数定义的符号，但这并不保证。

当一个命令返回到命令循环时，该值会从@code{this-command}中复制出来，除非该命令已经
为下面的命令指定了前缀参数。

这个变量始终是当前终端的本地变量，不能是缓冲区本地变量。
@xref{Multiple Terminals}。
@end defvar

@defvar real-last-command
这个变量在Emacs中的设置就像@code{last-command}一样，但从未被Lisp程序改变。
@end defvar

@defvar last-repeatable-command
这个变量存储了最近执行的不属于输入事件的命令。这是@code{repeat}将尝试重复执行的命令
，@xref{Repeating,,,emacs, The GNU Emacs Manual}。
@end defvar

@defvar this-command
@cindex current command
这个变量记录了编辑器命令循环正在执行的命令的名称，和@code{last-command}一样，它通
常是带有函数定义的符号。和@code{last-command}一样，它通常是一个带有函数定义的符号
。

命令循环在运行命令之前设置这个变量，并在命令完成后将其值复制到@code{last-command}
中（除非命令为下面的命令指定了一个前缀参数）。

@cindex kill command repetition
有些命令在执行过程中设置了这个变量，作为接下来运行的任何命令的标志。特别是，杀戮文本的
函数将@code{this-command}设置为@code{kill-region}，这样紧接着的任何杀戮命令都
会知道将杀戮文本附加到之前的杀戮中。
@end defvar

如果您不希望某条命令在出错的情况下被识别为前一条命令，您必须对该命令进行编码以防止这种
情况发生。一种方法是在命令的开头将@code{this-command}设置为@code{t}，然后在结尾
处将@code{this-command} 设置为合适的值，就像这样:

@example
(defun foo (args@dots{})
  (interactive @dots{})
  (let ((old-this-command this-command))
    (setq this-command t)
    @r{@dots{}do the work@dots{}}
    (setq this-command old-this-command)))
@end example

@noindent
我们没有绑定@code{this-command}与@code{let}，因为这样做会在出错时恢复旧的值--这
是@code{let}的一个特性，在这种情况下，它恰恰是我们想要避免的。

@defvar this-original-command
这与@code{this-command}的值相同，但当发生命令重映射时除外（@pxref{重映射命令}）。
在这种情况下，@code{this-command}给出了实际运行的命令（重映射的结果），而
@code{this-original-command}给出了指定运行但重映射为另一个命令的命令。
@end defvar

@defun this-command-keys
这个函数返回一个字符串或向量，其中包含调用当前命令的键序列，加上之前为这个命令生成前
缀参数的任何命令。任何由命令使用@code{read-event}读取的、没有超时的事件都会被加到
最后。

但是，如果命令调用了@code{read-key-sequence}，则返回最后读取的键序列。
@xref{键序列输入}。如果序列中的所有事件都是适合于字符串的字符，则该值是一个字符串。
@xref{输入事件}。

@example
@group
(this-command-keys)
;; @r{Now use @kbd{C-u C-x C-e} to evaluate that.}
     @result{} "^U^X^E"
@end group
@end example
@end defun

@defun this-command-keys-vector
@anchor{Definition of this-command-keys-vector}
和@code{this-command-keys}一样，只是它总是以向量的形式返回事件，所以你不需要处理
将输入事件存储在字符串中的复杂问题 (@pxref{事件字符串})。
@end defun

@defun clear-this-command-keys &optional keep-record
这个函数清空了@code{this-command-keys}要返回的事件表。除非@var{keep-record}是
非@code{nil}，否则它也会清空函数@code{recent-keys}所返回的记录。(
@pxref{记录输入})随后将返回。这在读取密码后很有用，可以防止在某些情况下，密码作为
下一条命令的一部分被无意中回传。
@end defun

@defvar last-nonmenu-event
这个变量保存了最后一次读取的输入事件，作为按键序列的一部分，不包括鼠标菜单产生的事件。

这个变量的一个用途是告诉@code{x-popup-menu}在哪里弹出一个菜单。它也被
@code{y-or-n-p}内部使用(@pxref{Yes-or-No Queries})。
@end defvar

@defvar last-command-event
这个变量被设置为命令循环读取的最后一个输入事件，作为命令的一部分。这个变量的主要用途
是在@code{self-insert-command}中，用来决定插入哪个字符。

@example
@group
last-command-event
;; @r{Now use @kbd{C-u C-x C-e} to evaluate that.}
     @result{} 5
@end group
@end example

@noindent
这个值是5，因为这是@kbd{C-e}的@acronym{ASCII}码。
@end defvar

@defvar last-event-frame
这个变量记录了最后一个输入事件被指向的窗框。通常这是事件生成时被选中的窗框，但如果该
窗框已将输入焦点重定向到另一窗框，则该值是事件被重定向到的窗框。@xref{输入焦点}。

如果最后一个事件来自于键盘宏，那么其值为@code{macro}。
@end defvar

@node 调整点
@section Adjusting Point After Commands
@cindex adjusting point
@cindex invisible/intangible text, and point
@cindex @code{display} property, and point display
@cindex @code{composition} property, and point display

  当点处于具有@code{display}或@code{composition}属性的，或者是隐形的文本序列中间
时，Emacs无法显示光标。因此，在一条命令完成并返回命令循环后，如果点在这样的序列内，
命令循环通常会将点移动到序列的边缘，使得这个序列实际上是无形的。

  一个命令可以通过设置变量@code{disable-point-adjustment}来抑制该功能：

@defvar disable-point-adjustment
如果当一个命令返回到命令循环时，这个变量是非@code{nil}，那么命令循环就不会检查这些文
本属性，也不会将点从有这些属性的序列中移出。

命令循环在每条命令之前都会将这个变量设置为@code{nil}，所以如果某条命令设置了这个变量
，那么效果只适用于这条命令。
@end defvar

@defvar global-disable-point-adjustment
如果将这个变量设置为非@code{nil}值，则完全关闭这些序列中移动点的功能。
@end defvar

@node 输入事件
@section Input Events
@cindex events
@cindex input events

Emacs命令循环读取一连串的@dfn{输入事件}，这些事件代表键盘或鼠标活动，或者是发
送给Emacs的系统事件。键盘活动的事件是字符或符号，其他事件总是列表。本节详细介绍
输入事件的表示方法和意义。

@defun eventp object
如果@var{object}是一个输入事件或事件类型，则该函数返回非@code{nil}。

请注意，任何非@code{nil}符号都可能被用作事件或事件类型；@code{eventp}不能区分
Lisp代码是否打算将一个符号用作事件。
@end defun

@menu
* 键盘事件::                     普通字符 -- 带符号的键。
* 功能键::                       功能键 -- 有名称而非符号的键。
* 鼠标事件::                     鼠标事件概述。
* 点击事件::                     按压和释放鼠标按钮。
* 拖动事件::                     在释放按钮之前移动鼠标。
* 按下按钮事件::                  按钮被按下后尚未释放。
* 重复事件::                     双击和三击（或拖动，或按下）。
* 运动事件::                     只是移动鼠标，而不按下按钮。
* 焦点事件::                     在窗框之间移动鼠标。
* 杂项事件::                     系统可以产生的其他事件。
* 事件示例::                     鼠标事件的列表示例。
* 分类事件::                     寻找事件符号中的修饰键。事件类型。
* 访问鼠标::                     从鼠标事件中提取信息的函数。
* 访问滚动条::                   从滚动条事件中获取信息的函数。
* 事件字符串::                   将键盘字符事件放在字符串中的特殊注意事项。
@end menu

@node 键盘事件
@subsection Keyboard Events
@cindex keyboard events

@cindex character event
你可以从键盘上获得两种输入：普通键和功能键。普通键对应的是（可能是修改过的）字符；
它们产生的事件在Lisp中表示为字符。一个@dfn{字符事件}的事件类型是字符本身（一个
整数），它可能设置了一些修饰位；参见 @ref{分类事件}。

@cindex modifier bits (of input character)
@cindex basic code (of input character)
一个输入字符事件由0到524287之间的@dfn{基本码}，加上任何或所有这些@dfn{修饰位}
组成：

@table @asis
@item meta
该
@tex
@math{2^{27}}
@end tex
@ifnottex
2**27
@end ifnottex
字符码中的位表示按住元键输入的字符。

@item control
该
@tex
@math{2^{26}}
@end tex
@ifnottex
2**26
@end ifnottex
字符码中的位表示非@acronym{ASCII}控制字符。

@sc{ascii}控制字符，如@kbd{C-a}，有它们自己的特殊的基本编码，所以Emacs不需要
特殊的位来表示它们。因此，@kbd{C-a}的编码只是1。

但是，如果你输入一个非@acronym{ASCII}的控制组合，例如 用控制键和@kbd{%}，得到的数
值就是编码@kbd{%}加上
@tex
@math{2^{26}}
@end tex
@ifnottex
2**26
@end ifnottex
(假设终端支持非@acronym{ASCII}控制字符)，即@:，设置第27位。

@item shift
该
@tex
@math{2^{25}}
@end tex
@ifnottex
2**25
@end ifnottex
位（第26位）在字符事件代码中，表示的是一个按住shift键输入的@acronym{ASCII}控制字符。

对于字母，基本码本身就表达大写与小写；对于数字和标点符号，shift键选择的是完全不同的字
符，基本码也不同。为了尽可能保持使用@acronym{ASCII}字符集，Emacs避免使用
@tex
@math{2^{25}}
@end tex
@ifnottex
2**25
@end ifnottex
位的那些字符事件。

但是，@acronym{ASCII}没有提供区分@kbd{C-A}和@kbd{C-a}的方法，所以Emacs使用了
@tex
@math{2^{25}}
@end tex
@ifnottex
2**25
@end ifnottex
位，在@kbd{C-A}中，不在@kbd{C-a}中。

@item hyper
该
@tex
@math{2^{24}}
@end tex
@ifnottex
2**24
@end ifnottex
字符事件代码中的位表示按住hyper键输入的字符。

@item super
该
@tex
@math{2^{23}}
@end tex
@ifnottex
2**23
@end ifnottex
字符事件代码中的位表示按住super键输入的字符。

@item alt
该
@tex
@math{2^{22}}
@end tex
@ifnottex
2**22
@end ifnottex
字符事件代码中的位表示在按住alt键的情况下输入了一个字符，（大多数键盘上标有
@key{Alt}的键实际上被当作meta键处理，而不是这个）。
@end table

  最好避免在程序中提到具体的位数。要测试一个字符的修饰位，请使用函数
@code{event-modifiers}(@pxref{分类事件})。在制作键绑定时，您可以
为带有修饰位的字符（@samp{\C-}、@samp{\M-}等）使用读语法。对于用
@code{define-key}制作键绑定，您可以使用@code{(control hyper ?x)}等列表来指定
字符(@pxref{Changing Key Bindings})。函数@code{event-convert-list}可以将这
样的列表转换为事件类型 (@pxref{分类事件})。

@node 功能键
@subsection Function Keys

@cindex function keys
大部分键盘也有@dfn{功能键}——有名字或不是字符的符号的键。在Emacs Lisp中，功能键是
以符号的形式来表示的；符号的名称就是功能键的标签，用小写字母表示。例如，按下一个标
有@key{F1}的键会产生一个输入事件，用符号@code{f1}表示。

函数键事件的事件类型就是事件符号本身。@xref{分类事件}。

下面是函数键的符号命名惯例中的几种特殊情况：

@table @asis
@item @code{backspace}, @code{tab}, @code{newline}, @code{return}, @code{delete}
这些键对应于常见的@acronym{ASCII}控制字符，这些字符在大多数键盘上有特殊的键。

在@acronym{ASCII}中，@kbd{C-i}和@key{TAB}是同一个字符。如果终端能够区分它们，
Emacs就会将它们的区别传达给Lisp程序，将前者表示为整数9，后者表示为符号@code{tab}。

大多数情况下，区分这两者是没有用的。所以一般情况下，
@code{local-function-key-map}(@pxref{Translation Keymaps})是为了将@code{tab}
映射到9而设置的。因此，字符代码9的键绑定（字符 @kbd{C-i}）也适用于@code{tab}。同样，
对于这一组中的其他符号也是如此。函数@code{read-char}也同样将这些事件转换为字符。

在@acronym{ASCII}中，@key{BS}实际上是@kbd{C-h}。但是@code{backspace}会转换成字
符代码127(@key{DEL})，而不是代码8(@key{BS})。这是大多数用户所喜欢的。

@item @code{left}, @code{up}, @code{right}, @code{down}
光标方向键
@item @code{kp-add}, @code{kp-decimal}, @code{kp-divide}, @dots{}
键盘键（在普通键盘的右侧）。
@item @code{kp-0}, @code{kp-1}, @dots{}
带数字的键盘键。
@item @code{kp-f1}, @code{kp-f2}, @code{kp-f3}, @code{kp-f4}
键盘PF键。
@item @code{kp-home}, @code{kp-left}, @code{kp-up}, @code{kp-right}, @code{kp-down}
键盘方向键。Emacs通常会将这些键翻译成相应的非键盘键@code{home}, @code{left},
@dots{}。
@item @code{kp-prior}, @code{kp-next}, @code{kp-end}, @code{kp-begin}, @code{kp-insert}, @code{kp-delete}
额外的键盘重复键，通常在其他地方都能找到，Emacs通常会将这些键翻译成同名的非键盘
键。Emacs通常会将这些键翻译成相同名称的非键盘键。
@end table

您可以用功能键同时使用修饰键@key{ALT}，@key{CTRL}，@key{HYPER}，@key{META}，
@key{SHIFT}，@key{SUPER}。方法是代表它们的是符号名称中的前缀：

@table @samp
@item A-
alt修饰。
@item C-
ctrl修饰。
@item H-
hyper修饰。
@item M-
meta修饰。
@item S-
shift修饰。
@item s-
super修饰。
@end table

因此，按住@key{META}的键@key{F3}的符号是@code{M-f3}。当您使用一个以上的前缀时，
我们建议您按字母顺序来写；但在键绑定查找和修改函数的参数中，顺序并不重要。

@node 鼠标事件
@subsection Mouse Events

Emacs支持四种鼠标事件：点击事件、拖动事件、下键事件和运动事件。所有的鼠标事件都用
列表来表示。列表中的@sc{car}是事件类型；它说明了涉及到的是哪个鼠标按钮，以及使用
了哪些修饰键。事件类型也可以区分双击或三击按钮（@pxref{重复事件}）。其余的列表元
素给出了位置和时间信息。

为了键查询，只有事件类型才是重要的：两个相同类型的事件必然运行同一个命令。命令可以
使用@samp{e}交互式代码访问这些事件的全部值。@xref{交互式代码}。

一个以鼠标事件开始的按键序列是使用鼠标所在窗口的缓冲区的键位图来读取的，而不是当前
缓冲区。这并不意味着点击一个窗口就能选择该窗口或其缓冲区--这完全是由按键序列的命令
绑定所控制的。

@node 点击事件
@subsection Click Events
@cindex click event
@cindex mouse click event

当用户按下鼠标按钮并在同一位置松开时，就会产生一个@dfn{click}事件。所有的鼠标点
击事件都有相同的格式：

@example
(@var{event-type} @var{position} @var{click-count})
@end example

@table @asis
@item @var{event-type}
这是一个表示使用了哪个鼠标按钮的符号。它是符号@code{mouse-1}、@code{mouse-2}、
@dots{}中的一种，其中按钮从左到右编号。

您也可以使用前缀@samp{A-}、@samp{C-}、@samp{H-}、@samp{M-}、@samp{s-}和
@samp{s-}代表修饰器alt、control、hyper、meta、shift和超级，就像你用功能键一样。

这个符号也作为事件的事件类型。键绑定通过事件类型来描述事件；因此，如果有一个
@code{mouse-1}的键绑定，该绑定将适用于所有@var{event-type}为@code{mouse-1}的事
件。

@item @var{position}
@cindex mouse position list
这是一个@dfn{鼠标位置列表}，指定了鼠标点击的位置，详情见下文。

@item @var{click-count}
这是到目前为止，快速重复按下同一个鼠标按钮的次数。@xref{重复事件}。
@end table

  要访问点击事件的@var{position}槽中的鼠标位置列表的内容，通常应该使用
@ref{访问鼠标}中记载的函数。列表的显式格式取决于点击发生的位置。对于在文本区域、模
式行、页眉行、标签行、边缘或边缘区域的点击，鼠标位置列表的格式为

@example
(@var{window} @var{pos-or-area} (@var{x} . @var{y}) @var{timestamp}
 @var{object} @var{text-pos} (@var{col} . @var{row})
 @var{image} (@var{dx} . @var{dy}) (@var{width} . @var{height}))
@end example

@noindent
这些清单要素的含义如下：

@table @asis
@item @var{window}
发生点击的窗口。

@item @var{pos-or-area}
文字区域中被点击的字符的缓冲位置；如果点击是在文字区域之外，则为其发生的窗口区域
。它是@code{mode-line}, @code{header-line}, @code{tab-line},
@code{vertical-line}, @code{left-margin}, @code{right-margin},
@code{left-fringe}, 或@code{right-fringe}等符号中的一种。

在一种特殊情况下，@var{pos-or-area}是一个包含符号（上面列出的符号之一）的列表，
而不仅仅是符号。这发生在Emacs注册了事件的虚前缀键之后。@xref{键序列输入}。

@item @var{x}, @var{y}
点击的相对像素坐标。对于窗口文字区域的点击，坐标原点@code{(0 . 0)}取为文字区域
的左上角。@xref{窗口大小}。对于模式行、标题行或标签行中的点击，坐标原点为窗口本
身的左上角。对于边缘、边框和垂直边框，@var{x}没有有意义的数据。对于边缘和边框，
@var{y}是相对于页眉线的底边而言的。在所有情况下，@var{x}和@var{y}的坐标分别向
右和向下增加。

@item @var{timestamp}
事件发生的时间，为系统初始时间后的整数毫秒。

@item @var{object}
要么是@code{nil}，表示点击发生在缓冲区文本上，要么是
@w{(@var{string} .@var{string-pos})}形式的cons单元格，如果点击位置有文本属
性的字符串或覆盖层。

@table @asis
@item @var{string}
被点击的字符串，包括任何属性。

@item @var{string-pos}
字符串中发生点击的位置。
@end table

@item @var{text-pos}
对于在边缘区域或边缘线上的点击，这是窗口中相应行中第一个可见字符的缓冲位置。对于
模式行、页眉行或标签行的点击，是@code{nil}。对于其他事件，它是最接近点击的缓冲
区位置。

@item @var{col}, @var{row}
这些是@var{x}、@var{y}位置下字型的实际列和行坐标号。如果@var{x}位于其行上实际
文本的最后一列之外，@var{col}则通过添加虚构的额外列来报告，这些列具有默认的字符
宽度。如果窗口有页眉行，则第0行被视为页眉行，如果窗口有标签行，则第1行被视为页眉
行，否则被视为文本区域的最上面一行。第0列是指在窗口文本区域上点击的文本区域最左
边的一列，或者在那里点击的最左边的模式线或页眉线列。对于边缘或垂直边界上的点击，
这些没有有意义的数据。对于在边框上的点击，@var{col}是从边框区域的左边缘开始测量
的，@var{row}是从边框区域的顶部开始测量的。

@item @var{image}
如果点击位置有图像，则是@code{find-image}返回的图像对象。(@pxref{定义图像})；
否则就是@code{nil}。

@item @var{dx}, @var{dy}
这些是点击的像素坐标，相对于@var{object}的左上角，也就是@code{(0 . 0)}。如果
@var{object}是@code{nil}，代表缓冲区，则坐标是相对于被点击的字符字形的左上角。

@item @var{width}, @var{height}
这些是@var{object}的像素宽度和高度，如果是@code{nil}，则是被点击的字符字形的宽
度和高度。
@end table

对于滚动条上的点击，@var{position}有这样的形式：

@example
(@var{window} @var{area} (@var{portion} . @var{whole}) @var{timestamp} @var{part})
@end example

@table @asis
@item @var{window}
其滚动条被点击的窗口。

@item @var{area}
这是符号@code{vertical-scroll-bar}。

@item @var{portion}
从滚动条的顶部到点击位置的像素数，在一些工具包中，包括GTK+，Emacs不能提取这个数据
，所以总是@code{0}。

@item @var{whole}
滚动条的总长度，以像素为单位。在一些工具包中，包括GTK+，Emacs不能提取这个数据，所
以值总是@code{0}。

@item @var{timestamp}
事件发生的时间，以毫秒为单位。在某些工具包中，包括GTK+，Emacs不能提取这个数据，所
以值总是@code{0}。

@item @var{part}
点击发生在滚动条上的部分。它是@code{handle}(滚动条抓手)，@code{above-handle}(
抓手上方的区域)，@code{below-handle}(抓手下面的区域)，@code{up}(滚动条一端的向
上箭头)，或@code{down}(滚动条一端的向下箭头)符号之一。
@c 'top'、'bottom'和'end-scroll'代码似乎没有被使用。
@end table


@node 拖动事件
@subsection Drag Events
@cindex drag event
@cindex mouse drag event

使用Emacs，你甚至不用换衣服就可以发生拖动事件。每当用户按下鼠标按钮，然后在释放按
钮之前将鼠标移动到不同的字符位置时，都会发生@dfn{拖动事件}。像所有的鼠标事件一样，
拖动事件在Lisp中以列表的形式表示。列表同时记录了鼠标的起始位置和最终位置，就像这样：

@example
(@var{event-type}
 (@var{window1} START-POSITION)
 (@var{window2} END-POSITION))
@end example

对于拖动事件，符号@var{event-type}的名称包含@samp{drag-}的前缀。例如，在按住
按钮2的情况下拖动鼠标会产生@code{drag-mouse-2}事件。事件的第二个和第三个元素给
出了拖动的开始和结束位置，作为鼠标位置列表(@pxref{点击事件})。您可以以同样的方式
访问任何鼠标事件的第二个元素。然而，拖动事件可能会在最初选择的窗框边界之外结束。在
这种情况下，第三个元素的位置列表将包含该窗框而不是窗口。

@samp{drag-}前缀跟随修饰键前缀，如@samp{C-}和@samp{M-}。

如果@code{read-key-sequence}接收到一个没有键绑定的拖动事件，而对应的点击事件有
绑定，它就会在拖动的起始位置将拖动事件变为点击事件。这意味着您不必区分点击和拖动
事件，除非您想这样做。

@node 按下按钮事件
@subsection Button-Down Events
@cindex button-down event

点击和拖动事件发生在用户释放鼠标按钮时。它们不可能在更早的时候发生，因为在释放按
钮之前，无法区分点击和拖动。

如果你想在按钮被按下后立即采取行动，你需要处理@dfn{按下按钮}事件。@footnote{按
下按钮是拖动的保守反义词}。这些事件在按钮被按下后立即发生。它们由看起来与点击事件
完全相同的列表来表示(@pxref{点击事件})，只是@var{event-type}符号名包含
@samp{down-}的前缀。@samp{down-} 前缀跟随修饰键前缀，如@samp{C-}和@samp{M-}。

函数@code{read-key-sequence}忽略任何没有命令绑定的按钮式事件；因此，Emacs命令
循环也会忽略它们。这意味着，除非你想让它们做一些事情，否则你不需要担心定义按下按
钮事件。通常定义一个向下按钮事件的原因是为了让您可以跟踪鼠标运动（通过读取运动事
件），直到按钮被释放。@xref{运动事件}。

@node 重复事件
@subsection Repeat Events
@cindex repeat events
@cindex double-click events
@cindex triple-click events
@cindex mouse events, repeated

如果您在没有移动鼠标的情况下，连续多次按下同一个鼠标按钮，Emacs会为第二次和后续
的按压生成特殊的@dfn{重复}鼠标事件。

最常见的重复事件是@dfn{双击}事件。Emacs会在您点击一个按钮两次时生成一个双击事件
；当您释放按钮时，该事件就会发生（与所有点击事件一样正常）。

双击事件的事件类型包含前缀@samp{double-}。因此，双击第二个鼠标按钮，按住
@key{meta}，在Lisp程序中就会显示为@code{M-double-mouse-2}。如果双击事件没有
绑定，则使用对应的普通点击事件的绑定来执行。因此，除非你真的想关注双击功能，否则
你不需要关注。

当用户执行双击时，Emacs会先生成一个普通的点击事件，然后再生成一个双击事件。因此
，你必须设计双击事件的命令绑定，假设单击命令已经运行。它必须从单次点击的结果出发
，产生双击的预期结果。

这很方便，如果双击的意义某种程度上建立在单击的意义上------这是推荐的双击的用户
界面设计实践。

如果你点击一个按钮，然后再按下按钮，并开始按住按钮移动鼠标，那么当你最终释放按钮
时，你会得到一个@dfn{双拖}事件。其事件类型包含@samp{double-drag}而不是
@samp{drag}。如果一个双拖事件没有绑定，Emacs 就会像普通的拖拽事件一样寻找替代
绑定。

在双击或双拖事件之前，当用户第二次按下按钮时，Emacs会产生一个@dfn{double-down}
事件。它的事件类型包含@samp{double-down}，而不是只包含@samp{down}。如果双击事
件没有绑定，Emacs会寻找一个替代绑定，就像该事件是一个普通的按下按钮事件一样。如
果它也没有找到这样的绑定，则忽略双击事件。

总结一下，当你点击一个按钮，然后马上再按一次，Emacs会产生一个按下按钮事件和第一
次点击的点击事件，当你再次按下按钮时，会产生一个双向下事件，最后不是双击就是双拖
事件。

如果您点击一个按钮两次，然后再按一次，所有这些都是连续的，Emacs会产生一个
@dfn{triple-down}事件，然后是@dfn{triple-click}或@dfn{triple-dag}事件，这
些事件类型包含@samp{triple}而不是@samp{double}。如果任何三重事件没有绑定，
Emacs会使用对应的双重事件的绑定。

如果你点击一个按钮三次或三次以上，然后再按一次，第三次以后的按压事件都是三重事件。
Emacs没有为四倍、五倍等@: 事件单独设置事件类型。但是，你可以通过查看事件列表来精
确地了解按钮被按下的次数。

@defun event-click-count event
此函数返回导致@var{event}的连续按键次数。如果@var{event}是一个双击、双击或双拖
事件，则返回值为2。如果@var{event}是一个三重事件，则返回值为3或更大。如果
@var{event}是一个普通的鼠标事件 (不是重复事件)，值为 1。
@end defun

@defopt double-click-fuzz
要生成重复事件，连续的鼠标按键必须在屏幕上大约相同的位置。
@code{double-click-fuzz}的值指定了鼠标在两次连续点击之间可以移动（水平或垂直）
的最大像素数，以实现双击。

这个变量也是鼠标运动算作拖动的阈值。
@end defopt

@defopt double-click-time
要产生重复事件，连续按下按钮之间的毫秒数必须小于@code{double-click-time}的值。
将@code{double-click-time}设置为@code{nil}会完全禁止多点击检测。将其设置为
@code{t}则会取消时间限制，Emacs 将仅通过位置检测多点击。
@end defopt

@node 运动事件
@subsection Motion Events
@cindex motion event
@cindex mouse motion events

Emacs有时会生成@dfn{鼠标运动}事件来描述没有任何按钮活动的鼠标运动。鼠标运
动事件用类似这样的列表来表示：

@example
(mouse-movement POSITION)
@end example

@noindent
@var{position}是一个鼠标位置列表(@pxref{点击事件})，指定了鼠标光标的当前
位置。与拖动事件的结束位置一样，该位置列表可能代表最初选定的窗框边界之外的位
置，在这种情况下，列表中包含该窗框，而不是窗口。

特殊形式@code{track-mouse}可以在其主体中生成运动事件。在
@code{track-mouse}窗体之外，Emacs不会为单纯的鼠标运动生成事件，这些事件
也不会出现。@xref{鼠标追踪}。

@defvar mouse-fine-grained-tracking
当非@code{nil}时，即使是非常小的运动，也会产生鼠标运动事件，否则，只要鼠标
光标仍然指向文本中的同一个字型，就不会产生运动事件。否则，只要鼠标光标仍然指
向文本中的同一个字型，就不会产生运动事件。
@end defvar

@node 焦点事件
@subsection Focus Events
@cindex focus event

窗口系统为用户提供了控制哪个窗口获得键盘输入的一般方法。这种窗口的选择称为
@dfn{focus}。当用户在Emacs框架之间进行切换时，会产生一个@dfn{focus事件}。在
全局键图中，焦点事件的正常定义是在Emacs中选择一个新的窗框，正如用户所期望的那样
。@xref{输入焦点}，它还描述了与焦点事件相关的钩子。

焦点事件在Lisp中表示为类似这样的列表：

@example
(switch-frame @var{new-frame})
@end example

@noindent
其中@var{new-frame}是切换到的窗框。

一些X窗口管理器的设置使得只需将鼠标移动到一个窗口中就足以将焦点设置在那里。通常
情况下，在其他类型的输入到来之前，Lisp程序没有必要知道焦点的变化。Emacs只有当用
户在新的窗框中实际输入键盘键或按下鼠标按钮时才会产生焦点事件；仅仅在窗框之间移动
鼠标不会产生焦点事件。

在键序列中间的焦点事件会使序列混乱。所以Emacs从来不会在键序列的中间产生一个焦点
事件。如果用户在键序列中间改变焦点--也就是在前缀键之后--那么Emacs会重新排列事件
，使焦点事件出现在多事件键序列之前或之后，而不是在其内部。

@node 杂项事件
@subsection Miscellaneous System Events

其他一些事件类型代表在系统内的发生。

@table @code
@cindex @code{delete-frame} event
@item (delete-frame (@var{frame}))
这种事件表明用户给窗口管理器下达了删除某个窗口的命令，而这个窗口恰好是一个Emacs窗
框。

@code{delete-frame}事件的标准定义是删除@var{frame}。

@cindex @code{iconify-frame} event
@item (iconify-frame (@var{frame}))
这种事件表示用户使用窗口管理器对@var{frame}进行了图标化。它的标准定义是
@code{ignore}；因为窗框已经被图标化了，所以Emacs没有工作要做。这种事件类型的目的
是为了让您在需要的时候可以跟踪这种事件。

@cindex @code{make-frame-visible} event
@item (make-frame-visible (@var{frame}))
这种事件表明用户使用窗口管理器对@var{frame}进行了去图标化处理，它的标准定义是
@code{ignore}。它的标准定义是@code{ignore}；由于窗框已经被显示，Emacs没有工作要做。

@cindex @code{wheel-up} event
@cindex @code{wheel-down} event
@item (wheel-up @var{position})
@itemx (wheel-down @var{position})
这类事件是通过移动鼠标滚轮产生的。@var{position}元素是一个鼠标位置列表（
@pxref{点击事件}），指定事件发生时鼠标光标的位置。

@vindex mouse-wheel-up-event
@vindex mouse-wheel-down-event
这类事件只在某些系统上产生，在某些系统上使用@code{mouse-4}和@code{mouse-5}代替。
在某些系统中，会使用@code{mouse-4}和@code{mouse-5}来代替。对于可移植的代码，请使
用在@file{mwheel.el}中定义的@code{mouse-wheel-up-event}和
@code{mouse-wheel-down-event}变量来确定鼠标滚轮的事件类型。

@cindex @code{drag-n-drop} event
@item (drag-n-drop @var{position} @var{files})
当在Emacs以外的应用程序中选择一组文件，然后将其拖放到一个Emacs窗框上时，就会产生这
种事件。

元素@var{position}是描述事件位置的列表，格式与鼠标点击事件中使用的相同 (
@pxref{点击事件})，@var{files}是被拖放的文件名列表。通常处理该事件的方法是访问这
些文件。

这种事件的产生，目前只在某些种类的系统上。

@cindex @code{help-echo} event
@item help-echo
当鼠标指针移动到具有@code{help-echo}文本属性的缓冲区文本部分时，就会产生这种事件。
生成的事件有这样的形式：

@example
(help-echo @var{frame} @var{help} @var{window} @var{object} @var{pos})
@end example

@noindent
事件参数的确切含义以及这些参数用于显示帮助-回声文本的方式将在以下章节中描述
@ref{Text help-echo}。

@cindex @code{sigusr1} event
@cindex @code{sigusr2} event
@cindex user signals
@item sigusr1
@itemx sigusr2
当Emacs进程收到信号@code{SIGUSR1}和@code{SIGUSR2}时，会产生这些事件。它们不包含
额外的数据，因为信号不携带额外的信息。它们对调试很有用（@pxref{Error Debugging}）。

要捕捉用户信号，请将相应的事件绑定到@code{special-event-map}中的一个交互式命令上。
(@pxref{控制活动映射})。调用该命令时没有任何参数，具体的信号事件可以在
@code{last-input-event}（@pxref{Event Input Misc}.例如：

@smallexample
(defun sigusr-handler ()
  (interactive)
  (message "Caught signal %S" last-input-event))

(define-key special-event-map [sigusr1] 'sigusr-handler)
@end smallexample

为了测试信号处理程序，你可以让Emacs向自己发送一个信号：

@smallexample
(signal-process (emacs-pid) 'sigusr1)
@end smallexample

@cindex @code{language-change} event
@item language-change
当输入语言发生变化时，MS-Windows上就会产生这种事件，通常这意味着键盘键会向Emacs
发送不同语言的字符。生成的事件有这样的形式：

@smallexample
(language-change @var{frame} @var{codepage} @var{language-id})
@end smallexample

@noindent
这里@var{frame}是输入语言改变时当前的窗框；@var{codepage}是新的代码页号；
@var{language-id}是新输入语言的数字ID。与@var{codepage}对应的编码系统（
@pxref{编码系统}）是@code{cp@var{codepage}}或@code{windows-@var{codepage}}
。要将@var{language-id}转换为字符串(例如，将它用于各种语言相关的功能，如
@code{set-language-environment})，请使用@code{w32-get-locale-info}函数，
像这样：

@smallexample
;; Get the abbreviated language name, such as "ENU" for English
(w32-get-locale-info language-id)
;; Get the full English name of the language,
;; such as "English (United States)"
(w32-get-locale-info language-id 4097)
;; Get the full localized name of the language
(w32-get-locale-info language-id t)
@end smallexample
@end table

  如果这些事件中的一个事件出现在一个键序列的中间--也就是在一个前缀键之后--那么
Emacs就会重新安排事件的顺序，使这个事件出现在多事件键序列之前或之后，而不是在其内
部。

@node 事件示例
@subsection Event Examples

如果用户在同一位置上按下并释放鼠标左键，就会产生一连串类似这样的事件：

@smallexample
(down-mouse-1 (#<window 18 on NEWS> 2613 (0 . 38) -864320))
(mouse-1      (#<window 18 on NEWS> 2613 (0 . 38) -864180))
@end smallexample

在按住ctrl键的同时，用户可能会按住第二个鼠标键，将鼠标从一行拖到下一行。这将产生
两个事件，如图所示：

@smallexample
(C-down-mouse-2 (#<window 18 on NEWS> 3440 (0 . 27) -731219))
(C-drag-mouse-2 (#<window 18 on NEWS> 3440 (0 . 27) -731219)
                (#<window 18 on NEWS> 3510 (0 . 28) -729648))
@end smallexample

在按住meta键和shift键的同时，用户可能会在窗口的模式线上按下第二个鼠标键，然后将鼠
标拖入另一个窗口。这样就会产生一对这样的事件：

@smallexample
(M-S-down-mouse-2 (#<window 18 on NEWS> mode-line (33 . 31) -457844))
(M-S-drag-mouse-2 (#<window 18 on NEWS> mode-line (33 . 31) -457844)
                  (#<window 20 on carlton-sanskrit.tex> 161 (33 . 3)
                   -453816))
@end smallexample

输入焦点的窗框可能不会占据整个屏幕，用户可能会在框架的范围外移动鼠标。在
@code{track-mouse}特殊形式里面，会产生这样的事件：

@smallexample
(mouse-movement (#<frame *ielm* 0x102849a30> nil (563 . 205) 532301936))
@end smallexample

要处理一个SIGUSR1信号，定义一个交互式函数，并将其绑定到@code{signal usr1}事件序
列：

@smallexample
(defun usr1-handler ()
  (interactive)
  (message "Got USR1 signal"))
(global-set-key [signal usr1] 'usr1-handler)
@end smallexample

@node 分类事件
@subsection Classifying Events
@cindex event type
@cindex classifying events

  每个事件都有一个@dfn{事件类型}，它对事件进行分类，以便于键绑定。对于键盘事件，事
件类型等于事件值；因此，字符的事件类型是字符，函数键符号的事件类型是符号本身。对于列
表的事件，事件类型是列表中@sc{car}的符号。因此，事件类型总是一个符号或一个字符。

  同一类型的两个事件在键绑定方面是等价的；因此，它们总是运行相同的命令。然而，这并不
一定意味着它们做的事情是一样的，因为有些命令会从整个事件来决定做什么。例如，有些命令
使用鼠标事件的位置来决定在缓冲区的哪个位置采取行动。

有时，对事件进行更广泛的分类是有用的。例如，您可能想问一个事件是否涉及@key{META}键，
而不管使用的是其他哪个键或鼠标按钮。

emacs提供了函数@code{event-modifiers}和@code{event-basic-type}可以方便地获取这
些信息。

@defun event-modifiers event
此函数返回@var{event}的修饰符列表。这些修饰符是符号，它们包括@code{shift},
@code{control},@code{meta},@code{alt},@code{hyper}和@code{super}。此外，鼠标
事件符号的修饰符列表总是包含@code{click}、@code{drag}和@code{down}中的一个。对于
双倍或三倍事件，它还包含@code{double}或@code{triple}。

参数@var{event}可以是整个事件对象，也可以只是一个事件类型。如果@var{event}是一个从
未在当前Emacs会话中作为输入读取的事件中使用过的符号，那么@code{event-modifiers}可
以返回@code{nil}，即使@var{event}实际上有修改器。

下面是一些例子：

@example
(event-modifiers ?a)
     @result{} nil
(event-modifiers ?A)
     @result{} (shift)
(event-modifiers ?\C-a)
     @result{} (control)
(event-modifiers ?\C-%)
     @result{} (control)
(event-modifiers ?\C-\S-a)
     @result{} (control shift)
(event-modifiers 'f5)
     @result{} nil
(event-modifiers 's-f5)
     @result{} (super)
(event-modifiers 'M-S-f5)
     @result{} (meta shift)
(event-modifiers 'mouse-1)
     @result{} (click)
(event-modifiers 'down-mouse-1)
     @result{} (down)
@end example

点击事件的修饰符列表中明确包含@code{click}，但事件符号名称本身并不包含
@samp{click}。类似地，一个@acronym{ASCII}控制字符的修饰符列表，如
@samp{C-a}，包含@code{control}，尽管通过@code{read-char}读取这样一个事件将返
回去掉控制修饰位的值1。
@end defun

@defun event-basic-type event
本函数返回@var{event}所描述的按键或鼠标按钮，并删除所有修饰符。@var{event}参数
与@code{event-modifiers}里的这个参数相同。例如：

@example
(event-basic-type ?a)
     @result{} 97
(event-basic-type ?A)
     @result{} 97
(event-basic-type ?\C-a)
     @result{} 97
(event-basic-type ?\C-\S-a)
     @result{} 97
(event-basic-type 'f5)
     @result{} f5
(event-basic-type 's-f5)
     @result{} f5
(event-basic-type 'M-S-f5)
     @result{} f5
(event-basic-type 'down-mouse-1)
     @result{} mouse-1
@end example
@end defun

@defun mouse-movement-p object
如果@var{object}是鼠标移动事件，则该函数返回非@code{nil}。@xref{移动事件}。
@end defun

@defun event-convert-list list
该函数将修饰符名称和基本事件类型的列表转换为指定所有修饰符的事件类型。基本事件类型
必须是列表的最后一个元素。例如，

@example
(event-convert-list '(control ?a))
     @result{} 1
(event-convert-list '(control meta ?a))
     @result{} -134217727
(event-convert-list '(control super f1))
     @result{} C-s-f1
@end example
@end defun

@node 访问鼠标
@subsection Accessing Mouse Events
@cindex mouse events, data in
@cindex keyboard events, data in

  本节介绍了访问鼠标按钮或运动事件中的数据的方便函数。键盘事件数据可以使用同样的函
数来访问，但不适用于键盘事件的数据元素为零或@code{nil}。

  以下两个函数返回一个鼠标位置列表（@pxref{点击事件}），指定鼠标事件的位置。

@defun event-start event
返回@var{event}的起始位置。

如果@var{event}是点击或按压事件，则返回事件的位置。如果@var{event}是拖动事件，
则返回拖动的起始位置。
@end defun

@defun event-end event
返回@var{event}的结束位置。

如果@var{event}是一个拖动事件，则返回用户释放鼠标按钮的位置。如果@var{event}是
一个点击或按压事件，该值实际上是起始位置，这是此类事件的唯一位置。
@end defun

@defun posnp object
如果@var{object}是一个鼠标位置列表，则该函数返回非@code{nil}，格式见
@ref{点击事件}）；否则返回@code{nil}。
@end defun

@cindex mouse position list, accessing
  这些函数以鼠标位置列表作为参数，并返回其中的各个部分：

@defun posn-window position
返回@var{position}所在的窗口。如果@var{position}代表的是事件发生的窗框之外的
位置，则返回该窗框。
@end defun

@defun posn-area position
返回@var{position}中记录的窗口区域。当事件发生在窗口的文本区域时，它返回
@code{nil}；否则，它是一个标识事件发生区域的符号。
@end defun

@defun posn-point position
返回@var{position}中的缓冲区位置。当事件发生在窗口的文本区域、边缘区域或边缘上
时，这是一个整数，用于指定缓冲区的位置。否则，该值是未定义的。
@end defun

@defun posn-x-y position
返回@var{position}中基于像素的x和y坐标，作为一个cons单元格
@w{@code{(@var{x} . @var{y})}}。这些坐标是相对于@code{posn-window}给出的窗
口而言的。

这个例子展示了如何将窗口文本区域的窗口相关坐标转换为窗框相关坐标：

@example
(defun frame-relative-coordinates (position)
  "Return frame-relative coordinates from POSITION.
POSITION is assumed to lie in a window text area."
  (let* ((x-y (posn-x-y position))
         (window (posn-window position))
         (edges (window-inside-pixel-edges window)))
    (cons (+ (car x-y) (car edges))
          (+ (cdr x-y) (cadr edges)))))
@end example
@end defun

@defun posn-col-row position
此函数返回一个cons单元格@w{@code{(@var{col} . @var{row})}，包含与
@var{position}所描述的缓冲区位置相对应的估计列和行。返回值以窗框的默认字符宽度
和默认行高（包括间距）为单位，由@var{x}和@var{y}对应@var{position}的值计算得
出。(因此，如果实际字符的大小是非默认的，那么实际的行和列可能会与这些计算值不同。)

请注意，@var{row}是从文本区域的顶部开始计算的。如果@var{position}给出的窗口有
标题行(@pxref{标题行})或制表行，那么它们会被@emph{not}包括在@var{row}的计数中。
@end defun

@defun posn-actual-col-row position
返回@var{position}中的实际行和列，作为一个cons单元格
@w{@code{(@var{col} . @var{row})}}。这些值是由@var{position}给出的窗口中实
际的行和列。详情请参考@xref{点击事件}。如果@var{position}不包含实际的位置值，
函数返回@code{nil}；在这种情况下，可以使用@code{posn-col-row}来获取近似值。

请注意，这个函数并没有考虑到字符在显示上的视觉宽度，比如标签字符或图像所占的视觉
列数。如果你需要用规范字符单位的坐标，可以使用@code{posn-col-row}代替。
@end defun

@defun posn-string position
返回由@var{position}描述的字符串对象，可以是@code{nil}。(这意味着
@var{position}描述的是缓冲区的文本)，或者一个cons单元格
@w{@code{(@var{string} . @var{string-pos})}}。
@end defun

@defun posn-image position
返回@var{position}中的图像对象，可以是@code{nil}。(如果在@var{position}处没
有图像的话)，或者图像规格@w{@code{(image @dots{})}}。
@end defun

@defun posn-object position
返回由@var{position}描述的图像或字符串对象，可以是@code{nil}。(这意味着
@var{position}描述的是缓冲区的文本)，一个图像@w{@code{(image @dots{})}}，或者
一个cons单元格@w{@code{(@var{string} . @var{string-pos})}}。
@end defun

@defun posn-object-x-y position
返回基于像素的x和y坐标，相对于@var{position}描述的对象的左上角，作为一个cons单元格
@w{@code{(@var{dx} . @var{dy})}}。如果@var{position}描述的是缓冲区文本，返回最
接近该位置的缓冲区文本字符的相对坐标。
@end defun

@defun posn-object-width-height position
返回由@var{position}描述的对象的像素宽度和高度，作为一个cons单元格
@code{(@var{width} . @var{height})}。如果@var{position}描述的是一个缓冲区的位
置，则返回该位置的字符大小。
@end defun

@cindex timestamp of a mouse event
@defun posn-timestamp position
返回@var{position}中的时间戳。这是事件发生的时间，以毫秒为单位。
@end defun

  这些函数计算给定的特定缓冲区位置或屏幕位置的位置列表。你可以通过上述函数访问这个
位置列表中的数据。

@defun posn-at-point &optional pos window
此函数返回@var{pos}在@var{window}中的位置列表。@var{pos}默认为@var{window}中的
点；@var{window}默认为选中的窗口。

如果@var{posn-at-point}在@var{window}中不可见，则@code{posn-at-point}返回
@code{nil}。
@end defun

@defun posn-at-x-y x y &optional frame-or-window whole
此函数返回指定的窗框或窗口@var{x}和@var{y}像素坐标的位置信息，
@var{frame-or-window}，默认为选定的窗口。坐标@var{x}和@var{y}是相对于所使用的窗
框或窗口而言的。

如果@var{whole}是@code{nil}，则坐标是相对于窗口文本区域的，否则是相对于整个窗口区
域的，包括滚动条、边框和边缘。
@end defun

@node 访问滚动条
@subsection Accessing Scroll Bar Events
@cindex scroll bar events, data in

  这些功能对解码滚动条事件很有用。

@defun scroll-bar-event-ratio event
该函数返回滚动条事件在滚动条中的垂直位置的分数。值是一个包含两个整数的单元格
@code{(@var{portion} . @var{whole})}，其比例是分数位置。
@end defun

@defun scroll-bar-scale ratio total
这个函数将@var{ratio}乘以@var{total}，并将结果取整。参数@var{ratio}不是一个数字，
而是一对@code{(@var{num} . @var{denom})}---典型的是由
@code{scroll-bar-event-ratio} 返回的值。

这个功能可以方便地将滚动条上的一个位置缩放到缓冲区的位置。这里是如何做到这一点：

@example
(+ (point-min)
   (scroll-bar-scale
      (posn-x-y (event-start event))
      (- (point-max) (point-min))))
@end example

记得滚动条事件有两个整数组成一个比率，代替一对x和y坐标。
@end defun

@node 事件字符串
@subsection Putting Keyboard Events in Strings
@cindex keyboard events in strings
@cindex strings with keyboard events

  在大多数使用字符串的地方，我们将字符串概念化为包含文本字符--与缓冲区或文件中的字
符相同。偶尔Lisp程序会使用一些概念上包含键盘字符的字符串，例如，它们可能是键序列或
键盘宏定义。然而，由于历史兼容性的原因，在字符串中存储键盘字符是一件复杂的事情，而且
并不总是可能的。

  我们建议新程序不要将键盘事件存储在字符串中，以避免处理这些复杂的问题。下面是如何做
到这一点：

@itemize @bullet
@item
当您打算将向量用作@code{lookup-key}和@code{define-key}的参数以外的其他用途时，
请使用向量而不是字符串来表示键序列。例如，您可以使用
@code{read-key-sequence-vector}来代替@code{read-key-sequence}，使用
@code{this-command-keys-vector} 来代替 @code{this-command-keys}。

@item
使用向量来编写包含元字符的密钥序列常量，即使是直接传递给@code{define-key}。

@item
当你需要查看一个可能是字符串的键序列的内容时，使用
@code{listify-key-sequence}。(@pxref{事件输入杂项})，先将其转换为一个列表。
@end itemize

  复杂性源于键盘输入字符可以包含的修饰位。除了Meta修饰位，这些修饰位都不能包含在字
符串中，Meta修饰位只允许在特殊情况下使用。

最早的GNU Emacs版本将元字符表示为128到255范围内的代码。当时，基本字符代码的范围是
0到127，所以所有的键盘字符代码都可以放在一个字符串中。许多Lisp程序在字符串常量中使
用@samp{/M-}来代表元字符，特别是在@code{define-key}和类似函数的参数中，按键序列
和事件序列总是用字符串表示。

当我们增加了对超过127的更大的基本字符代码的支持，以及额外的修饰位时，我们不得不改变
元字符的表示方法。现在，在一个字符中表示元修饰符的标志是
@tex
@math{2^{27}}
@end tex
@ifnottex
2**27
@end ifnottex
而这样的数字不能包含在一个字符串中。

为了支持字符串常量中带有@samp{\M-}的程序，有一些特殊的规则可以在字符串中包含某些元
字符。以下是将字符串解释为输入字符序列的规则：

@itemize @bullet
@item
如果键盘字符值在0到127的范围内，它可以不变地进入字符串。

@item
这些字符的元变体，其代码范围是
@tex
@math{2^{27}}
@end tex
@ifnottex
2**27
@end ifnottex
到
@tex
@math{2^{27} + 127},
@end tex
@ifnottex
2**27+127,
@end ifnottex
也可以放在字符串中，但你必须改变它们的数值。你必须设置
@tex
@math{2^{7}}
@end tex
@ifnottex
2**7
@end ifnottex
位，而不是
@tex
@math{2^{27}}
@end tex
@ifnottex
2**27
@end ifnottex
位，结果是一个介于128和255之间的值。只有一个单字节的字符串才能包含这些代码。

@item
256以上的非@acronym{ASCII}字符可以包含在多字节字符串中。

@item
其他键盘字符事件不能放入字符串中。这包括128到255范围内的键盘事件。
@end itemize

  像@code{read-key-sequence}这样构造键盘输入字符字符串的函数遵循这些规则：当事
件无法放入字符串时，它们会构造向量而不是字符串。

  当你在字符串中使用读取语法@samp{M-}时，它会产生一个128到255范围内的代码--也就
是你修改相应的键盘事件以将其放入字符串中得到的相同代码。 因此，在字符串中的元事件
的工作是一致的，无论它们是如何进入字符串的。

然而，大多数程序都可以通过遵循本节开头的建议来避免这些问题。

@node 读取输入
@section Reading Input
@cindex read input
@cindex keyboard input

  编辑器命令循环使用函数@code{read-key-sequence}读取键序列，该函数使用
@code{read-event}。这些函数和其他用于事件输入的函数也可以在Lisp程序中使用。另请
参见@ref{临时显示}中的@code{momentary-string-display}，以及@ref{Waiting}中
的@code{sit-for}。@xref{终端输入}，用于控制终端输入模式和调试终端输入的函数和变量。

  关于更高级别的输入设施，请参见@ref{迷你缓冲区}。

@menu
* 键序列输入::          如何读取一个关键序列。
* 读取一个事件::        如何只读取一个事件。
* 事件修改::            Emacs如何在读取事件时修改它们。
* 调用输入法::          读取一个事件如何使用输入法。
* 引用字符输入::        要求用户指定一个字符。
* 事件输入杂项::        如何重读或丢弃输入事件。
@end menu

@node 键序列输入
@subsection Key Sequence Input
@cindex key sequence input

  命令循环通过调用@code{read-key-sequence}，每次读取输入一个键序列。Lisp程序也可
以调用这个函数，例如，@code{describe-key}就用它来读取要描述的键。

@defun read-key-sequence prompt &optional continue-echo dont-downcase-last switch-frame-ok command-loop
这个函数读取一个键序列并以字符串或向量的形式返回。它不断地读取事件，直到积累了一个完
整的键序，也就是说，足够使用当前活动的键位图来指定一个非前缀命令。(请记住，一个以鼠
标事件开始的键序列是使用鼠标所在窗口的缓冲区的键映射来读取的，而不是当前缓冲区。)

如果事件都是字符，而且都能装进一个字符串，那么@code{read-key-sequence}返回一个字符
串(@pxref{事件字符串})。否则，它将返回一个向量，因为向量可以容纳所有类型的事件--字符
、符号和列表。字符串或向量的元素是键序列中的事件。

读取一个键序列包括以各种方式翻译事件。@xref{翻译键图}。

参数@var{prompt}是要在回音区显示的字符串作为提示，或者@code{nil}，意思是不显示提示。
参数@var{continue-echo}，如果是非@code{nil}，则表示将此键作为前一个键的延续进行回显。

通常情况下，如果原来的事件没有定义，而定义了等价的小写字母，那么任何大写字母事件都会被
转换为小写字母。参数@var{dont-downcase-last}，如果是非@code{nil}，则表示不要将最后
一个事件转换为小写。这适用于读取待定义的键序列。

参数@var{switch-frame-ok}如果是非@code{nil}，意味着如果用户在输入任何东西之前切换窗
框，这个函数应该处理@code{switch-frame}事件。如果用户在按键序列的中间，或者在序列开始
时切换窗框，但@var{switch-frame-ok}为@code{nil}，那么该事件将被推迟到当前按键序列之
后。

参数@var{command-loop}，如果是非@code{nil}，则表示这个键序列被一个接一个的读取命令的
东西所读取。如果调用者只读取一个键序列，那么应该是@code{nil}。

在下面的例子中，Emacs在回音区显示提示符@samp{?}，然后用户输入@kbd{C-x C-f}。

@example
(read-key-sequence "?")

@group
---------- Echo Area ----------
?@kbd{C-x C-f}
---------- Echo Area ----------

     @result{} "^X^F"
@end group
@end example

函数@code{read-key-sequence}可以抑制退出。在使用该函数读取时输入的@kbd{C-g}与其他
字符一样，不会设置@code{quit-flag}。@xref{退出}。
@end defun

@defun read-key-sequence-vector prompt &optional continue-echo dont-downcase-last switch-frame-ok command-loop
这和@code{read-key-sequence}类似，只是它总是以向量的形式返回键序列，而不是以字符串
的形式。@xref{事件字符串}。
@end defun

@cindex upper case key sequence
@cindex downcasing in @code{lookup-key}
@cindex shift-translation
如果一个输入字符是大写的（或者有shift修饰符），并且没有键绑定，但是它的小写字符有键
绑定，那么@code{read-key-sequence}就会把这个字符转换为小写。请注意，
@code{lookup-key}不会以这种方式进行大小写转换。

@vindex this-command-keys-shift-translated
当读取输入结果出现这样的@dfn{shift-translation}时，Emacs会将变量
@code{this-command-keys-shift-translated}设置为一个非@code{nil}值。如果Lisp程
序需要修改被shift-translation键调用时的行为，可以检查这个变量。例如，函数
@code{handle-shift-selection}检查这个变量的值，以决定如何激活或停用该区域（
@pxref{The Mark，handle-shift-selection}）。

函数@code{read-key-sequence}也会转换一些鼠标事件。它将未绑定的拖动事件转换为点击事
件，并完全丢弃未绑定的按键事件。它还会对焦点事件和其他窗口事件进行重新组合，使它们不
会与其他事件一起出现在键序中。

@cindex @code{tab-line} prefix key
@cindex @code{header-line} prefix key
@cindex @code{mode-line} prefix key
@cindex @code{vertical-line} prefix key
@cindex @code{horizontal-scroll-bar} prefix key
@cindex @code{vertical-scroll-bar} prefix key
@cindex @code{menu-bar} prefix key
@cindex @code{tab-bar} prefix key
@cindex mouse events, in special parts of frame
当鼠标事件发生在窗口的特殊部分，如模式线或滚动条时，事件类型并没有显示出什么特别的东
西------它与通常代表鼠标按钮和修饰键组合的符号相同。窗口部分的信息被保存在事件的其他
地方---坐标中。但是@code{read-key-sequence}将这些信息翻译成了虚构的前缀键，所有这
些都是符号：@code{tab-line}，@code{header-line}，@code{horizontal-scroll-bar}
，@code{menu-bar}，@code{tab-bar}，@code{module-line}，@code{vertical-line}，
和@code{vertical-scroll-bar}。您可以通过使用这些假想的前缀键定义的键序列来定义特殊
窗口部分中鼠标点击的含义。

例如，如果你调用@code{read-key-sequence}，然后在窗口的模式行上点击鼠标，你会得到两
个事件，就像这样：

@example
(read-key-sequence "Click on the mode line: ")
     @result{} [mode-line
         (mouse-1
          (#<window 6 on NEWS> mode-line
           (40 . 63) 5959987))]
@end example

@defvar num-input-keys
这个变量的值是迄今为止在这个Emacs会话中处理过的键序列的数目。这包括从终端读取的键序和
从正在执行的键盘宏读取的键序。
@end defvar

@node 读取一个事件
@subsection Reading One Event
@cindex reading a single event
@cindex event, reading only one

  命令输入的最低级别函数是@code{read-event}、@code{read-char}和
@code{read-char-exclusive}。

  如果你需要一个使用迷你缓冲区读取字符的函数，请使用
@code{read-char-from-minibuffer}。
(@pxref{多重查询})。

@defun read-event &optional prompt inherit-input-method seconds
该函数读取并返回命令输入的下一个事件，必要时等待，直到有事件可用。

返回的事件可能直接来自用户，或者来自键盘宏。它不会被键盘的输入编码系统解码（
@pxref{终端I/O编码}）。

如果可选参数@var{prompt}是非@code{nil}，那么它应该是一个字符串，作为提示显示在回显
区。如果@var{prompt}是非@code{nil}或字符串@samp{""}，则@code{read-event}不显示
任何消息来表示它正在等待输入；相反，它通过回显来提示：它显示导致当前命令或被当前命令
读取的事件的描述。@xref{回声区}。

如果@var{inherit-input-method}是非@code{nil}，则采用当前的输入法（如果有的话），
以便能够输入一个非@acronym{ASCII}字符。否则，读取该事件时，输入法处理将被禁用。

如果@code{cursor-in-echo-area}是非@code{nil}，那么@code{read-event}会将光标暂时
移动到回声区，并显示在回声区的任何消息的末尾。否则，@code{read-event}不会移动光标。

如果@var{seconds}是非@code{nil}，那么它应该是一个数字，指定等待输入的最大时间，以秒
为单位。如果在这段时间内没有输入，@code{read-event}将停止等待并返回@code{nil}。浮点
数@var{seconds}的意思是等待一个小数的秒数。有些系统只支持整数秒，在这些系统中，
@var{seconds}会被四舍五入。如果@var{seconds}是@code{nil}，则@code{read-event}会
尽可能久地等待输入的到来。

如果@var{seconds}是@code{nil}，Emacs在等待用户输入时被视为空闲。空闲计时器---用
@code{run-with-idle-timer}创建的计时器。(@pxref{空闲计时器})---可以在这段时间内运
行。但是，如果@var{seconds}是非@code{nil}，则闲置状态保持不变。如果Emacs在调用
@code{read-event}时是非空闲状态，那么在@code{read-event}的整个运行过程中，它都保持
非空闲状态；如果Emacs是空闲状态（如果调用发生在空闲定时器内，则可能发生这种情况），则保
持空闲状态。

如果@code{read-event}得到一个被定义为帮助字符的事件，那么在某些情况下，
@code{read-event}直接处理该事件而不返回。@xref{帮助函数}。某些其他事件，称为
@dfn{特殊事件}，也是直接在@code{read-event}内部处理的。(@pxref{Special Events})。

以下是调用@code{read-event}后按右键功能键的情况：

@example
@group
(read-event)
     @result{} right
@end group
@end example
@end defun

@defun read-char &optional prompt inherit-input-method seconds
这个函数读取并返回一个字符输入事件。如果用户产生的事件不是字符（例如，鼠标点击或函
数键事件），@code{read-char}将发出错误信号。参数的作用与@code{read-event}相同。

如果事件中有修饰符，Emacs会尝试解析这些修饰符并返回相应字符的代码。例如，如果用户
键入@kbd{C-a}，函数返回1，即@samp{C-a}字符的@acronym{ASCII}代码。如果有些修饰
符不能反映在字符代码中，@code{read-char}就会在返回的事件中留下未解决的修饰符位设
置。例如，如果用户输入@kbd{C-M-a}，函数返回134217729，十六进制是8000001，即
@: @samp{C-a}，并设置了Meta修饰位。这个值不是有效的字符代码：它没有通过
@code{characterp}测试（@pxref{Character Codes}）。使用
@code{event-basic-type}(@pxref{Classifying Events})来恢复去掉修饰位的字符代
码；使用@code{event-modifiers}来测试@code{read-char}返回的字符事件中的修饰位。

在下面的第一个例子中，用户输入字符@kbd{1}(@acronym{ASCII}代码49)。第二个例子显
示了一个键盘宏定义，它使用@code{eval-expression}从minibuffer中调用
@code{read-char}。@code{read-char}读取键盘宏的下一个字符，即@kbd{1}。然后
@code{eval-expression}在回声区显示其返回值。

@example
@group
(read-char)
     @result{} 49
@end group

@group
;; @r{我们假设您在这里使用@kbd{M-:}来评估这个函数。}
(symbol-function 'foo)
     @result{} "^[:(read-char)^M1"
@end group
@group
(execute-kbd-macro 'foo)
     @print{} 49
     @result{} nil
@end group
@end example
@end defun

@defun read-char-exclusive &optional prompt inherit-input-method seconds
这个函数读取并返回一个字符输入事件。如果用户生成的事件不是字符事件，
@code{read-char-exclusive}会忽略它，并读取另一个事件，直到得到一个字符。参数的工
作原理和@code{read-event}一样。返回的值可以包括修饰位，就像@code{read-char}一样。
@end defun

  以上功能都不抑制退出。

@defvar num-nonmacro-input-events
这个变量保存了迄今为止从终端接收到的输入事件的总数------不包括键盘宏产生的事件。
@end defvar

  我们强调，与@code{read-key-sequence}不同，函数 @code{read-event}、
@code{read-char} 和 @code{read-char-exclusive} 并不执行
@ref{Translation Keymaps}中描述的翻译。如果您希望在考虑到这些翻译的情况下读取单个
键，请使用函数 @code{read-key}：

@defun read-key &optional prompt
这个函数读取一个单一的键，它介于@code{read-key-sequence}和@code{read-event}之
间。它介于@code{read-key-sequence}和@code{read-event}之间。与前者不同的是，它读
取的是单个键，而不是键序列。与后者不同的是，它不返回一个原始事件，而是根据
@code{input-decode-map}、@code{local-function-key-map}和
@code{key-translation-map}对用户输入进行解码和翻译。(
@pxref{Translation Keymaps})。

参数@var{prompt}是一个要在回声区显示的字符串作为提示，或者@code{nil}，意思是不显
示提示。
@end defun

@defun read-char-choice prompt chars &optional inhibit-quit
这个函数使用@code{read-key}读取并返回一个字符。它忽略任何不属于@var{chars}（一
个可接受的字符列表）成员的输入。也可以选择在等待有效输入时忽略键盘退出事件。如果您
绑定了@code{help-form}(@pxref{帮助函数})到一个非@code{nil}值，同时调用
@code{read-char-choice}，然后按@code{help-char}使其评估@code{help-form}并
显示结果。然后继续等待一个有效的输入字符，或者键盘退出。
@end defun

@defun read-multiple-choice prompt choices
向用户提出一个多选题。@var{prompt}应该是一个字符串，将被显示为提示。

@var{choices}是一个alist，其中每个条目中的第一个元素是一个要输入的字符，第二个元
素是条目的简短名称，将在提示时显示（如果有空间，可能会被缩短），第三个可选条目是一个
较长的解释，将在用户请求更多帮助时显示在帮助缓冲区中。

返回值是来自@var{choices}的匹配值。

@lisp
(read-multiple-choice
 "Continue connecting?"
 '((?a "always" "Accept certificate for this and future sessions.")
   (?s "session only" "Accept certificate this session only.")
   (?n "no" "Refuse to use certificate, close connection.")))
@end lisp

@code{read-multiple-choice-face}字体被用于在图形终端上高亮显示名称字符串中的匹配
字符。

@end defun

@node 事件修改
@subsection Modifying and Translating Input Events
@cindex modifiers of events
@cindex translating input events
@cindex event translation

  Emacs根据@code{extra-keyboard-modifiers}对读取的每个事件进行修改，然后通过
@code{keyboard-translate-table}进行翻译(如果适用)，然后再从
@code{read-event}中返回。

@defvar extra-keyboard-modifiers
这个变量让Lisp程序可以"按"键盘上的修饰键。这个值是一个字符。只有该字符的修饰符才是
重要的。每当用户输入一个键盘键时，它就会被改变，就像这些修饰键被按住一样。例如，如果
您将@code{extra-keyboard-modifiers}绑定到@code{?\C-\M-a}，那么在绑定范围内输入
的所有键盘输入字符都会被应用到控制和元修饰符上。相当于整数0的字符@code{?\C-@@}，在
此目的下不作为控制字符，而是作为一个没有修饰符的字符。因此，将
@code{extra-keyboard-modifiers}设置为0，会取消任何修改。

当使用窗口系统时，程序可以用这种方式按下任何一个修饰键。否则，实际上只能按@key{CTL}
和@key{META}键。

请注意，这个变量只适用于真正来自键盘的事件，对鼠标事件或任何其他事件没有影响。
@end defvar

@defvar keyboard-translate-table
这个终端本地变量是键盘字符的翻译表。它可以让你在不改变任何命令绑定的情况下重新调整
键盘上的按键。它的值通常是一个字符表，否则就是@code{nil}。(它也可以是一个字符串或
向量，但这已经过时了。)

如果@code{keyboard-translate-table}是一个字符表(@pxref{字符表})，那么从键盘上
读取的每个字符都会在这个字符表中查找。如果在那里找到的值是非@code{nil}，那么就用
它来代替实际的输入字符。

需要注意的是，这个翻译是一个字符从终端读取后的第一件事。记录保存功能如
@code{recent-keys}和dribble文件会记录翻译后的字符。

还请注意，这种翻译是在向输入法提供字符之前完成的（@pxref{输入法}）。使用
@code{translation-table-for-input}(@pxref{Translation of Characters})，如
果你想在输入法操作后翻译字符。
@end defvar

@defun keyboard-translate from to
本函数修改@code{keyboard-translate-table}，将字符代码@var{from}翻译成字符代码
@var{to}。如果需要的话，它会创建一个键盘翻译表。
@end defun

  下面是一个使用@code{keyboard-translate-table}使@kbd{C-x}、@kbd{C-c}和
@kbd{C-v}执行剪切、复制和粘贴操作的例子：

@example
(keyboard-translate ?\C-x 'control-x)
(keyboard-translate ?\C-c 'control-c)
(keyboard-translate ?\C-v 'control-v)
(global-set-key [control-x] 'kill-region)
(global-set-key [control-c] 'kill-ring-save)
(global-set-key [control-v] 'yank)
@end example

@noindent
在支持扩展@acronym{ASCII}输入的图形终端上，你仍然可以通过用shift键输入其中一个字符来
获得标准Emacs的含义。这使得它在键盘翻译方面是一个不同的字符，但它具有相同的通常含义。

  @xref{Translation Keymaps}，用于在@code{read-key-sequence}层面翻译事件序列的机制。

@node 调用输入法
@subsection Invoking the Input Method
@cindex invoking input method

  事件读取函数调用当前的输入方法（如果有的话）（@pxref{输入法}）。如果
@code{input-method-function}的值是非@code{nil}，它应该是一个函数；当
@code{read-event}读取一个没有修饰位的打印字符（包括@key{SPC}）时，它就会调用该函数，将
该字符作为参数传递。

@defvar input-method-function
如果这是非@code{nil}，其值指定了当前的输入法函数。

@strong{警告：}不要用 @code{let} 绑定这个变量。它通常是缓冲区本地的，如果你在读
取输入时绑定它（这正是你@emph{将}绑定它的时候），在Emacs等待时异步切换缓冲区会导
致值被还原到错误的缓冲区中。
@end defvar

  输入法函数应该返回一个应被用作输入的事件列表。如果列表是@code{nil}，表示没有输
入，所以@code{read-event}等待另一个事件）。这些事件会在
@code{unread-command-events}中的事件之前被处理(@pxref{Event Input Misc})。
输入法函数返回的事件即使是打印没有修饰位的字符，也不会再传递给输入法函数。

  如果输入方法函数调用@code{read-event}或@code{read-key-sequence}，应先将
@code{input-method-function}绑定到@code{nil}，以防止递归。

  读取键序列的第二个和后续事件时，不调用输入法函数。因此，这些字符不受输入法处理。
输入法函数应该测试@code{overriding-local-map}和
@code{overriding-terminal-local-map}的值；如果这些变量中的任何一个是非
@code{nil}，输入法应该把它的参数放入一个列表中，并返回该列表，不做进一步处理。

@node 引用字符输入
@subsection Quoted Character Input
@cindex quoted character input

  您可以使用函数@code{read-quoted-char}来要求用户指定一个字符，并允许用户方便地
指定一个控制字符或元字符，可以是字面的，也可以是八进制字符代码。命令
@code{quoted-insert}就使用了这个函数。

@defun read-quoted-char &optional prompt
@cindex octal character input
@cindex control characters, reading
@cindex nonprinting characters, reading
这个函数与@code{read-char}类似，但如果读取的第一个字符是八进制数字(0--7)，则读
取任意数量的八进制数字(但如果发现非八进制数字则停止)，并返回该数字字符代码所代表的
字符。如果终止八进制数字序列的字符是@key{RET}，那么它将被丢弃。任何其他终止字符在
本函数返回后作为输入。

退出在读取第一个字符时被抑制，这样用户就可以输入@kbd{C-g}。@xref{Quitting}.

如果提供了@var{prompt}，它指定了一个用于提示用户的字符串。提示字符串总是显示在回
声区，后面是一个@samp{-}。

在下面的例子中，用户输入八进制数177（十进制数是127）。

@example
(read-quoted-char "What character")

@group
---------- Echo Area ----------
What character @kbd{1 7 7}-
---------- Echo Area ----------

     @result{} 127
@end group
@end example
@end defun

@need 2000
@node 事件输入杂项
@subsection Miscellaneous Event Input Features

本节介绍了如何在不使用事件的情况下提前偷看事件，如何检查待处理的输入，以及如何
丢弃待处理的输入。也请参见函数@code{read-passwd}。(@pxref{读取密码})。

@defvar unread-command-events
@cindex next input
@cindex peeking at input
这个变量保存了一个等待作为命令输入读取的事件列表。事件按其在列表中出现的顺序使用，
并在使用时逐一删除。

之所以需要这个变量，是因为在某些情况下，一个函数读取了一个事件，然后决定不使用它。
将事件存储在这个变量中会导致事件被正常处理，由命令循环或由函数读取命令输入。

@cindex prefix argument unreading
例如，实现数字前缀参数的函数可以读取任意数量的数字。当它发现一个非数字的事件时，必
须将该事件取消读取，以便命令循环可以正常读取。同样的，增量搜索也使用这个功能，在搜
索中解读没有特殊意义的事件，因为这些事件应该退出搜索，然后正常执行。

从键序列中提取事件并将其放入@code{unread-command-events}的可靠而简单的方法是使
用@code{listify-key-sequence}(见下文)。

通常你把事件添加到这个列表的前面，这样最近未读的事件就会先被重读。

从这个列表中读取的事件通常不会被添加到当前命令的键序列中（如
@code{this-command-keys}所返回的那样），因为这些事件在第一次读取时已经被添加过
一次。@w{@code{(t . @var{event})}}形式的元素会强制将@var{event}添加到当前命令
的键序列中。

@cindex not recording input events
@cindex input events, prevent recording
从此列表中读取的元素通常由记录保存功能 (@pxref{Recording Input}) 和定义键盘宏时
(@pxref{键盘宏}) 记录。但是，@w{@code{(no-record . @var{event})}}这种形式的元
素会导致@var{event}被正常处理而不被记录。
@end defvar

@defun listify-key-sequence key
这个函数将字符串或向量@var{key}转换为单个事件的列表，你可以将其放入
@code{unread-command-events}中。
@end defun

@defun input-pending-p &optional check-timers
@cindex waiting for command key input
该函数用于判断当前是否有可用的命令输入，如果有可用的输入，则立即返回，否则返回
@code{nil}。如果有可用的输入，则立即返回@code{t}，否则返回@code{nil}。在极少数情
况下，当没有可用的输入时，它可能返回@code{t}。

如果可选的参数@var{check-timers}是非@code{nil}，那么如果没有输入，Emacs会运行任
何准备好的计时器。@xref{计时器}.
@end defun

@defvar last-input-event
这个变量记录了最后一次读取的终端输入事件，无论是作为命令的一部分还是由Lisp程序显式读取。

在下面的例子中，Lisp程序读取字符@kbd{1}，@acronym{ASCII}代码49。它成为
@code{last-input-event}的值，而@kbd{C-e}(我们假设@kbd{C-x C-e}命令是用来评估这个
表达式的)仍然是@code{last-command-event}的值。

@example
@group
(progn (print (read-char))
       (print last-command-event)
       last-input-event)
     @print{} 49
     @print{} 5
     @result{} 49
@end group
@end example
@end defvar

@defmac while-no-input body@dots{}
这个构造运行@var{body}表单，并返回最后一个表单的值--但仅限于没有输入的情况。如
果在执行@var{body}表单的过程中出现了任何输入，它就会中止这些表单（工作方式很像
退出）。如果真正的退出，@code{while-no-input}表单会返回@code{nil}；如果有其
他输入，则返回@code{t}。

如果@var{body}的某个部分将@code{inhibit-quit}绑定到非@code{nil}，那么在这些
部分期间输入的到来不会导致中止，直到该部分结束。

如果你想区分@var{body}计算的所有可能的值和两种中止条件，可以写这样的代码：

@example
(while-no-input
  (list
    (progn . @var{body})))
@end example
@end defmac

@defvar while-no-input-ignore-events
这个变量允许设置@code{while-no-input}应该忽略哪些特殊事件。它是一个事件符号的
列表(@pxref{事件例子})。

@end defvar

@defun discard-input
@cindex flushing input
@cindex discarding input
@cindex keyboard macro, terminating
这个函数丢弃终端输入缓冲区的内容，并取消任何可能正在定义的键盘宏。返回@code{nil}。

在下面的例子中，用户可以在开始评估表单后立即键入一些字符。在@code{sleep-for}完成
睡眠后，@code{discard-input}会丢弃睡眠期间输入的任何字符。

@example
(progn (sleep-for 2)
       (discard-input))
     @result{} nil
@end example
@end defun

@node 特殊事件
@section Special Events

@cindex special events
某些@dfn{特殊事件}在非常低的层次上被处理----只要它们被读取。@code{read-event}函
数自己处理这些事件，并且从不返回它们。相反，它一直在等待第一个非特殊事件，并返回该
事件。

  特殊事件不会有回音，它们从不被分组为按键序列，也不会出现在
@code{last-command-event}或@code{(this-command-keys)}的值中。它们不会丢弃数
字参数，不能用@code{unread-command-events}取消读取，它们可能不会出现在键盘宏中，
而且在你定义键盘宏时，它们不会被记录在键盘宏中。

  然而，特殊事件确实在读取后立即出现在@code{last-input-event}中，这也是事件的定
义找到实际事件的方法。

  事件类型@code{iconify-frame},@code{make-frame-visible},@code{delete-frame}
,@code{drag-n-drop},@code{language-change},以及用户信号如@code{sigusr1}通常
以这种方式处理。定义如何处理特殊事件的按键图--以及哪些事件是特殊的--在变量
@code{special-event-map}中（@pxref{Controlling Active Maps}）。

@node 等待
@section Waiting for Elapsed Time or Input
@cindex waiting

  等待功能的设计是为了等待一定时间的过去或直到有输入。例如，您可能希望在计算过程中
暂停，以便让用户有时间查看显示。@code{sit-for}暂停并更新屏幕，如果有输入则立即返回，
而@code{sleep-for}则暂停而不更新屏幕。

@defun sit-for seconds &optional nodisp
该函数执行重新显示（前提是没有来自用户的待定输入），然后等待@var{seconds}秒，或直到
输入可用。通常，@code{sit-for}的目的是给用户时间来阅读你所显示的文本。如果
@code{sit-for}在没有输入的情况下等待了整整一段时间（@pxref{Event Input Misc}），
其值就是@code{t}。否则，该值为@code{nil}。

参数@var{seconds}不需要是一个整数。如果是浮点数，@code{sit-for}会等待一个小数的秒
数。有些系统只支持整数秒；在这些系统中，@var{seconds}会被向下取整。

表达式@code{(sit-for 0)}等同于@code{(redisplay)}，也就是说，如果没有待处理的输入
，它要求重新显示，没有任何延迟。@xref{强制重新显示}。

如果@var{nodisp}不是@code{nil}，那么@code{sit-for}就不会重新显示，但它仍然会在有
输入时（或超时后）立即返回。

在批处理模式下（@pxref{Batch Mode}），@code{sit-for}不能被打断，即使是来自标准输
入描述符的输入。因此，它等同于@code{sleep-for}，下面将介绍它。

可以用三个参数调用@code{sit-for}，如
@code{(sit-for @var{seconds} @var{millisec} @var{nodisp})}，但这被认为已经过
时了。
@end defun

@defun sleep-for seconds &optional millisec
这个函数只是暂停了@var{seconds}秒，而没有更新显示。它不关注可用的输入。它返回
@code{nil}。

参数@var{seconds}不需要是一个整数。如果是浮点数，@code{sleep-for}会等待一个小
数的秒数。有些系统只支持整数的秒数；在这些系统中，@var{seconds}被向下取整。

可选参数@var{millisec}指定了一个以毫秒为单位的额外等待时间。这是对@var{seconds}所
指定的周期的补充。如果系统不支持以秒为单位的等待，如果你指定了非零的@var{millisec}，
你会得到一个错误。

当你希望保证一个延迟时，请使用@code{sleep-for}。
@end defun

  @xref{Time of Day}，用于获取当前时间的函数。

@node 退出
@section Quitting
@cindex @kbd{C-g}
@cindex quitting
@cindex interrupt Lisp functions

  在Lisp函数运行时输入@kbd{C-g}会导致Emacs@dfn{quit}不管它在做什么。这意味着控制
权返回到最里面的活动指令循环。

  在命令循环等待键盘输入时，输入@kbd{C-g}不会导致退出；它的作用是作为一个普通的输入
字符。在最简单的情况下，你无法区分，因为@kbd{C-g}通常运行@code{keyboard-quit}命令
，其效果是退出。然而，当@kbd{C-g}跟随一个前缀键时，它们结合起来形成一个未定义的键。
其效果是取消前缀键以及任何前缀参数。

  在minibuffer中，@kbd{C-g}有一个不同的定义：它退出minibuffer。这意味着，实际上，
它退出了迷你缓冲区，然后退出。(简单的退出会返回到minibuffer@emph{内}的命令循环中)。
@kbd{C-g}不直接退出的原因是当命令阅读机在读取输入时，它的含义可以在minibuffer中以
这种方式重新定义。在前缀键之后的@kbd{C-g}不会在minibuffer中被重新定义，它的正常效
果是取消前缀键和前缀参数。如果@kbd{C-g}总是直接退出，这也是不可能的。

  当@kbd{C-g}直接退出时，它通过将变量@code{quit-flag}设置为@code{t}来实现。
Emacs会在适当的时候检查这个变量，如果它不是@code{nil}就会退出。以任何方式将
@code{quit-flag}设置为非@code{nil}，都会导致退出。

  在C代码的层面上，退出不能随便发生；只能在检查@code{quit-flag}的特殊地方发生。这样
做的原因是，在其他地方退出可能会在Emacs的内部状态中留下不一致的地方。因为退出被推迟到
安全的地方，所以退出不能使Emacs崩溃。

  某些函数，如@code{read-key-sequence}或@code{read-quoted-char}，即使等待输入，
也不会完全退出。不退出，@kbd{C-g}反而作为请求的输入。在@code{read-key-sequence}的
情况下，这有助于实现@kbd{C-g}在命令循环中的特殊行为。在@code{read-quoted-char}的
情况下，这是为了让@kbd{C-q}能够被用来引用@kbd{C-g}。

@cindex preventing quitting
  你可以通过将变量@code{inhibit-quit}绑定到一个非@code{nil}的值来防止Lisp函数的
一部分退出。然后，尽管@kbd{C-g}仍然像往常一样将@code{quit-flag}设置为@code{t}，
但其通常的结果--退出--是被阻止的。最终，@code{inhibit-quit}将再次成为@code{nil}，
例如，当它在一个@code{let}表单的末尾被解除绑定时。那时，如果@code{quit-flag}仍然
是非@code{nil}的，那么请求的退出就会立即发生。当你希望确保退出不会发生在程序的关键
部分时，这种行为是理想的。

@cindex @code{read-quoted-char} quitting
  在某些函数中（比如@code{read-quoted-char}），@kbd{C-g}被以一种特殊的方式处理，
不涉及退出。这是通过在读取输入时将@code{inhibit-quit}与@code{t}绑定，并在
@code{inhibit-quit}再次变成@code{nil}之前将@code{quit-flag}设置为@code{nil}。
这段来自@code{read-quoted-char}定义的节选显示了这是如何做到的；它还显示了在输入
的第一个字符后允许正常退出。

@example
(defun read-quoted-char (&optional prompt)
  "@dots{}@var{documentation}@dots{}"
  (let ((message-log-max nil) done (first t) (code 0) char)
    (while (not done)
      (let ((inhibit-quit first)
            @dots{})
        (and prompt (message "%s-" prompt))
        (setq char (read-event))
        (if inhibit-quit (setq quit-flag nil)))
      @r{@dots{}set the variable @code{code}@dots{}})
    code))
@end example

@defvar quit-flag
如果这个变量不是@code{nil}，那么Emacs会立即退出，除非@code{inhibit-quit}也不是
@code{nil}。输入@kbd{C-g}通常会将@code{quit-flag}设置为非@code{nil}，与
@code{inhibit-quit}无关。
@end defvar

@defvar inhibit-quit
这个变量决定了当@code{quit-flag}被设置为@code{nil}以外的值时，Emacs是否应该退出
。如果@code{inhibit-quit}不是@code{nil}，那么@code{quit-flag}就没有特殊作用。
@end defvar

@defmac with-local-quit body@dots{}
这个宏依次执行@var{body}中的表单，但允许在@var{body}中退出，至少是局部退出，即使
@code{inhibit-quit}在这个结构之外是非@code{nil}。它返回@var{body}中最后一个表
单的值，除非因退出而退出，在这种情况下，它会返回@code{nil}。

如果@code{inhibit-quit}在进入@code{with-local-quit}时是@code{nil}，它只执行
@var{body}，而设置@code{quit-flag}会导致普通退出。然而，如果
@code{inhibit-quit}是非@code{nil}的，这样普通退出就会被延迟，非@code{nil}的
@code{quit-flag} 会触发一种特殊的局部退出。这将结束@var{body}的执行，并退出
@code{with-local-quit}主体，而@code{quit-flag}仍然是非@code{nil}的，因此一旦
允许，另一个（普通）退出将发生。如果@code{quit-flag}在@var{body}的开头已经是非
@code{nil}，那么本地退出就会立即发生，并且主体根本不会执行。

这个宏主要在可以从计时器、进程过滤器、进程哨兵、@code{pre-command-hook}、
@code{post-command-hook}以及其他通常将@code{inhibit-quit}绑定到@code{t}的地
方调用的函数中有用。
@end defmac

@deffn Command keyboard-quit
这个函数用@code{quit}条件发出信号，@code{(signal 'quit nil)}。这与退出的作用相
同。(参见@code{signal}在@ref{Errors}中的内容）。
@end deffn

  你可以指定一个除@kbd{C-g}以外的字符来用于退出。参见@ref{Input Modes}中的函数
@code{set-input-mode}。

@node 前缀命令参数
@section Prefix Command Arguments
@cindex prefix argument
@cindex raw prefix argument
@cindex numeric prefix argument

  大多数Emacs命令可以使用@dfn{前缀参数}，即在命令本身之前指定的数字。(不要把前缀参
数和前缀键混为一谈。)前缀参数在任何时候都由一个值表示，这个值可能是@code{nil}，意味
着目前没有前缀参数。每个命令都可以使用前缀参数或忽略它。

  前缀参数有两种表示方法：@dfn{raw}和@dfn{numeric}。编辑器命令循环在内部使用原始
表示法，存储信息的Lisp变量也是如此，但命令可以要求任何一种表示法。

  下面是一个原始前缀参数的可能值：

@itemize @bullet
@item
@code{nil}，意味着没有前缀参数。它的数值是1，但许多命令对@code{nil}和整数1进行了区
分。

@item
一个整数，它代表自己。

@item
一个有一个元素的列表，这个元素是一个整数。这种形式的前缀参数是由一个或一连串没有数字
的@kbd{C-u}产生的。数值是列表中的整数，但是有些命令对这样的列表和单独的整数进行了区分。

@item
符号@code{-}。这表示输入了@kbd{M--}或@kbd{C-u -}，没有后面的数字。相应的数字值是
@minus{}1，但有些命令对整数的{}进行了区分。

@minus{}1和符号@code{-}。
@end itemize

我们通过调用以下带有不同前缀的函数来说明这些可能性：

@example
@group
(defun display-prefix (arg)
  "Display the value of the raw prefix arg."
  (interactive "P")
  (message "%s" arg))
@end group
@end example

@noindent
下面是调用@code{display-prefix}中各种原始前缀参数的结果：

@example
        M-x display-prefix  @print{} nil

C-u     M-x display-prefix  @print{} (4)

C-u C-u M-x display-prefix  @print{} (16)

C-u 3   M-x display-prefix  @print{} 3

M-3     M-x display-prefix  @print{} 3      ; @r{(Same as @code{C-u 3}.)}

C-u -   M-x display-prefix  @print{} -

M--     M-x display-prefix  @print{} -      ; @r{(Same as @code{C-u -}.)}

C-u - 7 M-x display-prefix  @print{} -7

M-- 7   M-x display-prefix  @print{} -7     ; @r{(Same as @code{C-u -7}.)}
@end example

  Emacs uses two variables to store the prefix argument:
@code{prefix-arg} and @code{current-prefix-arg}.  Commands such as
@code{universal-argument} that set up prefix arguments for other
commands store them in @code{prefix-arg}.  In contrast,
@code{current-prefix-arg} conveys the prefix argument to the current
command, so setting it has no effect on the prefix arguments for future
commands.

  Normally, commands specify which representation to use for the prefix
argument, either numeric or raw, in the @code{interactive} specification.
(@xref{Using Interactive}.)  Alternatively, functions may look at the
value of the prefix argument directly in the variable
@code{current-prefix-arg}, but this is less clean.

@defun prefix-numeric-value arg
This function returns the numeric meaning of a valid raw prefix argument
value, @var{arg}.  The argument may be a symbol, a number, or a list.
If it is @code{nil}, the value 1 is returned; if it is @code{-}, the
value @minus{}1 is returned; if it is a number, that number is returned;
if it is a list, the @sc{car} of that list (which should be a number) is
returned.
@end defun

@defvar current-prefix-arg
This variable holds the raw prefix argument for the @emph{current}
command.  Commands may examine it directly, but the usual method for
accessing it is with @code{(interactive "P")}.
@end defvar

@defvar prefix-arg
The value of this variable is the raw prefix argument for the
@emph{next} editing command.  Commands such as @code{universal-argument}
that specify prefix arguments for the following command work by setting
this variable.
@end defvar

@defvar last-prefix-arg
The raw prefix argument value used by the previous command.
@end defvar

  The following commands exist to set up prefix arguments for the
following command.  Do not call them for any other reason.

@deffn Command universal-argument
This command reads input and specifies a prefix argument for the
following command.  Don't call this command yourself unless you know
what you are doing.
@end deffn

@deffn Command digit-argument arg
This command adds to the prefix argument for the following command.  The
argument @var{arg} is the raw prefix argument as it was before this
command; it is used to compute the updated prefix argument.  Don't call
this command yourself unless you know what you are doing.
@end deffn

@deffn Command negative-argument arg
This command adds to the numeric argument for the next command.  The
argument @var{arg} is the raw prefix argument as it was before this
command; its value is negated to form the new prefix argument.  Don't
call this command yourself unless you know what you are doing.
@end deffn

@node 递归编辑
@section Recursive Editing
@cindex recursive command loop
@cindex recursive editing level
@cindex command loop, recursive

  The Emacs command loop is entered automatically when Emacs starts up.
This top-level invocation of the command loop never exits; it keeps
running as long as Emacs does.  Lisp programs can also invoke the
command loop.  Since this makes more than one activation of the command
loop, we call it @dfn{recursive editing}.  A recursive editing level has
the effect of suspending whatever command invoked it and permitting the
user to do arbitrary editing before resuming that command.

  The commands available during recursive editing are the same ones
available in the top-level editing loop and defined in the keymaps.
Only a few special commands exit the recursive editing level; the others
return to the recursive editing level when they finish.  (The special
commands for exiting are always available, but they do nothing when
recursive editing is not in progress.)

  All command loops, including recursive ones, set up all-purpose error
handlers so that an error in a command run from the command loop will
not exit the loop.

@cindex minibuffer input
  Minibuffer input is a special kind of recursive editing.  It has a few
special wrinkles, such as enabling display of the minibuffer and the
minibuffer window, but fewer than you might suppose.  Certain keys
behave differently in the minibuffer, but that is only because of the
minibuffer's local map; if you switch windows, you get the usual Emacs
commands.

@cindex @code{throw} example
@kindex exit
@cindex exit recursive editing
@cindex aborting
  To invoke a recursive editing level, call the function
@code{recursive-edit}.  This function contains the command loop; it also
contains a call to @code{catch} with tag @code{exit}, which makes it
possible to exit the recursive editing level by throwing to @code{exit}
(@pxref{Catch and Throw}).  If you throw a value other than @code{t},
then @code{recursive-edit} returns normally to the function that called
it.  The command @kbd{C-M-c} (@code{exit-recursive-edit}) does this.
Throwing a @code{t} value causes @code{recursive-edit} to quit, so that
control returns to the command loop one level up.  This is called
@dfn{aborting}, and is done by @kbd{C-]} (@code{abort-recursive-edit}).

  Most applications should not use recursive editing, except as part of
using the minibuffer.  Usually it is more convenient for the user if you
change the major mode of the current buffer temporarily to a special
major mode, which should have a command to go back to the previous mode.
(The @kbd{e} command in Rmail uses this technique.)  Or, if you wish to
give the user different text to edit recursively, create and select
a new buffer in a special mode.  In this mode, define a command to
complete the processing and go back to the previous buffer.  (The
@kbd{m} command in Rmail does this.)

  Recursive edits are useful in debugging.  You can insert a call to
@code{debug} into a function definition as a sort of breakpoint, so that
you can look around when the function gets there.  @code{debug} invokes
a recursive edit but also provides the other features of the debugger.

  Recursive editing levels are also used when you type @kbd{C-r} in
@code{query-replace} or use @kbd{C-x q} (@code{kbd-macro-query}).

@deffn Command recursive-edit
@cindex suspend evaluation
This function invokes the editor command loop.  It is called
automatically by the initialization of Emacs, to let the user begin
editing.  When called from a Lisp program, it enters a recursive editing
level.

If the current buffer is not the same as the selected window's buffer,
@code{recursive-edit} saves and restores the current buffer.  Otherwise,
if you switch buffers, the buffer you switched to is current after
@code{recursive-edit} returns.

In the following example, the function @code{simple-rec} first
advances point one word, then enters a recursive edit, printing out a
message in the echo area.  The user can then do any editing desired, and
then type @kbd{C-M-c} to exit and continue executing @code{simple-rec}.

@example
(defun simple-rec ()
  (forward-word 1)
  (message "Recursive edit in progress")
  (recursive-edit)
  (forward-word 1))
     @result{} simple-rec
(simple-rec)
     @result{} nil
@end example
@end deffn

@deffn Command exit-recursive-edit
This function exits from the innermost recursive edit (including
minibuffer input).  Its definition is effectively @code{(throw 'exit
nil)}.
@end deffn

@deffn Command abort-recursive-edit
This function aborts the command that requested the innermost recursive
edit (including minibuffer input), by signaling @code{quit}
after exiting the recursive edit.  Its definition is effectively
@code{(throw 'exit t)}.  @xref{Quitting}.
@end deffn

@deffn Command top-level
This function exits all recursive editing levels; it does not return a
value, as it jumps completely out of any computation directly back to
the main command loop.
@end deffn

@defun recursion-depth
This function returns the current depth of recursive edits.  When no
recursive edit is active, it returns 0.
@end defun

@node 禁用命令
@section Disabling Commands
@cindex disabled command

  @dfn{Disabling a command} marks the command as requiring user
confirmation before it can be executed.  Disabling is used for commands
which might be confusing to beginning users, to prevent them from using
the commands by accident.

@kindex disabled
  The low-level mechanism for disabling a command is to put a
non-@code{nil} @code{disabled} property on the Lisp symbol for the
command.  These properties are normally set up by the user's
init file (@pxref{Init File}) with Lisp expressions such as this:

@example
(put 'upcase-region 'disabled t)
@end example

@noindent
For a few commands, these properties are present by default (you can
remove them in your init file if you wish).

  If the value of the @code{disabled} property is a string, the message
saying the command is disabled includes that string.  For example:

@example
(put 'delete-region 'disabled
     "Text deleted this way cannot be yanked back!\n")
@end example

  @xref{Disabling,,, emacs, The GNU Emacs Manual}, for the details on
what happens when a disabled command is invoked interactively.
Disabling a command has no effect on calling it as a function from Lisp
programs.

@deffn Command enable-command command
Allow @var{command} (a symbol) to be executed without special
confirmation from now on, and alter the user's init file (@pxref{Init
File}) so that this will apply to future sessions.
@end deffn

@deffn Command disable-command command
Require special confirmation to execute @var{command} from now on, and
alter the user's init file so that this will apply to future sessions.
@end deffn

@defvar disabled-command-function
The value of this variable should be a function.  When the user
invokes a disabled command interactively, this function is called
instead of the disabled command.  It can use @code{this-command-keys}
to determine what the user typed to run the command, and thus find the
command itself.

The value may also be @code{nil}.  Then all commands work normally,
even disabled ones.

By default, the value is a function that asks the user whether to
proceed.
@end defvar

@node 命令历史
@section Command History
@cindex command history
@cindex complex command
@cindex history of commands

  The command loop keeps a history of the complex commands that have
been executed, to make it convenient to repeat these commands.  A
@dfn{complex command} is one for which the interactive argument reading
uses the minibuffer.  This includes any @kbd{M-x} command, any
@kbd{M-:} command, and any command whose @code{interactive}
specification reads an argument from the minibuffer.  Explicit use of
the minibuffer during the execution of the command itself does not cause
the command to be considered complex.

@defvar command-history
This variable's value is a list of recent complex commands, each
represented as a form to evaluate.  It continues to accumulate all
complex commands for the duration of the editing session, but when it
reaches the maximum size (@pxref{Minibuffer History}), the oldest
elements are deleted as new ones are added.

@example
@group
command-history
@result{} ((switch-to-buffer "chistory.texi")
    (describe-key "^X^[")
    (visit-tags-table "~/emacs/src/")
    (find-tag "repeat-complex-command"))
@end group
@end example
@end defvar

  This history list is actually a special case of minibuffer history
(@pxref{Minibuffer History}), with one special twist: the elements are
expressions rather than strings.

  There are a number of commands devoted to the editing and recall of
previous commands.  The commands @code{repeat-complex-command}, and
@code{list-command-history} are described in the user manual
(@pxref{Repetition,,, emacs, The GNU Emacs Manual}).  Within the
minibuffer, the usual minibuffer history commands are available.

@node 键盘宏
@section Keyboard Macros
@cindex keyboard macros

  A @dfn{keyboard macro} is a canned sequence of input events that can
be considered a command and made the definition of a key.  The Lisp
representation of a keyboard macro is a string or vector containing the
events.  Don't confuse keyboard macros with Lisp macros
(@pxref{Macros}).

@defun execute-kbd-macro kbdmacro &optional count loopfunc
This function executes @var{kbdmacro} as a sequence of events.  If
@var{kbdmacro} is a string or vector, then the events in it are executed
exactly as if they had been input by the user.  The sequence is
@emph{not} expected to be a single key sequence; normally a keyboard
macro definition consists of several key sequences concatenated.

If @var{kbdmacro} is a symbol, then its function definition is used in
place of @var{kbdmacro}.  If that is another symbol, this process repeats.
Eventually the result should be a string or vector.  If the result is
not a symbol, string, or vector, an error is signaled.

The argument @var{count} is a repeat count; @var{kbdmacro} is executed that
many times.  If @var{count} is omitted or @code{nil}, @var{kbdmacro} is
executed once.  If it is 0, @var{kbdmacro} is executed over and over until it
encounters an error or a failing search.

If @var{loopfunc} is non-@code{nil}, it is a function that is called,
without arguments, prior to each iteration of the macro.  If
@var{loopfunc} returns @code{nil}, then this stops execution of the macro.

@xref{Reading One Event}, for an example of using @code{execute-kbd-macro}.
@end defun

@defvar executing-kbd-macro
This variable contains the string or vector that defines the keyboard
macro that is currently executing.  It is @code{nil} if no macro is
currently executing.  A command can test this variable so as to behave
differently when run from an executing macro.  Do not set this variable
yourself.
@end defvar

@defvar defining-kbd-macro
This variable is non-@code{nil} if and only if a keyboard macro is
being defined.  A command can test this variable so as to behave
differently while a macro is being defined.  The value is
@code{append} while appending to the definition of an existing macro.
The commands @code{start-kbd-macro}, @code{kmacro-start-macro} and
@code{end-kbd-macro} set this variable---do not set it yourself.

The variable is always local to the current terminal and cannot be
buffer-local.  @xref{Multiple Terminals}.
@end defvar

@defvar last-kbd-macro
This variable is the definition of the most recently defined keyboard
macro.  Its value is a string or vector, or @code{nil}.

The variable is always local to the current terminal and cannot be
buffer-local.  @xref{Multiple Terminals}.
@end defvar

@defvar kbd-macro-termination-hook
This normal hook is run when a keyboard macro terminates, regardless
of what caused it to terminate (reaching the macro end or an error
which ended the macro prematurely).
@end defvar
