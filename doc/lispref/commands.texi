@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990--1995, 1998--1999, 2001--2020 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node 命令循环
@chapter Command Loop
@cindex editor command loop
@cindex command loop

  当你运行Emacs时，它几乎立即进入@dfn{editor command loop}。这个循环读取按键序列
，执行它们的定义，并显示结果。在本章中，我们将描述这些事情是如何完成的，以及允许Lisp程
序完成这些事情的子程序。

@menu
* 命令概述::   命令循环如何读取命令。
* 定义命令::   指定一个函数应该如何读取参数。
* 交互式调用:: 调用一个命令，使其读取参数。
* 区分交互式:: 使一个命令与交互式调用不同。
* 命令循环信息::令循环设置的变量，供你检查。
* 调整点::    命令后调整光标点。
* 输入事件::  读取输入时的样子。
* 读取输入::  从键盘或鼠标读取输入事件的方法。
* 特殊事件::  立即和单独处理的事件。
* 等待::     等待用户的输入或过期的时间。
* 退出::     @kbd{C-g}的工作方式。 如何捕捉或推迟退出。
* 前缀命令参数:: 设置前缀参数的命令如何工作。
* 递归编辑::  进入递归编辑,以及为什么你通常不应该这样做。
* 禁用命令::  命令循环如何处理被禁用的命令。
* 命令历史::  如何设置命令历史，以及如何访问。
* 键盘宏::    键盘宏的实现方式。
@end menu

@node 命令概述
@section Command Loop Overview

  命令循环必须做的第一件事是读取一个按键序列，这是一个转换为命令的输入事件序列，它通过
调用函数@code{read-key-sequence}来完成。Lisp程序也可以调用这个函数（
@pxref{key Sequence Input}）。它们也可以通过@code{read-key}或
@code{read-event}来读取更低层次的输入(@pxref{Reading One Event})，或者用
@code{discard-input}（@pxref{Event Input Misc}）丢弃待定的输入。

  按键序列通过当前活动键位图转化为命令。关于如何做到这一点的信息，请参见
@xref{Key Lookup}。其结果应该是一个键盘宏或一个可交互调用的函数。如果按键是
@kbd{M-x}，那么它就会读取另一个命令的名称，然后调用它。这是由命令
@code{execute-extended-command}（@pxref{Interactive Call}）完成的。

在执行命令之前，Emacs会运行@code{undo-boundary}来创建一个撤销边界。
@xref{Maintaining Undo}。

要执行一个命令，Emacs首先通过调用@code{command-execute}来读取其参数。(
@pxref{Interactive Call})。对于用Lisp编写的命令，@code{interactive}规范规定
了是如何读取参数。 这可能使用前缀参数（@pxref{Prefix Command Arguments}），也可
能在minibuffer中提示读取（@pxref{Minibuffers}）。例如，命令@code{find-file}有
一个@code{interactive}规范，说是使用minibuffer读取文件名。而@code{find-file}
的函数体并没有使用minibuffer，所以如果你从Lisp代码中调用@code{find-file}作为函数
，你必须提供文件名字符串作为普通Lisp函数参数。

如果命令是键盘宏(即字符串或向量)，Emacs会使用@code{execute-kbd-macro}来执行它(
@pxref{Keyboard Macros})

@defvar pre-command-hook
这个正常的钩子是由编辑器命令循环执行每个命令之前运行的。此时，@code{this-command}包
含即将运行的命令，@code{last-command}描述前一个命令。
@xref{Command Loop Info}。
@end defvar

@defvar post-command-hook
这个正常的钩子是在编辑器命令循环执行完每一条命令（包括因退出或错误而提前终止的命令）后
，由编辑器命令循环运行的。此时，@code{this-command}指的是刚刚运行的命令，
@code{last-command}指的是之前的命令。

当Emacs第一次进入命令循环时，也会运行这个钩子（此时@code{this-command}和
@code{last-command}都是@code{nil}）。
@end defvar

  在运行@code{pre-command-hook}和@code{post-command-hook}时，会抑制退出。如
果在执行这些钩子中的一个钩子时发生了错误，并不会终止钩子的执行；相反，错误会被沉默，发
生错误的函数会从钩子中移除。

进入Emacs服务器的请求(
@pxref{Emacs Server,,,emacs,The GNU Emacs Manual})会像键盘命令一样运行这两
个钩子。

@node 定义命令
@section Defining Commands
@cindex defining commands
@cindex commands, defining
@cindex functions, making them interactive
@cindex interactive function

  特殊表单@code{interactive}可以将一个Lisp函数变成一条命令。
@code{interactive}表单必须位于函数体的顶层，通常作为函数体的第一个表单；这适用于
lambda表达式（@pxref{Lambda Expressions}）和@code{defun}表单（
@pxref{Declare Form}）。此表单在实际执行函数的过程中没有任何作用；它的存在作为一个
标志，告诉Emacs命令循环可以交互式调用函数。@code{interactive}表单的参数指定了交互
式调用的参数应该如何读取。
@cindex @code{interactive-form} property
  另外，@code{interactive}表单可以在函数符号的@code{interactive-form}属性中指
定。这个属性的非@code{nil}值优先于函数体中的任何@code{interactive}形式。这个特性
很少被使用。
@anchor{The interactive-only property}
@cindex @code{interactive-only} property
  有时，一个函数只打算被交互式调用，而不是直接从Lisp中调用。在这种情况下，可以给函数一
个非@code{nil}的@code{interactive-only}属性，可以直接地或通过@code{declare}
。(@pxref{Declare Form})。这将导致字节编译器警告说从Lisp调用命令。
@code{describe-function}的输出将包括类似的信息。该属性的值可以是：一个字符串，字
节编译器将在其警告中直接使用该字符串（它应该以句号结束，而不是以大写开始，例如，
@code{"use (system-name) instead."}）；@code{t}；任何其他符号，它应该是
一个Lisp代码中使用的替代函数。

通用函数（@pxref{Generic Functions}）不能通过添加@code{interactive}形式来变成
命令。

@menu
* 使用交互式::  @code{interactive}的一般规则。
* 交互式代码::  各种方式读取参数的标准字母代码。
* 交互式例子::  如何读取交互式参数的例子。
* 通用命令::    在命令替代品中进行选择。
@end menu

@node 使用交互式
@subsection Using @code{interactive}
@cindex arguments, interactive entry
@cindex interactive spec, using

  本节介绍了如何编写@code{interactive}形式，使一个Lisp函数成为可交互调用的命令，
以及如何检查一个命令的@code{interactive}形式。

@defspec interactive arg-descriptor
这个特殊的表单声明一个函数是一个命令，因此它可以被交互式调用（通过@kbd{M-x}或输入一个
与之绑定的键序）。参数@var{arg-descriptor}声明了当命令被交互式调用时，如何计算命令
的参数。

命令可以像其他函数一样从Lisp程序中调用，但这时调用者提供参数，
@var{arg-descriptor}没有任何作用。

@cindex @code{interactive-form}, symbol property
@code{interactive}形式必须位于函数体的顶层，或者位于函数符号的
@code{interactive-form}属性中（@pxref{Symbol Properties}）。它之所以有效果，
是因为命令循环在调用函数之前会寻找它（@pxref{Interactive Call}）。一旦函数被调用
，它的所有主体表单都会被执行；此时，如果@code{interactive}表单发生在主体内，该表单
就会简单地返回@code{nil}，甚至不运算其参数。

按照惯例，你应该把@code{interactive}形式放在函数体中，作为第一个顶层形式。如果在
@code{interactive-form}符号属性和函数体中都有@code{interactive}表单，则前者优
先。可以使用@code{interactive-form}符号属性为现有的函数添加交互式表单，或者改变其
参数的交互式处理方式，而无需重新定义函数。
@end defspec

参数@var{arg-descriptor}有三种可能：

@itemize @bullet
@item
它可以被省略或@code{nil}，然后命令被调用时不需要任何参数。如果命令需要一个或多个参数
，这将很快导致错误。

@item
它可以是一个字符串；它的内容是一个由换行符分隔的元素序列，每个参数一个
@footnote{有些元素实际上提供了两个参数}。每个元素都由一个代码字符（
@pxref{Interactive Codes}）组成，后面可选择地跟着一个提示符（有些代码字符使用，有
些忽略）。下面是一个例子:

@smallexample
(interactive "P\nbFrobnicate buffer: ")
@end smallexample

@noindent
代码字母@samp{P}将命令的第一个参数设置为原始命令前缀（
@pxref{Prefix Command Arguments}）。@samp{bFrobnicate buffer: }用
@samp{Frobnicate buffer: }提示用户输入现有缓冲区的名称，该名称成为第二个也是最后
一个参数。

提示字符串可以使用@samp{%}将之前的参数值（从第一个参数开始）包含在提示中。
这可以通过@code{format-message}来完成。(@pxref{Formatting Strings})。
例如，以下是你可以如何读取一个现有缓冲区的名称，然后给这个缓冲区起一个新的名字:

@smallexample
@group
(interactive "bBuffer to rename: \nsRename buffer %s to: ")
@end group
@end smallexample

@cindex @samp{*} in @code{interactive}
@cindex read-only buffers in interactive
如果@samp{*}出现在字符串的开头，那么如果缓冲区是只读的，就会发出错误信号。

@cindex @samp{@@} in @code{interactive}
如果@samp{@@}出现在字符串的开头，并且如果用于调用命令的键序包括任何鼠标事件，那么在命
令运行之前，与第一个事件相关联的窗口被选中。

@cindex @samp{^} in @code{interactive}
@cindex shift-selection, and @code{interactive} spec
如果@samp{^}出现在字符串的开头，并且如果命令是通过@dfn{shift-translation}调用的
，则在命令运行前设置标记并暂时激活该区域，或者拓展一个已经激活的区域。如果命令是在没有
shift-translation的情况下调用的，并且区域暂时处于活动状态，则在命令运行前停用该区域
。Shift-translation在用户层面由@code{shift-select-mode}控制；参见
@ref{Shift Selection,,,,emacs,The GNU Emacs Manual}。

您可以同时使用@samp{*},@samp{@@},和@code{^}，顺序并不重要。参数的实际读取是由提示
字符串的其余部分控制的（从第一个不是@samp{*},@samp{@@},或@samp{^}的字符开始）。

@item
它可能是一个不是字符串的Lisp表达式；那么它应该是一个表单，通过运算得到要传递给命令的参
数列表。通常这个表单会调用各种函数来读取用户的输入，最常见的是通过迷你缓冲区（
@pxref{Minibuffers}）或直接从键盘（@pxref{Reading Input}）读取。

提供点或标记作为参数值也是很常见的，但如果你这样@emph{和}读输入（无论是否使用迷你缓冲
区），一定要在读完后得到点或标记的整数值。当前缓冲区可能正在接收子进程的输出；如果在命
令等待输入时子进程的输出到达，它可能会重新定位点和标记。

下面是一个@emph{不}要做的例子。

@smallexample
(interactive
 (list (region-beginning) (region-end)
       (read-string "Foo: " nil 'my-history)))
@end smallexample

@noindent
以下是如何避免这个问题，通过阅读键盘输入后检查点和标记：

@smallexample
(interactive
 (let ((string (read-string "Foo: " nil 'my-history)))
   (list (region-beginning) (region-end) string)))
@end smallexample

@strong{Warning:}参数值不应该包含任何不能打印和读取的数据类型。有些设施会将
@code{command-history}保存在一个文件中，以便在以后的会话中读取；如果一个命令的参数
包含了使用@samp{#<@dots{}>}语法打印的数据类型，那么这些设施将无法工作。

不过，也有一些例外：使用有限的一组表达式是可以的，比如@code{(point)}、
@code{(mark)}、@code{(region-beginning)}和@code{(region-end)}，因为Emacs
会特别识别它们，并将表达式（而不是其值）放入命令历史记录中。要查看您写的表达式是否属于
这些例外情况，请运行命令，然后检查 @code{(car command-history)}。

@end itemize

@cindex examining the @code{interactive} form
@defun interactive-form function
这个函数返回@var{function}的@code{interactive}表单。如果@var{function}是一个
可交互调用的函数 (@pxref{Interactive Call})，那么值就是命令的@code{交互式}形式
@code{(interactive @var{spec})}，它指定了如何计算其参数。否则，其值为
@code{nil}。如果@var{function}是一个符号，则使用其函数定义。
@end defun

@node 交互式代码
@subsection Code Characters for @code{interactive}
@cindex interactive code description
@cindex description for interactive codes
@cindex codes, interactive, description of
@cindex characters for interactive codes

  下面的代码字符描述包含一些关键词，在此定义如下：

@table @b
@item Completion
@cindex interactive completion
提供补全。@key{TAB}、@key{SPC}和@key{RET}执行名称补全，因为参数是用
@code{completing-read}读取的。(@pxref{Completion})。@kbd{?}
显示一个可能的完成列表。

@item Existing
要求使用现有对象的名称。不接受无效的名称；如果当前输入无效，退出minibuffer的命令不会
退出。

@item Default
@cindex default argument string
如果用户在minibuffer中没有输入文字，则使用某种默认值。默认值取决于代码字符。

@item No I/O
这个代码信在不读取任何输入的情况下计算一个参数，因此，它不使用提示字符串，你提供的任何
提示符都会被忽略。

即使代码字母没有使用提示字符串，但如果它不是字符串中的最后一个代码字符，你必须在它后面
加上一个新行。

@item Prompt
在代码字符后面紧跟着一个提示符。提示符以字符串的结尾或换行结束。

@item Special
这个代码字符只有在交互式字符串的开头才有意义，它不会寻找提示符或换行符。它是一个单独的
、孤立的字符。
@end table

@cindex reading interactive arguments
下面是与@code{interactive}配合使用的代码字符说明：

@table @samp
@item *
如果当前缓冲区为只读，则发出错误信号。Special。

@item @@
选择调用该命令的键序中第一个鼠标事件中提到的窗口。Special。

@item ^
如果命令是通过移位翻译调用的，则在命令运行前设置标记并暂时激活该区域，或扩展已经激活的
区域。如果命令是在没有移位翻译的情况下调用的，且区域暂时处于活动状态，则在命令运行前停
用该区域。Special。

@item a
一个函数名（比如满足@code{fboundp}的符号）。Existing, Completion, Prompt.

@item b
现有缓冲区的名称。默认情况下，使用当前缓冲区的名称（@pxref{Buffers}）。
Existing, Completion, Prompt。

@item B
缓冲区名称。缓冲区不需要存在。默认情况下，使用当前缓冲区以外的最近使用的缓冲区的名称。
Existing, Completion, Prompt。

@item c
一个字符。光标不会移动到回音区。Prompt.

@item C
一个命令名称（即满足@code{commandp}的符号）。Existing, Completion, Prompt.

@item d
@cindex position argument
点的位置，是一个整数（@pxref{Point}）。No I/O。

@item D
一个目录。默认为当前缓冲区的默认目录，@code{default-directory}。(
@pxref{File Name Expansion})。Existing, Completion, Default, Prompt.

@item e
在调用命令的按键序列中的第一个或下一个非键盘事件。更准确地说，@samp{e}得到的事件是列
表，所以你可以查看列表中的数据。@xref{Input Events}。No I/O。

您可以使用@samp{e}来处理鼠标事件和特殊系统事件（@pxref{Misc Events}）。命令接收
的事件列表取决于事件。@xref{Input Events}，它在相应的小节中描述了每个事件的列表
表单。

您可以在一个命令的交互式规范中使用@samp{e}一次以上。如果调用命令的键序列中有@var{n}
个事件是列表，那么第@var{n}个@samp{e}提供了第@var{n}个这样的事件。不是列表的事件，
例如函数键和 @acronym{ASCII} 字符，在 @samp{e} 中不计算。

@item f
一个现有文件的文件名(@pxref{File Names}).默认目录是@code{default-directory}。
默认目录是@code{default-directory}。Existing, Completion, Default,
Prompt.

@item F
一个文件名。文件不需要存在。 Completion, Default, Prompt.

@item G
一个文件名。该文件不需要存在。如果用户只输入一个目录名，那么值就只是该目录名，不添加目
录内的文件名。 Completion, Default, Prompt.

@item i
一个不相关的参数。此代码总是提供@code{nil}作为参数的值。 No I/O.

@item k
一个键序列（@pxref{Key Sequences}）。这将持续读取事件，直到在当前键映射中找到一条
命令（或未定义的命令）。键序列参数用字符串或向量表示。光标不会移动到回音区。Prompt.

如果@samp{k}读取了一个以向下事件结束的键序列，它也会读取并丢弃下面的向上事件。您可以
使用@samp{U}代码字符来访问该上行事件。

这种输入被@code{describe-key}和@code{global-set-key}等命令使用。

@item K
一个你想改变其定义的键序列。其工作原理如@samp{k}，但对于键中的最后一个输入事件，它抑
制了键序列，通常用于（必要时）将未定义的键转换为定义的键的转换。

@item m
@cindex marker argument
标记的位置，为整数。 No I/O.

@item M
任意文本，使用当前缓冲区的输入方法在minibuffer中读取，并以字符串形式返回（
@pxref{Input Methods,,, emacs, The GNU Emacs Manual}）。 Prompt.

@item n
一个数字，用minibuffer读取。如果输入的不是数字，用户必须再试一次。@samp{n}从不使用
前缀参数。Prompt.

@item N
数字前缀参数；但如果没有前缀参数，则像@kbd{n}一样读取一个数字。值总是一个数字。
@xref{Prefix Command Arguments}.  Prompt.

@item p
@cindex numeric prefix argument usage
数字前缀参数。(注意这个@samp{p}是小写的。) No I/O.

@item P
@cindex raw prefix argument usage
原始前缀参数。(注意，这个@samp{P}是大写的。) No I/O.

@item r
@cindex region argument
点和标记，作为两个数字参数，先小后大。这是唯一一个指定两个连续参数而不是一个参数的代码
字母。如果标记没有设置在缓冲区中，这将发出错误信号，而缓冲区在命令被调用时是当前的。
No I/O.

@item s
任意文本，从迷你缓冲区中读取并以字符串形式返回(@pxref{Text from Minibuffer})。用
以下两种方式终止输入@kbd{C-j}或@key{RET}。(@kbd{C-q}可用于包含输入里两种个之一。
) Prompt.

@item S
在minibuffer中读取一个内部符号的名称。用@kbd{C-j}或@key{RET}终止输入。其他通常终
止符号的字符(如：空格、括号和大括号)在这里不能终止。 Prompt.

@item U
一个按键序列或@code{nil}。可以在@samp{k}或@samp{K}参数之后使用，用来获取被丢弃的
@samp{k}或@samp{K}读取一个向下事件后的上位事件（如果有的话）。如果没有上行事件被丢
弃，则@samp{U}提供@code{nil}作为参数。 No I/O.

@item v
一个声明为用户选项的变量(即满足前提条件@code{custom-variable-p})。这将使用
@code{read-variable}读取变量。@xref{Definition of read-variable}。
Existing, Completion, Prompt.

@item x
一个Lisp对象，用它的读取语法指定，以@kbd{C-j}或@key{RET}结束。该对象没有被评估。
@xref{Object from Minibuffer}。 Prompt.

@item X
@cindex evaluated expression argument
一个Lisp表单的值。@samp{X}像@samp{x}一样读取，然后运算表单，使其值成为命令的参数
。 Prompt.

@item z
一个编码系统名称（一个符号）。如果用户输入为空，参数值为@code{nil}。
@xref{Coding Systems}.  Completion, Existing, Prompt.

@item Z
一个编码系统名称（一个符号），仅当这个命令有前缀参数时。如果没有前缀参数，@samp{Z}提
供@code{nil}作为参数值。 Completion, Existing, Prompt.
@end table

@node 交互式例子
@subsection Examples of Using @code{interactive}
@cindex examples of using @code{interactive}
@cindex @code{interactive}, examples of using

  Here are some examples of @code{interactive}:

@example
@group
(defun foo1 ()              ; @r{@code{foo1} takes no arguments,}
    (interactive)           ;   @r{just moves forward two words.}
    (forward-word 2))
     @result{} foo1
@end group

@group
(defun foo2 (n)             ; @r{@code{foo2} takes one argument,}
    (interactive "^p")      ;   @r{which is the numeric prefix.}
                            ; @r{under @code{shift-select-mode},}
                            ;   @r{will activate or extend region.}
    (forward-word (* 2 n)))
     @result{} foo2
@end group

@group
(defun foo3 (n)             ; @r{@code{foo3} takes one argument,}
    (interactive "nCount:") ;   @r{which is read with the Minibuffer.}
    (forward-word (* 2 n)))
     @result{} foo3
@end group

@group
(defun three-b (b1 b2 b3)
  "Select three existing buffers.
Put them into three windows, selecting the last one."
@end group
    (interactive "bBuffer1:\nbBuffer2:\nbBuffer3:")
    (delete-other-windows)
    (split-window (selected-window) 8)
    (switch-to-buffer b1)
    (other-window 1)
    (split-window (selected-window) 8)
    (switch-to-buffer b2)
    (other-window 1)
    (switch-to-buffer b3))
     @result{} three-b
@group
(three-b "*scratch*" "declarations.texi" "*mail*")
     @result{} nil
@end group
@end example

@node 通用命令
@subsection Select among Command Alternatives
@cindex generic commands
@cindex alternatives, defining

宏@code{define-alternatives}可以用来定义@dfn{generic commands}。这些是交互
式函数，按照用户的喜好，可以从几个备选方案中选择实施。

@defmac define-alternatives command &rest customizations
定义新的命令@var{command}，一个符号。

当用户在第一次运行@kbd{M-x @var{command} @key{RET}}时，Emacs会提示使用命令的
实际表单，并通过自定义变量记录选择。使用前缀参数会重复这个选择过程。

变量@code{@var{command}-alternatives}应该包含一个@var{command}的替代实现的
列表。在这个变量被设置之前，@code{define-alternatives}没有任何作用。

如果@var{customizations}是非@code{nil}，它应该由替代的@code{defcustom}关键
字（通常是@code{:group}和@code{:version}）和值组成，以添加到
@code{@var{command}-alternatives}的声明中。
@end defmac

@node 交互式调用
@section Interactive Call
@cindex interactive call

  在命令循环将一个键序列翻译成命令后，它使用函数@code{command-execute}来调用这个
命令。如果命令是一个函数，那么@code{command-execute}会调用
@code{call-inactively}，后者读取参数并调用命令。你也可以自己调用这些函数。

  请注意，术语"命令"在这里指的是一个可交互调用的函数（或类似函数的对象），或一个键盘
宏。它不是指用于调用命令的键序（@pxref{Keymaps}）。

@defun commandp object &optional for-call-interactively
如果@var{object}是一条命令，则该函数返回@code{t}。否则，返回@code{nil}。

命令包括字符串和向量（被视为键盘宏）、包含顶级@code{interactive}表单的lambda表达
式（@pxref{Using Interactive}）、由这些lambda表达式构成的字节码函数对象、被声
明为交互式的自动加载对象（@code{autoload}的第四个参数非@code{nil}），以及一些原
始函数。另外，如果一个符号有一个非@code{nil}的@code{interactive-form}属性，或者
它的函数定义满足@code{commandp}，第四个参数，那么它就被认为是一个命令。

如果@var{for-call-interactively}是非@code{nil}，那么@code{commandp}只对
@code{call-interactively}可以调用的对象返回@code{t}--因此，不对键盘宏返回。

参见@ref{Accessing Documentation}中的@code{documentation}，这是一个使用
@code{commandp}的实际例子。
@end defun

@defun call-interactively command &optional record-flag keys
这个函数调用可交互调用的函数@var{command}，并根据其交互调用规范提供参数。无论
@var{command}返回什么，它都会返回。

例如，如果你有一个具有以下签名的函数:

@example
(defun foo (begin end)
  (interactive "r")
  ...)
@end example

然后

@example
(call-interactively 'foo)
@end example

将调用@code{foo}，把区域（@code{point}和@code{mark}）作为参数。

如果@var{command}不是函数，或者不能交互调用（即不是命令），就会发出错误信号。请注意
，键盘宏（字符串和向量）即使被认为是命令，也不会被接受，因为它们不是函数。如果
@var{command}是一个符号，那么@code{call-interactively}使用它的函数定义。

@cindex record command history
如果@var{record-flag}是非@code{nil}，那么这条命令和它的参数就会无条件地添加到
@code{command-history}列表中。否则，只有当该命令使用迷你缓冲区读取参数时，才会被
添加到列表中。@xref{Command History}。

如果给定参数@var{keys}，那么它应该是一个向量，用于指定在命令询问哪些事件被用来调用
时要提供的事件序列。如果省略了@var{keys}或@code{nil}，则默认为
@code{this-command-keys-vector}的返回值。
@xref{this-command-keys-vector}。
@end defun

@defun funcall-interactively function &rest arguments
这个函数的工作原理与@code{funcall}类似。(@pxref{Calling Functions})，但它使
调用看起来像一个交互式调用：在@var{function}内调用
@code{called-interactively-p}将返回@code{t}。如果@var{function}不是一个命
令，那么它在被调用时不会发出错误信号。
@end defun

@defun command-execute command &optional record-flag keys special
@cindex keyboard macro execution
这个函数执行@var{command}，参数@var{command}必须满足@code{commandp}谓词，也
就是说，它必须是一个可交互调用的函数或键盘宏。

作为@var{command}的字符串或向量会被@code{execute-kbd-macro}执行。一个函数与
@var{record-flag}和@var{keys}参数一起传递给@code{call-interactively}（见上
文）。

如果@var{command}是一个符号，那么使用它的函数定义。如果一个带有@code{autoload}
定义的符号被声明为代表一个可交互调用的函数，那么这个符号也算作一个命令。这种定义是通过
加载指定的库，然后重新检查符号的定义来处理的。

如果给定参数@var{special}，意味着忽略前缀参数，而且不清除它。这用于执行特殊事件（
@pxref{Special Events}）。
@end defun

@deffn Command execute-extended-command prefix-argument
@cindex read command name
该函数使用@code{completing-read}从minibuffer中读取命令名。(
@pxref{Completion})。然后它使用@code{command-execute}来调用指定的命令。无论
该命令返回什么，都会成为@code{execute-extended-command}的值。

@cindex execute with prefix argument
如果命令要求使用前缀参数，它将接收@var{prefix-argument}的值。如果交互式地调用了
@code{execute-extended-command}，那么当前的原始前缀参数将被用于
@var{prefix-argument}，从而传递给任何运行的命令。

@c !!!应该是@kindex?
@cindex @kbd{M-x}
@code{execute-extended-command}是@kbd{M-x}的普通定义，所以它使用了字符串
@w{@samp{M-x }}作为提示符。(最好是从调用@code{execute-extended-command}的事
件中获取提示符，但实现起来很麻烦。)如果有的话，对前缀参数值的描述也会成为提示的一部分
。

@example
@group
(execute-extended-command 3)
---------- Buffer: Minibuffer ----------
3 M-x forward-word @key{RET}
---------- Buffer: Minibuffer ----------
     @result{} t
@end group
@end example
@end deffn

@node 区分交互式
@section Distinguish Interactive Calls
@cindex distinguish interactive calls
@cindex is this call interactive

  有时，命令应该只为交互式呼叫显示额外的视觉反馈（如在回音区显示信息信息）。有三种方
法可以做到这一点。测试函数是否通过@code{call-interactively}调用，推荐的方法是给
函数一个可选的参数@code{print-message}，并使用@code{interactive}规范使其在交
互式调用中不@code{nil}。下面是一个例子:

@example
(defun foo (&optional print-message)
  (interactive "p")
  (when print-message
    (message "foo")))
@end example

@noindent
我们使用@code{"p"}，因为数字前缀参数永远不会是@code{nil}。以这种方式定义的函数，
在从键盘宏调用时确实会显示消息。

上面的方法加上额外的参数通常是最好的，因为它允许调用者说"把这个调用当作交互式"。但你
也可以通过测试@code{called-interactively-p}来完成这项工作。

@defun called-interactively-p kind
当使用@code{call-inactively}调用调用函数时，该函数返回@code{t}。

参数@var{kind}应该是符号@code{interactive}或者符号@code{any}。如果是
@code{interactive}，那么@code{called-interactively-p}只有在用户直接调用的情
况下才返回@code{t}--例如，如果用户输入了一个绑定到调用函数的按键序列，但如果用户运
行了一个调用函数的键盘宏(@pxref{Keyboard Macros})，则返回@emph{not}。如果
@var{kind}是@code{any}，则@code{called-interactively-p}返回@code{t}，用于
任何类型的交互式调用，包括键盘宏。

如果有疑问，请使用@code{any}；唯一已知的@code{interactive}的正确用法是当你需要
决定是否在函数运行时显示一个有用的消息。

如果一个函数是通过Lisp运算调用的（或者使用@code{apply}或@code{funcall}），那么
它永远不会被认为是交互式调用的。
@end defun

@noindent
下面是一个使用@code{called-interactively-p}的例子:

@example
@group
(defun foo ()
  (interactive)
  (when (called-interactively-p 'any)
    (message "Interactive!")
    'foo-called-interactively))
@end group

@group
;; @r{Type @kbd{M-x foo}.}
     @print{} Interactive!
@end group

@group
(foo)
     @result{} nil
@end group
@end example

@noindent
下面是另一个例子，将直接和间接调用@code{called-interactively-p}进行对比。

@example
@group
(defun bar ()
  (interactive)
  (message "%s" (list (foo) (called-interactively-p 'any))))
@end group

@group
;; @r{Type @kbd{M-x bar}.}
     @print{} (nil t)
@end group
@end example

@node 命令循环信息
@section Information from the Command Loop
@cindex command loop variables

编辑器命令循环设置了几个Lisp变量来为自己和正在运行的命令保存状态记录。除了
@code{this-command}和@code{last-command}之外，一般来说，在Lisp程序中改变这些
变量是个坏主意。

@defvar last-command
这个变量记录了命令循环执行的前一条命令的名称（当前命令之前的那条）。通常情况下，值是一
个带有函数定义的符号，但这并不保证。

当一个命令返回到命令循环时，该值会从@code{this-command}中复制出来，除非该命令已经
为下面的命令指定了前缀参数。

这个变量始终是当前终端的本地变量，不能是缓冲区本地变量。
@xref{Multiple Terminals}。
@end defvar

@defvar real-last-command
这个变量在Emacs中的设置就像@code{last-command}一样，但从未被Lisp程序改变。
@end defvar

@defvar last-repeatable-command
这个变量存储了最近执行的不属于输入事件的命令。这是@code{repeat}将尝试重复执行的命令
，@xref{Repeating,,,emacs, The GNU Emacs Manual}。
@end defvar

@defvar this-command
@cindex current command
这个变量记录了编辑器命令循环正在执行的命令的名称，和@code{last-command}一样，它通
常是带有函数定义的符号。和@code{last-command}一样，它通常是一个带有函数定义的符号
。

命令循环在运行命令之前设置这个变量，并在命令完成后将其值复制到@code{last-command}
中（除非命令为下面的命令指定了一个前缀参数）。

@cindex kill command repetition
有些命令在执行过程中设置了这个变量，作为接下来运行的任何命令的标志。特别是，杀戮文本的
函数将@code{this-command}设置为@code{kill-region}，这样紧接着的任何杀戮命令都
会知道将杀戮文本附加到之前的杀戮中。
@end defvar

如果您不希望某条命令在出错的情况下被识别为前一条命令，您必须对该命令进行编码以防止这种
情况发生。一种方法是在命令的开头将@code{this-command}设置为@code{t}，然后在结尾
处将@code{this-command} 设置为合适的值，就像这样:

@example
(defun foo (args@dots{})
  (interactive @dots{})
  (let ((old-this-command this-command))
    (setq this-command t)
    @r{@dots{}do the work@dots{}}
    (setq this-command old-this-command)))
@end example

@noindent
我们没有绑定@code{this-command}与@code{let}，因为这样做会在出错时恢复旧的值--这
是@code{let}的一个特性，在这种情况下，它恰恰是我们想要避免的。

@defvar this-original-command
这与@code{this-command}的值相同，但当发生命令重映射时除外（@pxref{重映射命令}）。
在这种情况下，@code{this-command}给出了实际运行的命令（重映射的结果），而
@code{this-original-command}给出了指定运行但重映射为另一个命令的命令。
@end defvar

@defun this-command-keys
这个函数返回一个字符串或向量，其中包含调用当前命令的键序列，加上之前为这个命令生成前
缀参数的任何命令。任何由命令使用@code{read-event}读取的、没有超时的事件都会被加到
最后。

但是，如果命令调用了@code{read-key-sequence}，则返回最后读取的键序列。
@xref{键序列输入}。如果序列中的所有事件都是适合于字符串的字符，则该值是一个字符串。
@xref{输入事件}。

@example
@group
(this-command-keys)
;; @r{Now use @kbd{C-u C-x C-e} to evaluate that.}
     @result{} "^U^X^E"
@end group
@end example
@end defun

@defun this-command-keys-vector
@anchor{Definition of this-command-keys-vector}
和@code{this-command-keys}一样，只是它总是以向量的形式返回事件，所以你不需要处理
将输入事件存储在字符串中的复杂问题 (@pxref{事件字符串})。
@end defun

@defun clear-this-command-keys &optional keep-record
这个函数清空了@code{this-command-keys}要返回的事件表。除非@var{keep-record}是
非@code{nil}，否则它也会清空函数@code{recent-keys}所返回的记录。(
@pxref{记录输入})随后将返回。这在读取密码后很有用，可以防止在某些情况下，密码作为
下一条命令的一部分被无意中回传。
@end defun

@defvar last-nonmenu-event
这个变量保存了最后一次读取的输入事件，作为按键序列的一部分，不包括鼠标菜单产生的事件。

这个变量的一个用途是告诉@code{x-popup-menu}在哪里弹出一个菜单。它也被
@code{y-or-n-p}内部使用(@pxref{Yes-or-No Queries})。
@end defvar

@defvar last-command-event
这个变量被设置为命令循环读取的最后一个输入事件，作为命令的一部分。这个变量的主要用途
是在@code{self-insert-command}中，用来决定插入哪个字符。

@example
@group
last-command-event
;; @r{Now use @kbd{C-u C-x C-e} to evaluate that.}
     @result{} 5
@end group
@end example

@noindent
这个值是5，因为这是@kbd{C-e}的@acronym{ASCII}码。
@end defvar

@defvar last-event-frame
这个变量记录了最后一个输入事件被指向的窗框。通常这是事件生成时被选中的窗框，但如果该
窗框已将输入焦点重定向到另一窗框，则该值是事件被重定向到的窗框。@xref{输入焦点}。

如果最后一个事件来自于键盘宏，那么其值为@code{macro}。
@end defvar

@node 调整点
@section Adjusting Point After Commands
@cindex adjusting point
@cindex invisible/intangible text, and point
@cindex @code{display} property, and point display
@cindex @code{composition} property, and point display

  当点处于具有@code{display}或@code{composition}属性的，或者是隐形的文本序列中间
时，Emacs无法显示光标。因此，在一条命令完成并返回命令循环后，如果点在这样的序列内，
命令循环通常会将点移动到序列的边缘，使得这个序列实际上是无形的。

  一个命令可以通过设置变量@code{disable-point-adjustment}来抑制该功能：

@defvar disable-point-adjustment
如果当一个命令返回到命令循环时，这个变量是非@code{nil}，那么命令循环就不会检查这些文
本属性，也不会将点从有这些属性的序列中移出。

命令循环在每条命令之前都会将这个变量设置为@code{nil}，所以如果某条命令设置了这个变量
，那么效果只适用于这条命令。
@end defvar

@defvar global-disable-point-adjustment
如果将这个变量设置为非@code{nil}值，则完全关闭这些序列中移动点的功能。
@end defvar

@node 输入事件
@section Input Events
@cindex events
@cindex input events

Emacs命令循环读取一连串的@dfn{输入事件}，这些事件代表键盘或鼠标活动，或者是发
送给Emacs的系统事件。键盘活动的事件是字符或符号，其他事件总是列表。本节详细介绍
输入事件的表示方法和意义。

@defun eventp object
如果@var{object}是一个输入事件或事件类型，则该函数返回非@code{nil}。

请注意，任何非@code{nil}符号都可能被用作事件或事件类型；@code{eventp}不能区分
Lisp代码是否打算将一个符号用作事件。
@end defun

@menu
* 键盘事件::                     普通字符 -- 带符号的键。
* 功能键::                       功能键 -- 有名称而非符号的键。
* 鼠标事件::                     鼠标事件概述。
* 点击事件::                     按压和释放鼠标按钮。
* 拖动事件::                     在释放按钮之前移动鼠标。
* 按下按钮事件::                  按钮被按下后尚未释放。
* 重复事件::                     双击和三击（或拖动，或按下）。
* 运动事件::                     只是移动鼠标，而不按下按钮。
* 焦点事件::                     在窗框之间移动鼠标。
* 杂项事件::                     系统可以产生的其他事件。
* 事件示例::                     鼠标事件的列表示例。
* 分类事件::                     寻找事件符号中的修饰键。事件类型。
* 访问鼠标::                     从鼠标事件中提取信息的函数。
* 访问滚动条::                   从滚动条事件中获取信息的函数。
* 事件字符串::                   将键盘字符事件放在字符串中的特殊注意事项。
@end menu

@node 键盘事件
@subsection Keyboard Events
@cindex keyboard events

@cindex character event
你可以从键盘上获得两种输入：普通键和功能键。普通键对应的是（可能是修改过的）字符；
它们产生的事件在Lisp中表示为字符。一个@dfn{字符事件}的事件类型是字符本身（一个
整数），它可能设置了一些修饰位；参见 @ref{分类事件}。

@cindex modifier bits (of input character)
@cindex basic code (of input character)
一个输入字符事件由0到524287之间的@dfn{基本码}，加上任何或所有这些@dfn{修饰位}
组成：

@table @asis
@item meta
该
@tex
@math{2^{27}}
@end tex
@ifnottex
2**27
@end ifnottex
字符码中的位表示按住元键输入的字符。

@item control
该
@tex
@math{2^{26}}
@end tex
@ifnottex
2**26
@end ifnottex
字符码中的位表示非@acronym{ASCII}控制字符。

@sc{ascii} control characters such as @kbd{C-a} have special basic
codes of their own, so Emacs needs no special bit to indicate them.
Thus, the code for @kbd{C-a} is just 1.

But if you type a control combination not in @acronym{ASCII}, such as
@kbd{%} with the control key, the numeric value you get is the code
for @kbd{%} plus
@tex
@math{2^{26}}
@end tex
@ifnottex
2**26
@end ifnottex
(assuming the terminal supports non-@acronym{ASCII}
control characters), i.e.@: with the 27th bit set.

@item shift
The
@tex
@math{2^{25}}
@end tex
@ifnottex
2**25
@end ifnottex
bit (the 26th bit) in the character event code indicates an
@acronym{ASCII} control character typed with the shift key held down.

For letters, the basic code itself indicates upper versus lower case;
for digits and punctuation, the shift key selects an entirely different
character with a different basic code.  In order to keep within the
@acronym{ASCII} character set whenever possible, Emacs avoids using the
@tex
@math{2^{25}}
@end tex
@ifnottex
2**25
@end ifnottex
bit for those character events.

However, @acronym{ASCII} provides no way to distinguish @kbd{C-A} from
@kbd{C-a}, so Emacs uses the
@tex
@math{2^{25}}
@end tex
@ifnottex
2**25
@end ifnottex
bit in @kbd{C-A} and not in
@kbd{C-a}.

@item hyper
The
@tex
@math{2^{24}}
@end tex
@ifnottex
2**24
@end ifnottex
bit in the character event code indicates a character
typed with the hyper key held down.

@item super
The
@tex
@math{2^{23}}
@end tex
@ifnottex
2**23
@end ifnottex
bit in the character event code indicates a character
typed with the super key held down.

@item alt
The
@tex
@math{2^{22}}
@end tex
@ifnottex
2**22
@end ifnottex
bit in the character event code indicates a character typed with the
alt key held down.  (The key labeled @key{Alt} on most keyboards is
actually treated as the meta key, not this.)
@end table

  It is best to avoid mentioning specific bit numbers in your program.
To test the modifier bits of a character, use the function
@code{event-modifiers} (@pxref{Classifying Events}).  When making key
bindings, you can use the read syntax for characters with modifier bits
(@samp{\C-}, @samp{\M-}, and so on).  For making key bindings with
@code{define-key}, you can use lists such as @code{(control hyper ?x)} to
specify the characters (@pxref{Changing Key Bindings}).  The function
@code{event-convert-list} converts such a list into an event type
(@pxref{Classifying Events}).

@node 功能键
@subsection Function Keys

@cindex function keys
Most keyboards also have @dfn{function keys}---keys that have names or
symbols that are not characters.  Function keys are represented in
Emacs Lisp as symbols; the symbol's name is the function key's label,
in lower case.  For example, pressing a key labeled @key{F1} generates
an input event represented by the symbol @code{f1}.

The event type of a function key event is the event symbol itself.
@xref{Classifying Events}.

Here are a few special cases in the symbol-naming convention for
function keys:

@table @asis
@item @code{backspace}, @code{tab}, @code{newline}, @code{return}, @code{delete}
These keys correspond to common @acronym{ASCII} control characters that have
special keys on most keyboards.

In @acronym{ASCII}, @kbd{C-i} and @key{TAB} are the same character.  If the
terminal can distinguish between them, Emacs conveys the distinction to
Lisp programs by representing the former as the integer 9, and the
latter as the symbol @code{tab}.

Most of the time, it's not useful to distinguish the two.  So normally
@code{local-function-key-map} (@pxref{Translation Keymaps}) is set up
to map @code{tab} into 9.  Thus, a key binding for character code 9
(the character @kbd{C-i}) also applies to @code{tab}.  Likewise for
the other symbols in this group.  The function @code{read-char}
likewise converts these events into characters.

In @acronym{ASCII}, @key{BS} is really @kbd{C-h}.  But @code{backspace}
converts into the character code 127 (@key{DEL}), not into code 8
(@key{BS}).  This is what most users prefer.

@item @code{left}, @code{up}, @code{right}, @code{down}
Cursor arrow keys
@item @code{kp-add}, @code{kp-decimal}, @code{kp-divide}, @dots{}
Keypad keys (to the right of the regular keyboard).
@item @code{kp-0}, @code{kp-1}, @dots{}
Keypad keys with digits.
@item @code{kp-f1}, @code{kp-f2}, @code{kp-f3}, @code{kp-f4}
Keypad PF keys.
@item @code{kp-home}, @code{kp-left}, @code{kp-up}, @code{kp-right}, @code{kp-down}
Keypad arrow keys.  Emacs normally translates these into the
corresponding non-keypad keys @code{home}, @code{left}, @dots{}
@item @code{kp-prior}, @code{kp-next}, @code{kp-end}, @code{kp-begin}, @code{kp-insert}, @code{kp-delete}
Additional keypad duplicates of keys ordinarily found elsewhere.  Emacs
normally translates these into the like-named non-keypad keys.
@end table

You can use the modifier keys @key{ALT}, @key{CTRL}, @key{HYPER},
@key{META}, @key{SHIFT}, and @key{SUPER} with function keys.  The way to
represent them is with prefixes in the symbol name:

@table @samp
@item A-
The alt modifier.
@item C-
The control modifier.
@item H-
The hyper modifier.
@item M-
The meta modifier.
@item S-
The shift modifier.
@item s-
The super modifier.
@end table

Thus, the symbol for the key @key{F3} with @key{META} held down is
@code{M-f3}.  When you use more than one prefix, we recommend you
write them in alphabetical order; but the order does not matter in
arguments to the key-binding lookup and modification functions.

@node 鼠标事件
@subsection Mouse Events

Emacs supports four kinds of mouse events: click events, drag events,
button-down events, and motion events.  All mouse events are represented
as lists.  The @sc{car} of the list is the event type; this says which
mouse button was involved, and which modifier keys were used with it.
The event type can also distinguish double or triple button presses
(@pxref{Repeat Events}).  The rest of the list elements give position
and time information.

For key lookup, only the event type matters: two events of the same type
necessarily run the same command.  The command can access the full
values of these events using the @samp{e} interactive code.
@xref{Interactive Codes}.

A key sequence that starts with a mouse event is read using the keymaps
of the buffer in the window that the mouse was in, not the current
buffer.  This does not imply that clicking in a window selects that
window or its buffer---that is entirely under the control of the command
binding of the key sequence.

@node 点击事件
@subsection Click Events
@cindex click event
@cindex mouse click event

When the user presses a mouse button and releases it at the same
location, that generates a @dfn{click} event.  All mouse click event
share the same format:

@example
(@var{event-type} @var{position} @var{click-count})
@end example

@table @asis
@item @var{event-type}
This is a symbol that indicates which mouse button was used.  It is
one of the symbols @code{mouse-1}, @code{mouse-2}, @dots{}, where the
buttons are numbered left to right.

You can also use prefixes @samp{A-}, @samp{C-}, @samp{H-}, @samp{M-},
@samp{S-} and @samp{s-} for modifiers alt, control, hyper, meta, shift
and super, just as you would with function keys.

This symbol also serves as the event type of the event.  Key bindings
describe events by their types; thus, if there is a key binding for
@code{mouse-1}, that binding would apply to all events whose
@var{event-type} is @code{mouse-1}.

@item @var{position}
@cindex mouse position list
This is a @dfn{mouse position list} specifying where the mouse click
occurred; see below for details.

@item @var{click-count}
This is the number of rapid repeated presses so far of the same mouse
button.  @xref{Repeat Events}.
@end table

  To access the contents of a mouse position list in the
@var{position} slot of a click event, you should typically use the
functions documented in @ref{Accessing Mouse}.  The explicit format of
the list depends on where the click occurred.  For clicks in the text
area, mode line, header line, tab line, or in the fringe or marginal
areas, the mouse position list has the form

@example
(@var{window} @var{pos-or-area} (@var{x} . @var{y}) @var{timestamp}
 @var{object} @var{text-pos} (@var{col} . @var{row})
 @var{image} (@var{dx} . @var{dy}) (@var{width} . @var{height}))
@end example

@noindent
The meanings of these list elements are as follows:

@table @asis
@item @var{window}
The window in which the click occurred.

@item @var{pos-or-area}
The buffer position of the character clicked on in the text area; or,
if the click was outside the text area, the window area where it
occurred.  It is one of the symbols @code{mode-line},
@code{header-line}, @code{tab-line}, @code{vertical-line},
@code{left-margin}, @code{right-margin}, @code{left-fringe}, or
@code{right-fringe}.

In one special case, @var{pos-or-area} is a list containing a symbol
(one of the symbols listed above) instead of just the symbol.  This
happens after the imaginary prefix keys for the event are registered
by Emacs.  @xref{Key Sequence Input}.

@item @var{x}, @var{y}
The relative pixel coordinates of the click.  For clicks in the text
area of a window, the coordinate origin @code{(0 . 0)} is taken to be
the top left corner of the text area.  @xref{Window Sizes}.  For
clicks in a mode line, header line or tab line, the coordinate origin
is the top left corner of the window itself.  For fringes, margins,
and the vertical border, @var{x} does not have meaningful data.
For fringes and margins, @var{y} is relative to the bottom edge of the
header line.  In all cases, the @var{x} and @var{y} coordinates
increase rightward and downward respectively.

@item @var{timestamp}
The time at which the event occurred, as an integer number of
milliseconds since a system-dependent initial time.

@item @var{object}
Either @code{nil}, which means the click occurred on buffer text, or a
cons cell of the form @w{(@var{string} . @var{string-pos})} if there
is a string from a text property or an overlay at the click position.

@table @asis
@item @var{string}
The string which was clicked on, including any properties.

@item @var{string-pos}
The position in the string where the click occurred.
@end table

@item @var{text-pos}
For clicks on a marginal area or on a fringe, this is the buffer
position of the first visible character in the corresponding line in
the window.  For clicks on the mode line, the header line or the tab
line, this is @code{nil}.  For other events, it is the buffer position
closest to the click.

@item @var{col}, @var{row}
These are the actual column and row coordinate numbers of the glyph
under the @var{x}, @var{y} position.  If @var{x} lies beyond the last
column of actual text on its line, @var{col} is reported by adding
fictional extra columns that have the default character width.
Row 0 is taken to be the header line if the window has one, or Row 1
if the window also has the tab line, or the topmost row of
the text area otherwise.  Column 0 is taken to be the leftmost
column of the text area for clicks on a window text area, or the
leftmost mode line or header line column for clicks there.  For clicks
on fringes or vertical borders, these have no meaningful data.  For
clicks on margins, @var{col} is measured from the left edge of the
margin area and @var{row} is measured from the top of the margin area.

@item @var{image}
If there is an image at the click location, this is the image object
as returned by @code{find-image} (@pxref{Defining Images}); otherwise
this is @code{nil}.

@item @var{dx}, @var{dy}
These are the pixel coordinates of the click, relative to the top left
corner of @var{object}, which is @code{(0 . 0)}.  If @var{object} is
@code{nil}, which stands for a buffer, the coordinates are relative to
the top left corner of the character glyph clicked on.

@item @var{width}, @var{height}
These are the pixel width and height of @var{object} or, if this is
@code{nil}, those of the character glyph clicked on.
@end table

For clicks on a scroll bar, @var{position} has this form:

@example
(@var{window} @var{area} (@var{portion} . @var{whole}) @var{timestamp} @var{part})
@end example

@table @asis
@item @var{window}
The window whose scroll bar was clicked on.

@item @var{area}
This is the symbol @code{vertical-scroll-bar}.

@item @var{portion}
The number of pixels from the top of the scroll bar to the click
position.  On some toolkits, including GTK+, Emacs cannot extract this
data, so the value is always @code{0}.

@item @var{whole}
The total length, in pixels, of the scroll bar.  On some toolkits,
including GTK+, Emacs cannot extract this data, so the value is always
@code{0}.

@item @var{timestamp}
The time at which the event occurred, in milliseconds.  On some
toolkits, including GTK+, Emacs cannot extract this data, so the value
is always @code{0}.

@item @var{part}
The part of the scroll bar on which the click occurred.  It is one of
the symbols @code{handle} (the scroll bar handle), @code{above-handle}
(the area above the handle), @code{below-handle} (the area below the
handle), @code{up} (the up arrow at one end of the scroll bar), or
@code{down} (the down arrow at one end of the scroll bar).
@c The 'top', 'bottom', and 'end-scroll' codes don't seem to be used.
@end table


@node 拖动事件
@subsection Drag Events
@cindex drag event
@cindex mouse drag event

With Emacs, you can have a drag event without even changing your
clothes.  A @dfn{drag event} happens every time the user presses a mouse
button and then moves the mouse to a different character position before
releasing the button.  Like all mouse events, drag events are
represented in Lisp as lists.  The lists record both the starting mouse
position and the final position, like this:

@example
(@var{event-type}
 (@var{window1} START-POSITION)
 (@var{window2} END-POSITION))
@end example

For a drag event, the name of the symbol @var{event-type} contains the
prefix @samp{drag-}.  For example, dragging the mouse with button 2
held down generates a @code{drag-mouse-2} event.  The second and third
elements of the event give the starting and ending position of the
drag, as mouse position lists (@pxref{Click Events}).  You can access
the second element of any mouse event in the same way.  However, the
drag event may end outside the boundaries of the frame that was
initially selected.  In that case, the third element's position list
contains that frame in place of a window.

The @samp{drag-} prefix follows the modifier key prefixes such as
@samp{C-} and @samp{M-}.

If @code{read-key-sequence} receives a drag event that has no key
binding, and the corresponding click event does have a binding, it
changes the drag event into a click event at the drag's starting
position.  This means that you don't have to distinguish between click
and drag events unless you want to.

@node 按下按钮事件
@subsection Button-Down Events
@cindex button-down event

Click and drag events happen when the user releases a mouse button.
They cannot happen earlier, because there is no way to distinguish a
click from a drag until the button is released.

If you want to take action as soon as a button is pressed, you need to
handle @dfn{button-down} events.@footnote{Button-down is the
conservative antithesis of drag.}  These occur as soon as a button is
pressed.  They are represented by lists that look exactly like click
events (@pxref{Click Events}), except that the @var{event-type} symbol
name contains the prefix @samp{down-}.  The @samp{down-} prefix follows
modifier key prefixes such as @samp{C-} and @samp{M-}.

The function @code{read-key-sequence} ignores any button-down events
that don't have command bindings; therefore, the Emacs command loop
ignores them too.  This means that you need not worry about defining
button-down events unless you want them to do something.  The usual
reason to define a button-down event is so that you can track mouse
motion (by reading motion events) until the button is released.
@xref{Motion Events}.

@node 重复事件
@subsection Repeat Events
@cindex repeat events
@cindex double-click events
@cindex triple-click events
@cindex mouse events, repeated

If you press the same mouse button more than once in quick succession
without moving the mouse, Emacs generates special @dfn{repeat} mouse
events for the second and subsequent presses.

The most common repeat events are @dfn{double-click} events.  Emacs
generates a double-click event when you click a button twice; the event
happens when you release the button (as is normal for all click
events).

The event type of a double-click event contains the prefix
@samp{double-}.  Thus, a double click on the second mouse button with
@key{meta} held down comes to the Lisp program as
@code{M-double-mouse-2}.  If a double-click event has no binding, the
binding of the corresponding ordinary click event is used to execute
it.  Thus, you need not pay attention to the double click feature
unless you really want to.

When the user performs a double click, Emacs generates first an ordinary
click event, and then a double-click event.  Therefore, you must design
the command binding of the double click event to assume that the
single-click command has already run.  It must produce the desired
results of a double click, starting from the results of a single click.

This is convenient, if the meaning of a double click somehow builds
on the meaning of a single click---which is recommended user interface
design practice for double clicks.

If you click a button, then press it down again and start moving the
mouse with the button held down, then you get a @dfn{double-drag} event
when you ultimately release the button.  Its event type contains
@samp{double-drag} instead of just @samp{drag}.  If a double-drag event
has no binding, Emacs looks for an alternate binding as if the event
were an ordinary drag.

Before the double-click or double-drag event, Emacs generates a
@dfn{double-down} event when the user presses the button down for the
second time.  Its event type contains @samp{double-down} instead of just
@samp{down}.  If a double-down event has no binding, Emacs looks for an
alternate binding as if the event were an ordinary button-down event.
If it finds no binding that way either, the double-down event is
ignored.

To summarize, when you click a button and then press it again right
away, Emacs generates a down event and a click event for the first
click, a double-down event when you press the button again, and finally
either a double-click or a double-drag event.

If you click a button twice and then press it again, all in quick
succession, Emacs generates a @dfn{triple-down} event, followed by
either a @dfn{triple-click} or a @dfn{triple-drag}.  The event types of
these events contain @samp{triple} instead of @samp{double}.  If any
triple event has no binding, Emacs uses the binding that it would use
for the corresponding double event.

If you click a button three or more times and then press it again, the
events for the presses beyond the third are all triple events.  Emacs
does not have separate event types for quadruple, quintuple, etc.@:
events.  However, you can look at the event list to find out precisely
how many times the button was pressed.

@defun event-click-count event
This function returns the number of consecutive button presses that led
up to @var{event}.  If @var{event} is a double-down, double-click or
double-drag event, the value is 2.  If @var{event} is a triple event,
the value is 3 or greater.  If @var{event} is an ordinary mouse event
(not a repeat event), the value is 1.
@end defun

@defopt double-click-fuzz
To generate repeat events, successive mouse button presses must be at
approximately the same screen position.  The value of
@code{double-click-fuzz} specifies the maximum number of pixels the
mouse may be moved (horizontally or vertically) between two successive
clicks to make a double-click.

This variable is also the threshold for motion of the mouse to count
as a drag.
@end defopt

@defopt double-click-time
To generate repeat events, the number of milliseconds between
successive button presses must be less than the value of
@code{double-click-time}.  Setting @code{double-click-time} to
@code{nil} disables multi-click detection entirely.  Setting it to
@code{t} removes the time limit; Emacs then detects multi-clicks by
position only.
@end defopt

@node 运动事件
@subsection Motion Events
@cindex motion event
@cindex mouse motion events

Emacs sometimes generates @dfn{mouse motion} events to describe motion
of the mouse without any button activity.  Mouse motion events are
represented by lists that look like this:

@example
(mouse-movement POSITION)
@end example

@noindent
@var{position} is a mouse position list (@pxref{Click Events}),
specifying the current position of the mouse cursor.  As with the
end-position of a drag event, this position list may represent a
location outside the boundaries of the initially selected frame, in
which case the list contains that frame in place of a window.

The special form @code{track-mouse} enables generation of motion
events within its body.  Outside of @code{track-mouse} forms, Emacs
does not generate events for mere motion of the mouse, and these
events do not appear.  @xref{Mouse Tracking}.

@defvar mouse-fine-grained-tracking
When non-@code{nil}, mouse motion events are generated even for very
small movements.  Otherwise, motion events are not generated as long
as the mouse cursor remains pointing to the same glyph in the text.
@end defvar

@node 焦点事件
@subsection Focus Events
@cindex focus event

Window systems provide general ways for the user to control which window
gets keyboard input.  This choice of window is called the @dfn{focus}.
When the user does something to switch between Emacs frames, that
generates a @dfn{focus event}.  The normal definition of a focus event,
in the global keymap, is to select a new frame within Emacs, as the user
would expect.  @xref{Input Focus}, which also describes hooks related
to focus events.

Focus events are represented in Lisp as lists that look like this:

@example
(switch-frame @var{new-frame})
@end example

@noindent
where @var{new-frame} is the frame switched to.

Some X window managers are set up so that just moving the mouse into a
window is enough to set the focus there.  Usually, there is no need
for a Lisp program to know about the focus change until some other
kind of input arrives.  Emacs generates a focus event only when the
user actually types a keyboard key or presses a mouse button in the
new frame; just moving the mouse between frames does not generate a
focus event.

A focus event in the middle of a key sequence would garble the
sequence.  So Emacs never generates a focus event in the middle of a key
sequence.  If the user changes focus in the middle of a key
sequence---that is, after a prefix key---then Emacs reorders the events
so that the focus event comes either before or after the multi-event key
sequence, and not within it.

@node 杂项事件
@subsection Miscellaneous System Events

A few other event types represent occurrences within the system.

@table @code
@cindex @code{delete-frame} event
@item (delete-frame (@var{frame}))
This kind of event indicates that the user gave the window manager
a command to delete a particular window, which happens to be an Emacs frame.

The standard definition of the @code{delete-frame} event is to delete @var{frame}.

@cindex @code{iconify-frame} event
@item (iconify-frame (@var{frame}))
This kind of event indicates that the user iconified @var{frame} using
the window manager.  Its standard definition is @code{ignore}; since the
frame has already been iconified, Emacs has no work to do.  The purpose
of this event type is so that you can keep track of such events if you
want to.

@cindex @code{make-frame-visible} event
@item (make-frame-visible (@var{frame}))
This kind of event indicates that the user deiconified @var{frame} using
the window manager.  Its standard definition is @code{ignore}; since the
frame has already been made visible, Emacs has no work to do.

@cindex @code{wheel-up} event
@cindex @code{wheel-down} event
@item (wheel-up @var{position})
@itemx (wheel-down @var{position})
These kinds of event are generated by moving a mouse wheel.  The
@var{position} element is a mouse position list (@pxref{Click
Events}), specifying the position of the mouse cursor when the event
occurred.

@vindex mouse-wheel-up-event
@vindex mouse-wheel-down-event
This kind of event is generated only on some kinds of systems.  On some
systems, @code{mouse-4} and @code{mouse-5} are used instead.  For
portable code, use the variables @code{mouse-wheel-up-event} and
@code{mouse-wheel-down-event} defined in @file{mwheel.el} to determine
what event types to expect for the mouse wheel.

@cindex @code{drag-n-drop} event
@item (drag-n-drop @var{position} @var{files})
This kind of event is generated when a group of files is
selected in an application outside of Emacs, and then dragged and
dropped onto an Emacs frame.

The element @var{position} is a list describing the position of the
event, in the same format as used in a mouse-click event (@pxref{Click
Events}), and @var{files} is the list of file names that were dragged
and dropped.  The usual way to handle this event is by visiting these
files.

This kind of event is generated, at present, only on some kinds of
systems.

@cindex @code{help-echo} event
@item help-echo
This kind of event is generated when a mouse pointer moves onto a
portion of buffer text which has a @code{help-echo} text property.
The generated event has this form:

@example
(help-echo @var{frame} @var{help} @var{window} @var{object} @var{pos})
@end example

@noindent
The precise meaning of the event parameters and the way these
parameters are used to display the help-echo text are described in
@ref{Text help-echo}.

@cindex @code{sigusr1} event
@cindex @code{sigusr2} event
@cindex user signals
@item sigusr1
@itemx sigusr2
These events are generated when the Emacs process receives
the signals @code{SIGUSR1} and @code{SIGUSR2}.  They contain no
additional data because signals do not carry additional information.
They can be useful for debugging (@pxref{Error Debugging}).

To catch a user signal, bind the corresponding event to an interactive
command in the @code{special-event-map} (@pxref{Controlling Active Maps}).
The command is called with no arguments, and the specific signal event is
available in @code{last-input-event} (@pxref{Event Input Misc}.  For
example:

@smallexample
(defun sigusr-handler ()
  (interactive)
  (message "Caught signal %S" last-input-event))

(define-key special-event-map [sigusr1] 'sigusr-handler)
@end smallexample

To test the signal handler, you can make Emacs send a signal to itself:

@smallexample
(signal-process (emacs-pid) 'sigusr1)
@end smallexample

@cindex @code{language-change} event
@item language-change
This kind of event is generated on MS-Windows when the input language
has changed.  This typically means that the keyboard keys will send to
Emacs characters from a different language.  The generated event has
this form:

@smallexample
(language-change @var{frame} @var{codepage} @var{language-id})
@end smallexample

@noindent
Here @var{frame} is the frame which was current when the input
language changed; @var{codepage} is the new codepage number; and
@var{language-id} is the numerical ID of the new input language.  The
coding-system (@pxref{Coding Systems}) that corresponds to
@var{codepage} is @code{cp@var{codepage}} or
@code{windows-@var{codepage}}.  To convert @var{language-id} to a
string (e.g., to use it for various language-dependent features, such
as @code{set-language-environment}), use the
@code{w32-get-locale-info} function, like this:

@smallexample
;; Get the abbreviated language name, such as "ENU" for English
(w32-get-locale-info language-id)
;; Get the full English name of the language,
;; such as "English (United States)"
(w32-get-locale-info language-id 4097)
;; Get the full localized name of the language
(w32-get-locale-info language-id t)
@end smallexample
@end table

  If one of these events arrives in the middle of a key sequence---that
is, after a prefix key---then Emacs reorders the events so that this
event comes either before or after the multi-event key sequence, not
within it.

@node 事件示例
@subsection Event Examples

If the user presses and releases the left mouse button over the same
location, that generates a sequence of events like this:

@smallexample
(down-mouse-1 (#<window 18 on NEWS> 2613 (0 . 38) -864320))
(mouse-1      (#<window 18 on NEWS> 2613 (0 . 38) -864180))
@end smallexample

While holding the control key down, the user might hold down the
second mouse button, and drag the mouse from one line to the next.
That produces two events, as shown here:

@smallexample
(C-down-mouse-2 (#<window 18 on NEWS> 3440 (0 . 27) -731219))
(C-drag-mouse-2 (#<window 18 on NEWS> 3440 (0 . 27) -731219)
                (#<window 18 on NEWS> 3510 (0 . 28) -729648))
@end smallexample

While holding down the meta and shift keys, the user might press the
second mouse button on the window's mode line, and then drag the mouse
into another window.  That produces a pair of events like these:

@smallexample
(M-S-down-mouse-2 (#<window 18 on NEWS> mode-line (33 . 31) -457844))
(M-S-drag-mouse-2 (#<window 18 on NEWS> mode-line (33 . 31) -457844)
                  (#<window 20 on carlton-sanskrit.tex> 161 (33 . 3)
                   -453816))
@end smallexample

The frame with input focus might not take up the entire screen, and
the user might move the mouse outside the scope of the frame.  Inside
the @code{track-mouse} special form, that produces an event like this:

@smallexample
(mouse-movement (#<frame *ielm* 0x102849a30> nil (563 . 205) 532301936))
@end smallexample

To handle a SIGUSR1 signal, define an interactive function, and
bind it to the @code{signal usr1} event sequence:

@smallexample
(defun usr1-handler ()
  (interactive)
  (message "Got USR1 signal"))
(global-set-key [signal usr1] 'usr1-handler)
@end smallexample

@node 分类事件
@subsection Classifying Events
@cindex event type
@cindex classifying events

  Every event has an @dfn{event type}, which classifies the event for
key binding purposes.  For a keyboard event, the event type equals the
event value; thus, the event type for a character is the character, and
the event type for a function key symbol is the symbol itself.  For
events that are lists, the event type is the symbol in the @sc{car} of
the list.  Thus, the event type is always a symbol or a character.

  Two events of the same type are equivalent where key bindings are
concerned; thus, they always run the same command.  That does not
necessarily mean they do the same things, however, as some commands look
at the whole event to decide what to do.  For example, some commands use
the location of a mouse event to decide where in the buffer to act.

  Sometimes broader classifications of events are useful.  For example,
you might want to ask whether an event involved the @key{META} key,
regardless of which other key or mouse button was used.

  The functions @code{event-modifiers} and @code{event-basic-type} are
provided to get such information conveniently.

@defun event-modifiers event
This function returns a list of the modifiers that @var{event} has.  The
modifiers are symbols; they include @code{shift}, @code{control},
@code{meta}, @code{alt}, @code{hyper} and @code{super}.  In addition,
the modifiers list of a mouse event symbol always contains one of
@code{click}, @code{drag}, and @code{down}.  For double or triple
events, it also contains @code{double} or @code{triple}.

The argument @var{event} may be an entire event object, or just an
event type.  If @var{event} is a symbol that has never been used in an
event that has been read as input in the current Emacs session, then
@code{event-modifiers} can return @code{nil}, even when @var{event}
actually has modifiers.

Here are some examples:

@example
(event-modifiers ?a)
     @result{} nil
(event-modifiers ?A)
     @result{} (shift)
(event-modifiers ?\C-a)
     @result{} (control)
(event-modifiers ?\C-%)
     @result{} (control)
(event-modifiers ?\C-\S-a)
     @result{} (control shift)
(event-modifiers 'f5)
     @result{} nil
(event-modifiers 's-f5)
     @result{} (super)
(event-modifiers 'M-S-f5)
     @result{} (meta shift)
(event-modifiers 'mouse-1)
     @result{} (click)
(event-modifiers 'down-mouse-1)
     @result{} (down)
@end example

The modifiers list for a click event explicitly contains @code{click},
but the event symbol name itself does not contain @samp{click}.
Similarly, the modifiers list for an @acronym{ASCII} control
character, such as @samp{C-a}, contains @code{control}, even though
reading such an event via @code{read-char} will return the value 1
with the control modifier bit removed.
@end defun

@defun event-basic-type event
This function returns the key or mouse button that @var{event}
describes, with all modifiers removed.  The @var{event} argument is as
in @code{event-modifiers}.  For example:

@example
(event-basic-type ?a)
     @result{} 97
(event-basic-type ?A)
     @result{} 97
(event-basic-type ?\C-a)
     @result{} 97
(event-basic-type ?\C-\S-a)
     @result{} 97
(event-basic-type 'f5)
     @result{} f5
(event-basic-type 's-f5)
     @result{} f5
(event-basic-type 'M-S-f5)
     @result{} f5
(event-basic-type 'down-mouse-1)
     @result{} mouse-1
@end example
@end defun

@defun mouse-movement-p object
This function returns non-@code{nil} if @var{object} is a mouse movement
event.  @xref{Motion Events}.
@end defun

@defun event-convert-list list
This function converts a list of modifier names and a basic event type
to an event type which specifies all of them.  The basic event type
must be the last element of the list.  For example,

@example
(event-convert-list '(control ?a))
     @result{} 1
(event-convert-list '(control meta ?a))
     @result{} -134217727
(event-convert-list '(control super f1))
     @result{} C-s-f1
@end example
@end defun

@node 访问鼠标
@subsection Accessing Mouse Events
@cindex mouse events, data in
@cindex keyboard events, data in

  This section describes convenient functions for accessing the data in
a mouse button or motion event.  Keyboard event data can be accessed
using the same functions, but data elements that aren't applicable to
keyboard events are zero or @code{nil}.

  The following two functions return a mouse position list
(@pxref{Click Events}), specifying the position of a mouse event.

@defun event-start event
This returns the starting position of @var{event}.

If @var{event} is a click or button-down event, this returns the
location of the event.  If @var{event} is a drag event, this returns the
drag's starting position.
@end defun

@defun event-end event
This returns the ending position of @var{event}.

If @var{event} is a drag event, this returns the position where the user
released the mouse button.  If @var{event} is a click or button-down
event, the value is actually the starting position, which is the only
position such events have.
@end defun

@defun posnp object
This function returns non-@code{nil} if @var{object} is a mouse
position list, in the format documented in @ref{Click Events}); and
@code{nil} otherwise.
@end defun

@cindex mouse position list, accessing
  These functions take a mouse position list as argument, and return
various parts of it:

@defun posn-window position
Return the window that @var{position} is in.  If @var{position}
represents a location outside the frame where the event was initiated,
return that frame instead.
@end defun

@defun posn-area position
Return the window area recorded in @var{position}.  It returns @code{nil}
when the event occurred in the text area of the window; otherwise, it
is a symbol identifying the area in which the event occurred.
@end defun

@defun posn-point position
Return the buffer position in @var{position}.  When the event occurred
in the text area of the window, in a marginal area, or on a fringe,
this is an integer specifying a buffer position.  Otherwise, the value
is undefined.
@end defun

@defun posn-x-y position
Return the pixel-based x and y coordinates in @var{position}, as a
cons cell @w{@code{(@var{x} . @var{y})}}.  These coordinates are
relative to the window given by @code{posn-window}.

This example shows how to convert the window-relative coordinates in
the text area of a window into frame-relative coordinates:

@example
(defun frame-relative-coordinates (position)
  "Return frame-relative coordinates from POSITION.
POSITION is assumed to lie in a window text area."
  (let* ((x-y (posn-x-y position))
         (window (posn-window position))
         (edges (window-inside-pixel-edges window)))
    (cons (+ (car x-y) (car edges))
          (+ (cdr x-y) (cadr edges)))))
@end example
@end defun

@defun posn-col-row position
This function returns a cons cell @w{@code{(@var{col} .  @var{row})}},
containing the estimated column and row corresponding to buffer
position described by @var{position}.  The return value is given in
units of the frame's default character width and default line height
(including spacing), as computed from the @var{x} and @var{y} values
corresponding to @var{position}.  (So, if the actual characters have
non-default sizes, the actual row and column may differ from these
computed values.)

Note that @var{row} is counted from the top of the text area.  If the
window given by @var{position} possesses a header line (@pxref{Header
Lines}) or a tab line, they are @emph{not} included in the @var{row}
count.
@end defun

@defun posn-actual-col-row position
Return the actual row and column in @var{position}, as a cons cell
@w{@code{(@var{col} . @var{row})}}.  The values are the actual row and
column numbers in the window given by @var{position}.  @xref{Click
Events}, for details.  The function returns @code{nil} if
@var{position} does not include actual position values; in that case
@code{posn-col-row} can be used to get approximate values.

Note that this function doesn't account for the visual width of
characters on display, like the number of visual columns taken by a
tab character or an image.  If you need the coordinates in canonical
character units, use @code{posn-col-row} instead.
@end defun

@defun posn-string position
Return the string object described by @var{position}, either
@code{nil} (which means @var{position} describes buffer text), or a
cons cell @w{@code{(@var{string} . @var{string-pos})}}.
@end defun

@defun posn-image position
Return the image object in @var{position}, either @code{nil} (if
there's no image at @var{position}), or an image spec @w{@code{(image
@dots{})}}.
@end defun

@defun posn-object position
Return the image or string object described by @var{position}, either
@code{nil} (which means @var{position} describes buffer text), an
image @w{@code{(image @dots{})}}, or a cons cell
@w{@code{(@var{string} . @var{string-pos})}}.
@end defun

@defun posn-object-x-y position
Return the pixel-based x and y coordinates relative to the upper left
corner of the object described by @var{position}, as a cons cell
@w{@code{(@var{dx} . @var{dy})}}.  If the @var{position} describes
buffer text, return the relative coordinates of the buffer-text character
closest to that position.
@end defun

@defun posn-object-width-height position
Return the pixel width and height of the object described by
@var{position}, as a cons cell @code{(@var{width} . @var{height})}.
If the @var{position} describes a buffer position, return the size of
the character at that position.
@end defun

@cindex timestamp of a mouse event
@defun posn-timestamp position
Return the timestamp in @var{position}.  This is the time at which the
event occurred, in milliseconds.
@end defun

  These functions compute a position list given particular buffer
position or screen position.  You can access the data in this position
list with the functions described above.

@defun posn-at-point &optional pos window
This function returns a position list for position @var{pos} in
@var{window}.  @var{pos} defaults to point in @var{window};
@var{window} defaults to the selected window.

@code{posn-at-point} returns @code{nil} if @var{pos} is not visible in
@var{window}.
@end defun

@defun posn-at-x-y x y &optional frame-or-window whole
This function returns position information corresponding to pixel
coordinates @var{x} and @var{y} in a specified frame or window,
@var{frame-or-window}, which defaults to the selected window.
The coordinates @var{x} and @var{y} are relative to the
frame or window used.
If @var{whole} is @code{nil}, the coordinates are relative
to the window text area, otherwise they are relative to
the entire window area including scroll bars, margins and fringes.
@end defun

@node 访问滚动条
@subsection Accessing Scroll Bar Events
@cindex scroll bar events, data in

  These functions are useful for decoding scroll bar events.

@defun scroll-bar-event-ratio event
This function returns the fractional vertical position of a scroll bar
event within the scroll bar.  The value is a cons cell
@code{(@var{portion} . @var{whole})} containing two integers whose ratio
is the fractional position.
@end defun

@defun scroll-bar-scale ratio total
This function multiplies (in effect) @var{ratio} by @var{total},
rounding the result to an integer.  The argument @var{ratio} is not a
number, but rather a pair @code{(@var{num} . @var{denom})}---typically a
value returned by @code{scroll-bar-event-ratio}.

This function is handy for scaling a position on a scroll bar into a
buffer position.  Here's how to do that:

@example
(+ (point-min)
   (scroll-bar-scale
      (posn-x-y (event-start event))
      (- (point-max) (point-min))))
@end example

Recall that scroll bar events have two integers forming a ratio, in place
of a pair of x and y coordinates.
@end defun

@node 事件字符串
@subsection Putting Keyboard Events in Strings
@cindex keyboard events in strings
@cindex strings with keyboard events

  In most of the places where strings are used, we conceptualize the
string as containing text characters---the same kind of characters found
in buffers or files.  Occasionally Lisp programs use strings that
conceptually contain keyboard characters; for example, they may be key
sequences or keyboard macro definitions.  However, storing keyboard
characters in a string is a complex matter, for reasons of historical
compatibility, and it is not always possible.

  We recommend that new programs avoid dealing with these complexities
by not storing keyboard events in strings.  Here is how to do that:

@itemize @bullet
@item
Use vectors instead of strings for key sequences, when you plan to use
them for anything other than as arguments to @code{lookup-key} and
@code{define-key}.  For example, you can use
@code{read-key-sequence-vector} instead of @code{read-key-sequence}, and
@code{this-command-keys-vector} instead of @code{this-command-keys}.

@item
Use vectors to write key sequence constants containing meta characters,
even when passing them directly to @code{define-key}.

@item
When you have to look at the contents of a key sequence that might be a
string, use @code{listify-key-sequence} (@pxref{Event Input Misc})
first, to convert it to a list.
@end itemize

  The complexities stem from the modifier bits that keyboard input
characters can include.  Aside from the Meta modifier, none of these
modifier bits can be included in a string, and the Meta modifier is
allowed only in special cases.

  The earliest GNU Emacs versions represented meta characters as codes
in the range of 128 to 255.  At that time, the basic character codes
ranged from 0 to 127, so all keyboard character codes did fit in a
string.  Many Lisp programs used @samp{\M-} in string constants to stand
for meta characters, especially in arguments to @code{define-key} and
similar functions, and key sequences and sequences of events were always
represented as strings.

  When we added support for larger basic character codes beyond 127, and
additional modifier bits, we had to change the representation of meta
characters.  Now the flag that represents the Meta modifier in a
character is
@tex
@math{2^{27}}
@end tex
@ifnottex
2**27
@end ifnottex
and such numbers cannot be included in a string.

  To support programs with @samp{\M-} in string constants, there are
special rules for including certain meta characters in a string.
Here are the rules for interpreting a string as a sequence of input
characters:

@itemize @bullet
@item
If the keyboard character value is in the range of 0 to 127, it can go
in the string unchanged.

@item
The meta variants of those characters, with codes in the range of
@tex
@math{2^{27}}
@end tex
@ifnottex
2**27
@end ifnottex
to
@tex
@math{2^{27} + 127},
@end tex
@ifnottex
2**27+127,
@end ifnottex
can also go in the string, but you must change their
numeric values.  You must set the
@tex
@math{2^{7}}
@end tex
@ifnottex
2**7
@end ifnottex
bit instead of the
@tex
@math{2^{27}}
@end tex
@ifnottex
2**27
@end ifnottex
bit, resulting in a value between 128 and 255.  Only a unibyte string
can include these codes.

@item
Non-@acronym{ASCII} characters above 256 can be included in a multibyte string.

@item
Other keyboard character events cannot fit in a string.  This includes
keyboard events in the range of 128 to 255.
@end itemize

  Functions such as @code{read-key-sequence} that construct strings of
keyboard input characters follow these rules: they construct vectors
instead of strings, when the events won't fit in a string.

  When you use the read syntax @samp{\M-} in a string, it produces a
code in the range of 128 to 255---the same code that you get if you
modify the corresponding keyboard event to put it in the string.  Thus,
meta events in strings work consistently regardless of how they get into
the strings.

  However, most programs would do well to avoid these issues by
following the recommendations at the beginning of this section.

@node 读取输入
@section Reading Input
@cindex read input
@cindex keyboard input

  The editor command loop reads key sequences using the function
@code{read-key-sequence}, which uses @code{read-event}.  These and other
functions for event input are also available for use in Lisp programs.
See also @code{momentary-string-display} in @ref{Temporary Displays},
and @code{sit-for} in @ref{Waiting}.  @xref{Terminal Input}, for
functions and variables for controlling terminal input modes and
debugging terminal input.

  For higher-level input facilities, see @ref{Minibuffers}.

@menu
* Key Sequence Input::          How to read one key sequence.
* Reading One Event::           How to read just one event.
* Event Mod::                   How Emacs modifies events as they are read.
* Invoking the Input Method::   How reading an event uses the input method.
* Quoted Character Input::      Asking the user to specify a character.
* Event Input Misc::            How to reread or throw away input events.
@end menu

@node Key Sequence Input
@subsection Key Sequence Input
@cindex key sequence input

  The command loop reads input a key sequence at a time, by calling
@code{read-key-sequence}.  Lisp programs can also call this function;
for example, @code{describe-key} uses it to read the key to describe.

@defun read-key-sequence prompt &optional continue-echo dont-downcase-last switch-frame-ok command-loop
This function reads a key sequence and returns it as a string or
vector.  It keeps reading events until it has accumulated a complete key
sequence; that is, enough to specify a non-prefix command using the
currently active keymaps.  (Remember that a key sequence that starts
with a mouse event is read using the keymaps of the buffer in the
window that the mouse was in, not the current buffer.)

If the events are all characters and all can fit in a string, then
@code{read-key-sequence} returns a string (@pxref{事件字符串}).
Otherwise, it returns a vector, since a vector can hold all kinds of
events---characters, symbols, and lists.  The elements of the string or
vector are the events in the key sequence.

Reading a key sequence includes translating the events in various
ways.  @xref{Translation Keymaps}.

The argument @var{prompt} is either a string to be displayed in the
echo area as a prompt, or @code{nil}, meaning not to display a prompt.
The argument @var{continue-echo}, if non-@code{nil}, means to echo
this key as a continuation of the previous key.

Normally any upper case event is converted to lower case if the
original event is undefined and the lower case equivalent is defined.
The argument @var{dont-downcase-last}, if non-@code{nil}, means do not
convert the last event to lower case.  This is appropriate for reading
a key sequence to be defined.

The argument @var{switch-frame-ok}, if non-@code{nil}, means that this
function should process a @code{switch-frame} event if the user
switches frames before typing anything.  If the user switches frames
in the middle of a key sequence, or at the start of the sequence but
@var{switch-frame-ok} is @code{nil}, then the event will be put off
until after the current key sequence.

The argument @var{command-loop}, if non-@code{nil}, means that this
key sequence is being read by something that will read commands one
after another.  It should be @code{nil} if the caller will read just
one key sequence.

In the following example, Emacs displays the prompt @samp{?} in the
echo area, and then the user types @kbd{C-x C-f}.

@example
(read-key-sequence "?")

@group
---------- Echo Area ----------
?@kbd{C-x C-f}
---------- Echo Area ----------

     @result{} "^X^F"
@end group
@end example

The function @code{read-key-sequence} suppresses quitting: @kbd{C-g}
typed while reading with this function works like any other character,
and does not set @code{quit-flag}.  @xref{Quitting}.
@end defun

@defun read-key-sequence-vector prompt &optional continue-echo dont-downcase-last switch-frame-ok command-loop
This is like @code{read-key-sequence} except that it always
returns the key sequence as a vector, never as a string.
@xref{事件字符串}.
@end defun

@cindex upper case key sequence
@cindex downcasing in @code{lookup-key}
@cindex shift-translation
If an input character is upper-case (or has the shift modifier) and
has no key binding, but its lower-case equivalent has one, then
@code{read-key-sequence} converts the character to lower case.  Note
that @code{lookup-key} does not perform case conversion in this way.

@vindex this-command-keys-shift-translated
When reading input results in such a @dfn{shift-translation}, Emacs
sets the variable @code{this-command-keys-shift-translated} to a
non-@code{nil} value.  Lisp programs can examine this variable if they
need to modify their behavior when invoked by shift-translated keys.
For example, the function @code{handle-shift-selection} examines the
value of this variable to determine how to activate or deactivate the
region (@pxref{The Mark, handle-shift-selection}).

The function @code{read-key-sequence} also transforms some mouse events.
It converts unbound drag events into click events, and discards unbound
button-down events entirely.  It also reshuffles focus events and
miscellaneous window events so that they never appear in a key sequence
with any other events.

@cindex @code{tab-line} prefix key
@cindex @code{header-line} prefix key
@cindex @code{mode-line} prefix key
@cindex @code{vertical-line} prefix key
@cindex @code{horizontal-scroll-bar} prefix key
@cindex @code{vertical-scroll-bar} prefix key
@cindex @code{menu-bar} prefix key
@cindex @code{tab-bar} prefix key
@cindex mouse events, in special parts of frame
When mouse events occur in special parts of a window, such as a mode
line or a scroll bar, the event type shows nothing special---it is the
same symbol that would normally represent that combination of mouse
button and modifier keys.  The information about the window part is kept
elsewhere in the event---in the coordinates.  But
@code{read-key-sequence} translates this information into imaginary
prefix keys, all of which are symbols: @code{tab-line}, @code{header-line},
@code{horizontal-scroll-bar}, @code{menu-bar}, @code{tab-bar}, @code{mode-line},
@code{vertical-line}, and @code{vertical-scroll-bar}.  You can define
meanings for mouse clicks in special window parts by defining key
sequences using these imaginary prefix keys.

For example, if you call @code{read-key-sequence} and then click the
mouse on the window's mode line, you get two events, like this:

@example
(read-key-sequence "Click on the mode line: ")
     @result{} [mode-line
         (mouse-1
          (#<window 6 on NEWS> mode-line
           (40 . 63) 5959987))]
@end example

@defvar num-input-keys
This variable's value is the number of key sequences processed so far in
this Emacs session.  This includes key sequences read from the terminal
and key sequences read from keyboard macros being executed.
@end defvar

@node Reading One Event
@subsection Reading One Event
@cindex reading a single event
@cindex event, reading only one

  The lowest level functions for command input are @code{read-event},
@code{read-char}, and @code{read-char-exclusive}.

If you need a function to read a character using the minibuffer, use
@code{read-char-from-minibuffer} (@pxref{Multiple Queries}).

@defun read-event &optional prompt inherit-input-method seconds
This function reads and returns the next event of command input,
waiting if necessary until an event is available.

The returned event may come directly from the user, or from a keyboard
macro.  It is not decoded by the keyboard's input coding system
(@pxref{Terminal I/O Encoding}).

If the optional argument @var{prompt} is non-@code{nil}, it should be
a string to display in the echo area as a prompt.  If @var{prompt} is
@code{nil} or the string @samp{""}, @code{read-event} does not display
any message to indicate it is waiting for input; instead, it prompts
by echoing: it displays descriptions of the events that led to or were
read by the current command.  @xref{The Echo Area}.

If @var{inherit-input-method} is non-@code{nil}, then the current input
method (if any) is employed to make it possible to enter a
non-@acronym{ASCII} character.  Otherwise, input method handling is disabled
for reading this event.

If @code{cursor-in-echo-area} is non-@code{nil}, then @code{read-event}
moves the cursor temporarily to the echo area, to the end of any message
displayed there.  Otherwise @code{read-event} does not move the cursor.

If @var{seconds} is non-@code{nil}, it should be a number specifying
the maximum time to wait for input, in seconds.  If no input arrives
within that time, @code{read-event} stops waiting and returns
@code{nil}.  A floating point @var{seconds} means to wait
for a fractional number of seconds.  Some systems support only a whole
number of seconds; on these systems, @var{seconds} is rounded down.
If @var{seconds} is @code{nil}, @code{read-event} waits as long as
necessary for input to arrive.

If @var{seconds} is @code{nil}, Emacs is considered idle while waiting
for user input to arrive.  Idle timers---those created with
@code{run-with-idle-timer} (@pxref{Idle Timers})---can run during this
period.  However, if @var{seconds} is non-@code{nil}, the state of
idleness remains unchanged.  If Emacs is non-idle when
@code{read-event} is called, it remains non-idle throughout the
operation of @code{read-event}; if Emacs is idle (which can happen if
the call happens inside an idle timer), it remains idle.

If @code{read-event} gets an event that is defined as a help character,
then in some cases @code{read-event} processes the event directly without
returning.  @xref{Help Functions}.  Certain other events, called
@dfn{special events}, are also processed directly within
@code{read-event} (@pxref{Special Events}).

Here is what happens if you call @code{read-event} and then press the
right-arrow function key:

@example
@group
(read-event)
     @result{} right
@end group
@end example
@end defun

@defun read-char &optional prompt inherit-input-method seconds
This function reads and returns a character input event.  If the
user generates an event which is not a character (i.e., a mouse click or
function key event), @code{read-char} signals an error.  The arguments
work as in @code{read-event}.

If the event has modifiers, Emacs attempts to resolve them and return
the code of the corresponding character.  For example, if the user
types @kbd{C-a}, the function returns 1, which is the @acronym{ASCII}
code of the @samp{C-a} character.  If some of the modifiers cannot be
reflected in the character code, @code{read-char} leaves the
unresolved modifier bits set in the returned event.  For example, if
the user types @kbd{C-M-a}, the function returns 134217729, 8000001 in
hex, i.e.@: @samp{C-a} with the Meta modifier bit set.  This value is
not a valid character code: it fails the @code{characterp} test
(@pxref{Character Codes}).  Use @code{event-basic-type}
(@pxref{Classifying Events}) to recover the character code with the
modifier bits removed; use @code{event-modifiers} to test for
modifiers in the character event returned by @code{read-char}.

In the first example below, the user types the character @kbd{1}
(@acronym{ASCII} code 49).  The second example shows a keyboard macro
definition that calls @code{read-char} from the minibuffer using
@code{eval-expression}.  @code{read-char} reads the keyboard macro's
very next character, which is @kbd{1}.  Then @code{eval-expression}
displays its return value in the echo area.

@example
@group
(read-char)
     @result{} 49
@end group

@group
;; @r{We assume here you use @kbd{M-:} to evaluate this.}
(symbol-function 'foo)
     @result{} "^[:(read-char)^M1"
@end group
@group
(execute-kbd-macro 'foo)
     @print{} 49
     @result{} nil
@end group
@end example
@end defun

@defun read-char-exclusive &optional prompt inherit-input-method seconds
This function reads and returns a character input event.  If the
user generates an event which is not a character event,
@code{read-char-exclusive} ignores it and reads another event, until it
gets a character.  The arguments work as in @code{read-event}.  The
returned value may include modifier bits, as with @code{read-char}.
@end defun

  None of the above functions suppress quitting.

@defvar num-nonmacro-input-events
This variable holds the total number of input events received so far
from the terminal---not counting those generated by keyboard macros.
@end defvar

  We emphasize that, unlike @code{read-key-sequence}, the functions
@code{read-event}, @code{read-char}, and @code{read-char-exclusive} do
not perform the translations described in @ref{Translation Keymaps}.
If you wish to read a single key taking these translations into
account, use the function @code{read-key}:

@defun read-key &optional prompt
This function reads a single key.  It is intermediate between
@code{read-key-sequence} and @code{read-event}.  Unlike the former, it
reads a single key, not a key sequence.  Unlike the latter, it does
not return a raw event, but decodes and translates the user input
according to @code{input-decode-map}, @code{local-function-key-map},
and @code{key-translation-map} (@pxref{Translation Keymaps}).

The argument @var{prompt} is either a string to be displayed in the
echo area as a prompt, or @code{nil}, meaning not to display a prompt.
@end defun

@defun read-char-choice prompt chars &optional inhibit-quit
This function uses @code{read-key} to read and return a single
character.  It ignores any input that is not a member of @var{chars},
a list of accepted characters.  Optionally, it will also ignore
keyboard-quit events while it is waiting for valid input.  If you bind
@code{help-form} (@pxref{Help Functions}) to a non-@code{nil} value
while calling @code{read-char-choice}, then pressing @code{help-char}
causes it to evaluate @code{help-form} and display the result.  It
then continues to wait for a valid input character, or keyboard-quit.
@end defun

@defun read-multiple-choice prompt choices
Ask user a multiple choice question.  @var{prompt} should be a string
that will be displayed as the prompt.

@var{choices} is an alist where the first element in each entry is a
character to be entered, the second element is a short name for the
entry to be displayed while prompting (if there's room, it might be
shortened), and the third, optional entry is a longer explanation that
will be displayed in a help buffer if the user requests more help.

The return value is the matching value from @var{choices}.

@lisp
(read-multiple-choice
 "Continue connecting?"
 '((?a "always" "Accept certificate for this and future sessions.")
   (?s "session only" "Accept certificate this session only.")
   (?n "no" "Refuse to use certificate, close connection.")))
@end lisp

The @code{read-multiple-choice-face} face is used to highlight the
matching characters in the name string on graphical terminals.

@end defun

@node Event Mod
@subsection Modifying and Translating Input Events
@cindex modifiers of events
@cindex translating input events
@cindex event translation

  Emacs modifies every event it reads according to
@code{extra-keyboard-modifiers}, then translates it through
@code{keyboard-translate-table} (if applicable), before returning it
from @code{read-event}.

@defvar extra-keyboard-modifiers
This variable lets Lisp programs ``press'' the modifier keys on the
keyboard.  The value is a character.  Only the modifiers of the
character matter.  Each time the user types a keyboard key, it is
altered as if those modifier keys were held down.  For instance, if
you bind @code{extra-keyboard-modifiers} to @code{?\C-\M-a}, then all
keyboard input characters typed during the scope of the binding will
have the control and meta modifiers applied to them.  The character
@code{?\C-@@}, equivalent to the integer 0, does not count as a control
character for this purpose, but as a character with no modifiers.
Thus, setting @code{extra-keyboard-modifiers} to zero cancels any
modification.

When using a window system, the program can press any of the
modifier keys in this way.  Otherwise, only the @key{CTL} and @key{META}
keys can be virtually pressed.

Note that this variable applies only to events that really come from
the keyboard, and has no effect on mouse events or any other events.
@end defvar

@defvar keyboard-translate-table
This terminal-local variable is the translate table for keyboard
characters.  It lets you reshuffle the keys on the keyboard without
changing any command bindings.  Its value is normally a char-table, or
else @code{nil}.  (It can also be a string or vector, but this is
considered obsolete.)

If @code{keyboard-translate-table} is a char-table
(@pxref{Char-Tables}), then each character read from the keyboard is
looked up in this char-table.  If the value found there is
non-@code{nil}, then it is used instead of the actual input character.

Note that this translation is the first thing that happens to a
character after it is read from the terminal.  Record-keeping features
such as @code{recent-keys} and dribble files record the characters after
translation.

Note also that this translation is done before the characters are
supplied to input methods (@pxref{Input Methods}).  Use
@code{translation-table-for-input} (@pxref{Translation of Characters}),
if you want to translate characters after input methods operate.
@end defvar

@defun keyboard-translate from to
This function modifies @code{keyboard-translate-table} to translate
character code @var{from} into character code @var{to}.  It creates
the keyboard translate table if necessary.
@end defun

  Here's an example of using the @code{keyboard-translate-table} to
make @kbd{C-x}, @kbd{C-c} and @kbd{C-v} perform the cut, copy and paste
operations:

@example
(keyboard-translate ?\C-x 'control-x)
(keyboard-translate ?\C-c 'control-c)
(keyboard-translate ?\C-v 'control-v)
(global-set-key [control-x] 'kill-region)
(global-set-key [control-c] 'kill-ring-save)
(global-set-key [control-v] 'yank)
@end example

@noindent
On a graphical terminal that supports extended @acronym{ASCII} input,
you can still get the standard Emacs meanings of one of those
characters by typing it with the shift key.  That makes it a different
character as far as keyboard translation is concerned, but it has the
same usual meaning.

  @xref{Translation Keymaps}, for mechanisms that translate event sequences
at the level of @code{read-key-sequence}.

@node Invoking the Input Method
@subsection Invoking the Input Method
@cindex invoking input method

  The event-reading functions invoke the current input method, if any
(@pxref{Input Methods}).  If the value of @code{input-method-function}
is non-@code{nil}, it should be a function; when @code{read-event} reads
a printing character (including @key{SPC}) with no modifier bits, it
calls that function, passing the character as an argument.

@defvar input-method-function
If this is non-@code{nil}, its value specifies the current input method
function.

@strong{Warning:} don't bind this variable with @code{let}.  It is often
buffer-local, and if you bind it around reading input (which is exactly
when you @emph{would} bind it), switching buffers asynchronously while
Emacs is waiting will cause the value to be restored in the wrong
buffer.
@end defvar

  The input method function should return a list of events which should
be used as input.  (If the list is @code{nil}, that means there is no
input, so @code{read-event} waits for another event.)  These events are
processed before the events in @code{unread-command-events}
(@pxref{Event Input Misc}).  Events
returned by the input method function are not passed to the input method
function again, even if they are printing characters with no modifier
bits.

  If the input method function calls @code{read-event} or
@code{read-key-sequence}, it should bind @code{input-method-function} to
@code{nil} first, to prevent recursion.

  The input method function is not called when reading the second and
subsequent events of a key sequence.  Thus, these characters are not
subject to input method processing.  The input method function should
test the values of @code{overriding-local-map} and
@code{overriding-terminal-local-map}; if either of these variables is
non-@code{nil}, the input method should put its argument into a list and
return that list with no further processing.

@node Quoted Character Input
@subsection Quoted Character Input
@cindex quoted character input

  You can use the function @code{read-quoted-char} to ask the user to
specify a character, and allow the user to specify a control or meta
character conveniently, either literally or as an octal character code.
The command @code{quoted-insert} uses this function.

@defun read-quoted-char &optional prompt
@cindex octal character input
@cindex control characters, reading
@cindex nonprinting characters, reading
This function is like @code{read-char}, except that if the first
character read is an octal digit (0--7), it reads any number of octal
digits (but stopping if a non-octal digit is found), and returns the
character represented by that numeric character code.  If the
character that terminates the sequence of octal digits is @key{RET},
it is discarded.  Any other terminating character is used as input
after this function returns.

Quitting is suppressed when the first character is read, so that the
user can enter a @kbd{C-g}.  @xref{Quitting}.

If @var{prompt} is supplied, it specifies a string for prompting the
user.  The prompt string is always displayed in the echo area, followed
by a single @samp{-}.

In the following example, the user types in the octal number 177 (which
is 127 in decimal).

@example
(read-quoted-char "What character")

@group
---------- Echo Area ----------
What character @kbd{1 7 7}-
---------- Echo Area ----------

     @result{} 127
@end group
@end example
@end defun

@need 2000
@node Event Input Misc
@subsection Miscellaneous Event Input Features

This section describes how to peek ahead at events without using
them up, how to check for pending input, and how to discard pending
input.  See also the function @code{read-passwd} (@pxref{Reading a
Password}).

@defvar unread-command-events
@cindex next input
@cindex peeking at input
This variable holds a list of events waiting to be read as command
input.  The events are used in the order they appear in the list, and
removed one by one as they are used.

The variable is needed because in some cases a function reads an event
and then decides not to use it.  Storing the event in this variable
causes it to be processed normally, by the command loop or by the
functions to read command input.

@cindex prefix argument unreading
For example, the function that implements numeric prefix arguments reads
any number of digits.  When it finds a non-digit event, it must unread
the event so that it can be read normally by the command loop.
Likewise, incremental search uses this feature to unread events with no
special meaning in a search, because these events should exit the search
and then execute normally.

The reliable and easy way to extract events from a key sequence so as
to put them in @code{unread-command-events} is to use
@code{listify-key-sequence} (see below).

Normally you add events to the front of this list, so that the events
most recently unread will be reread first.

Events read from this list are not normally added to the current
command's key sequence (as returned by, e.g., @code{this-command-keys}),
as the events will already have been added once as they were read for
the first time.  An element of the form @w{@code{(t . @var{event})}}
forces @var{event} to be added to the current command's key sequence.

@cindex not recording input events
@cindex input events, prevent recording
Elements read from this list are normally recorded by the
record-keeping features (@pxref{Recording Input}) and while defining a
keyboard macro (@pxref{Keyboard Macros}).  However, an element of the
form @w{@code{(no-record . @var{event})}} causes @var{event} to be
processed normally without recording it.
@end defvar

@defun listify-key-sequence key
This function converts the string or vector @var{key} to a list of
individual events, which you can put in @code{unread-command-events}.
@end defun

@defun input-pending-p &optional check-timers
@cindex waiting for command key input
This function determines whether any command input is currently
available to be read.  It returns immediately, with value @code{t} if
there is available input, @code{nil} otherwise.  On rare occasions it
may return @code{t} when no input is available.

If the optional argument @var{check-timers} is non-@code{nil}, then if
no input is available, Emacs runs any timers which are ready.
@xref{Timers}.
@end defun

@defvar last-input-event
This variable records the last terminal input event read, whether
as part of a command or explicitly by a Lisp program.

In the example below, the Lisp program reads the character @kbd{1},
@acronym{ASCII} code 49.  It becomes the value of @code{last-input-event},
while @kbd{C-e} (we assume @kbd{C-x C-e} command is used to evaluate
this expression) remains the value of @code{last-command-event}.

@example
@group
(progn (print (read-char))
       (print last-command-event)
       last-input-event)
     @print{} 49
     @print{} 5
     @result{} 49
@end group
@end example
@end defvar

@defmac while-no-input body@dots{}
This construct runs the @var{body} forms and returns the value of the
last one---but only if no input arrives.  If any input arrives during
the execution of the @var{body} forms, it aborts them (working much
like a quit).  The @code{while-no-input} form returns @code{nil} if
aborted by a real quit, and returns @code{t} if aborted by arrival of
other input.

If a part of @var{body} binds @code{inhibit-quit} to non-@code{nil},
arrival of input during those parts won't cause an abort until
the end of that part.

If you want to be able to distinguish all possible values computed
by @var{body} from both kinds of abort conditions, write the code
like this:

@example
(while-no-input
  (list
    (progn . @var{body})))
@end example
@end defmac

@defvar while-no-input-ignore-events
This variable allow setting which special events @code{while-no-input}
should ignore.  It is a list of event symbols (@pxref{Event Examples}).

@end defvar

@defun discard-input
@cindex flushing input
@cindex discarding input
@cindex keyboard macro, terminating
This function discards the contents of the terminal input buffer and
cancels any keyboard macro that might be in the process of definition.
It returns @code{nil}.

In the following example, the user may type a number of characters right
after starting the evaluation of the form.  After the @code{sleep-for}
finishes sleeping, @code{discard-input} discards any characters typed
during the sleep.

@example
(progn (sleep-for 2)
       (discard-input))
     @result{} nil
@end example
@end defun

@node 特殊事件
@section Special Events

@cindex special events
Certain @dfn{special events} are handled at a very low level---as soon
as they are read.  The @code{read-event} function processes these
events itself, and never returns them.  Instead, it keeps waiting for
the first event that is not special and returns that one.

  Special events do not echo, they are never grouped into key
sequences, and they never appear in the value of
@code{last-command-event} or @code{(this-command-keys)}.  They do not
discard a numeric argument, they cannot be unread with
@code{unread-command-events}, they may not appear in a keyboard macro,
and they are not recorded in a keyboard macro while you are defining
one.

  Special events do, however, appear in @code{last-input-event}
immediately after they are read, and this is the way for the event's
definition to find the actual event.

  The events types @code{iconify-frame}, @code{make-frame-visible},
@code{delete-frame}, @code{drag-n-drop}, @code{language-change}, and
user signals like @code{sigusr1} are normally handled in this way.
The keymap which defines how to handle special events---and which
events are special---is in the variable @code{special-event-map}
(@pxref{Controlling Active Maps}).

@node 等待
@section Waiting for Elapsed Time or Input
@cindex waiting

  The wait functions are designed to wait for a certain amount of time
to pass or until there is input.  For example, you may wish to pause in
the middle of a computation to allow the user time to view the display.
@code{sit-for} pauses and updates the screen, and returns immediately if
input comes in, while @code{sleep-for} pauses without updating the
screen.

@defun sit-for seconds &optional nodisp
This function performs redisplay (provided there is no pending input
from the user), then waits @var{seconds} seconds, or until input is
available.  The usual purpose of @code{sit-for} is to give the user
time to read text that you display.  The value is @code{t} if
@code{sit-for} waited the full time with no input arriving
(@pxref{Event Input Misc}).  Otherwise, the value is @code{nil}.

The argument @var{seconds} need not be an integer.  If it is floating
point, @code{sit-for} waits for a fractional number of seconds.
Some systems support only a whole number of seconds; on these systems,
@var{seconds} is rounded down.

The expression @code{(sit-for 0)} is equivalent to @code{(redisplay)},
i.e., it requests a redisplay, without any delay, if there is no pending input.
@xref{Forcing Redisplay}.

If @var{nodisp} is non-@code{nil}, then @code{sit-for} does not
redisplay, but it still returns as soon as input is available (or when
the timeout elapses).

In batch mode (@pxref{Batch Mode}), @code{sit-for} cannot be
interrupted, even by input from the standard input descriptor.  It is
thus equivalent to @code{sleep-for}, which is described below.

It is also possible to call @code{sit-for} with three arguments,
as @code{(sit-for @var{seconds} @var{millisec} @var{nodisp})},
but that is considered obsolete.
@end defun

@defun sleep-for seconds &optional millisec
This function simply pauses for @var{seconds} seconds without updating
the display.  It pays no attention to available input.  It returns
@code{nil}.

The argument @var{seconds} need not be an integer.  If it is floating
point, @code{sleep-for} waits for a fractional number of seconds.
Some systems support only a whole number of seconds; on these systems,
@var{seconds} is rounded down.

The optional argument @var{millisec} specifies an additional waiting
period measured in milliseconds.  This adds to the period specified by
@var{seconds}.  If the system doesn't support waiting fractions of a
second, you get an error if you specify nonzero @var{millisec}.

Use @code{sleep-for} when you wish to guarantee a delay.
@end defun

  @xref{Time of Day}, for functions to get the current time.

@node 退出
@section Quitting
@cindex @kbd{C-g}
@cindex quitting
@cindex interrupt Lisp functions

  Typing @kbd{C-g} while a Lisp function is running causes Emacs to
@dfn{quit} whatever it is doing.  This means that control returns to the
innermost active command loop.

  Typing @kbd{C-g} while the command loop is waiting for keyboard input
does not cause a quit; it acts as an ordinary input character.  In the
simplest case, you cannot tell the difference, because @kbd{C-g}
normally runs the command @code{keyboard-quit}, whose effect is to quit.
However, when @kbd{C-g} follows a prefix key, they combine to form an
undefined key.  The effect is to cancel the prefix key as well as any
prefix argument.

  In the minibuffer, @kbd{C-g} has a different definition: it aborts out
of the minibuffer.  This means, in effect, that it exits the minibuffer
and then quits.  (Simply quitting would return to the command loop
@emph{within} the minibuffer.)  The reason why @kbd{C-g} does not quit
directly when the command reader is reading input is so that its meaning
can be redefined in the minibuffer in this way.  @kbd{C-g} following a
prefix key is not redefined in the minibuffer, and it has its normal
effect of canceling the prefix key and prefix argument.  This too
would not be possible if @kbd{C-g} always quit directly.

  When @kbd{C-g} does directly quit, it does so by setting the variable
@code{quit-flag} to @code{t}.  Emacs checks this variable at appropriate
times and quits if it is not @code{nil}.  Setting @code{quit-flag}
non-@code{nil} in any way thus causes a quit.

  At the level of C code, quitting cannot happen just anywhere; only at the
special places that check @code{quit-flag}.  The reason for this is
that quitting at other places might leave an inconsistency in Emacs's
internal state.  Because quitting is delayed until a safe place, quitting
cannot make Emacs crash.

  Certain functions such as @code{read-key-sequence} or
@code{read-quoted-char} prevent quitting entirely even though they wait
for input.  Instead of quitting, @kbd{C-g} serves as the requested
input.  In the case of @code{read-key-sequence}, this serves to bring
about the special behavior of @kbd{C-g} in the command loop.  In the
case of @code{read-quoted-char}, this is so that @kbd{C-q} can be used
to quote a @kbd{C-g}.

@cindex preventing quitting
  You can prevent quitting for a portion of a Lisp function by binding
the variable @code{inhibit-quit} to a non-@code{nil} value.  Then,
although @kbd{C-g} still sets @code{quit-flag} to @code{t} as usual, the
usual result of this---a quit---is prevented.  Eventually,
@code{inhibit-quit} will become @code{nil} again, such as when its
binding is unwound at the end of a @code{let} form.  At that time, if
@code{quit-flag} is still non-@code{nil}, the requested quit happens
immediately.  This behavior is ideal when you wish to make sure that
quitting does not happen within a critical section of the program.

@cindex @code{read-quoted-char} quitting
  In some functions (such as @code{read-quoted-char}), @kbd{C-g} is
handled in a special way that does not involve quitting.  This is done
by reading the input with @code{inhibit-quit} bound to @code{t}, and
setting @code{quit-flag} to @code{nil} before @code{inhibit-quit}
becomes @code{nil} again.  This excerpt from the definition of
@code{read-quoted-char} shows how this is done; it also shows that
normal quitting is permitted after the first character of input.

@example
(defun read-quoted-char (&optional prompt)
  "@dots{}@var{documentation}@dots{}"
  (let ((message-log-max nil) done (first t) (code 0) char)
    (while (not done)
      (let ((inhibit-quit first)
            @dots{})
        (and prompt (message "%s-" prompt))
        (setq char (read-event))
        (if inhibit-quit (setq quit-flag nil)))
      @r{@dots{}set the variable @code{code}@dots{}})
    code))
@end example

@defvar quit-flag
If this variable is non-@code{nil}, then Emacs quits immediately, unless
@code{inhibit-quit} is non-@code{nil}.  Typing @kbd{C-g} ordinarily sets
@code{quit-flag} non-@code{nil}, regardless of @code{inhibit-quit}.
@end defvar

@defvar inhibit-quit
This variable determines whether Emacs should quit when @code{quit-flag}
is set to a value other than @code{nil}.  If @code{inhibit-quit} is
non-@code{nil}, then @code{quit-flag} has no special effect.
@end defvar

@defmac with-local-quit body@dots{}
This macro executes @var{body} forms in sequence, but allows quitting, at
least locally, within @var{body} even if @code{inhibit-quit} was
non-@code{nil} outside this construct.  It returns the value of the
last form in @var{body}, unless exited by quitting, in which case
it returns @code{nil}.

If @code{inhibit-quit} is @code{nil} on entry to @code{with-local-quit},
it only executes the @var{body}, and setting @code{quit-flag} causes
a normal quit.  However, if @code{inhibit-quit} is non-@code{nil} so
that ordinary quitting is delayed, a non-@code{nil} @code{quit-flag}
triggers a special kind of local quit.  This ends the execution of
@var{body} and exits the @code{with-local-quit} body with
@code{quit-flag} still non-@code{nil}, so that another (ordinary) quit
will happen as soon as that is allowed.  If @code{quit-flag} is
already non-@code{nil} at the beginning of @var{body}, the local quit
happens immediately and the body doesn't execute at all.

This macro is mainly useful in functions that can be called from
timers, process filters, process sentinels, @code{pre-command-hook},
@code{post-command-hook}, and other places where @code{inhibit-quit} is
normally bound to @code{t}.
@end defmac

@deffn Command keyboard-quit
This function signals the @code{quit} condition with @code{(signal 'quit
nil)}.  This is the same thing that quitting does.  (See @code{signal}
in @ref{Errors}.)
@end deffn

  You can specify a character other than @kbd{C-g} to use for quitting.
See the function @code{set-input-mode} in @ref{Input Modes}.

@node 前缀命令参数
@section Prefix Command Arguments
@cindex prefix argument
@cindex raw prefix argument
@cindex numeric prefix argument

  Most Emacs commands can use a @dfn{prefix argument}, a number
specified before the command itself.  (Don't confuse prefix arguments
with prefix keys.)  The prefix argument is at all times represented by a
value, which may be @code{nil}, meaning there is currently no prefix
argument.  Each command may use the prefix argument or ignore it.

  There are two representations of the prefix argument: @dfn{raw} and
@dfn{numeric}.  The editor command loop uses the raw representation
internally, and so do the Lisp variables that store the information, but
commands can request either representation.

  Here are the possible values of a raw prefix argument:

@itemize @bullet
@item
@code{nil}, meaning there is no prefix argument.  Its numeric value is
1, but numerous commands make a distinction between @code{nil} and the
integer 1.

@item
An integer, which stands for itself.

@item
A list of one element, which is an integer.  This form of prefix
argument results from one or a succession of @kbd{C-u}s with no
digits.  The numeric value is the integer in the list, but some
commands make a distinction between such a list and an integer alone.

@item
The symbol @code{-}.  This indicates that @kbd{M--} or @kbd{C-u -} was
typed, without following digits.  The equivalent numeric value is
@minus{}1, but some commands make a distinction between the integer
@minus{}1 and the symbol @code{-}.
@end itemize

We illustrate these possibilities by calling the following function with
various prefixes:

@example
@group
(defun display-prefix (arg)
  "Display the value of the raw prefix arg."
  (interactive "P")
  (message "%s" arg))
@end group
@end example

@noindent
Here are the results of calling @code{display-prefix} with various
raw prefix arguments:

@example
        M-x display-prefix  @print{} nil

C-u     M-x display-prefix  @print{} (4)

C-u C-u M-x display-prefix  @print{} (16)

C-u 3   M-x display-prefix  @print{} 3

M-3     M-x display-prefix  @print{} 3      ; @r{(Same as @code{C-u 3}.)}

C-u -   M-x display-prefix  @print{} -

M--     M-x display-prefix  @print{} -      ; @r{(Same as @code{C-u -}.)}

C-u - 7 M-x display-prefix  @print{} -7

M-- 7   M-x display-prefix  @print{} -7     ; @r{(Same as @code{C-u -7}.)}
@end example

  Emacs uses two variables to store the prefix argument:
@code{prefix-arg} and @code{current-prefix-arg}.  Commands such as
@code{universal-argument} that set up prefix arguments for other
commands store them in @code{prefix-arg}.  In contrast,
@code{current-prefix-arg} conveys the prefix argument to the current
command, so setting it has no effect on the prefix arguments for future
commands.

  Normally, commands specify which representation to use for the prefix
argument, either numeric or raw, in the @code{interactive} specification.
(@xref{Using Interactive}.)  Alternatively, functions may look at the
value of the prefix argument directly in the variable
@code{current-prefix-arg}, but this is less clean.

@defun prefix-numeric-value arg
This function returns the numeric meaning of a valid raw prefix argument
value, @var{arg}.  The argument may be a symbol, a number, or a list.
If it is @code{nil}, the value 1 is returned; if it is @code{-}, the
value @minus{}1 is returned; if it is a number, that number is returned;
if it is a list, the @sc{car} of that list (which should be a number) is
returned.
@end defun

@defvar current-prefix-arg
This variable holds the raw prefix argument for the @emph{current}
command.  Commands may examine it directly, but the usual method for
accessing it is with @code{(interactive "P")}.
@end defvar

@defvar prefix-arg
The value of this variable is the raw prefix argument for the
@emph{next} editing command.  Commands such as @code{universal-argument}
that specify prefix arguments for the following command work by setting
this variable.
@end defvar

@defvar last-prefix-arg
The raw prefix argument value used by the previous command.
@end defvar

  The following commands exist to set up prefix arguments for the
following command.  Do not call them for any other reason.

@deffn Command universal-argument
This command reads input and specifies a prefix argument for the
following command.  Don't call this command yourself unless you know
what you are doing.
@end deffn

@deffn Command digit-argument arg
This command adds to the prefix argument for the following command.  The
argument @var{arg} is the raw prefix argument as it was before this
command; it is used to compute the updated prefix argument.  Don't call
this command yourself unless you know what you are doing.
@end deffn

@deffn Command negative-argument arg
This command adds to the numeric argument for the next command.  The
argument @var{arg} is the raw prefix argument as it was before this
command; its value is negated to form the new prefix argument.  Don't
call this command yourself unless you know what you are doing.
@end deffn

@node 递归编辑
@section Recursive Editing
@cindex recursive command loop
@cindex recursive editing level
@cindex command loop, recursive

  The Emacs command loop is entered automatically when Emacs starts up.
This top-level invocation of the command loop never exits; it keeps
running as long as Emacs does.  Lisp programs can also invoke the
command loop.  Since this makes more than one activation of the command
loop, we call it @dfn{recursive editing}.  A recursive editing level has
the effect of suspending whatever command invoked it and permitting the
user to do arbitrary editing before resuming that command.

  The commands available during recursive editing are the same ones
available in the top-level editing loop and defined in the keymaps.
Only a few special commands exit the recursive editing level; the others
return to the recursive editing level when they finish.  (The special
commands for exiting are always available, but they do nothing when
recursive editing is not in progress.)

  All command loops, including recursive ones, set up all-purpose error
handlers so that an error in a command run from the command loop will
not exit the loop.

@cindex minibuffer input
  Minibuffer input is a special kind of recursive editing.  It has a few
special wrinkles, such as enabling display of the minibuffer and the
minibuffer window, but fewer than you might suppose.  Certain keys
behave differently in the minibuffer, but that is only because of the
minibuffer's local map; if you switch windows, you get the usual Emacs
commands.

@cindex @code{throw} example
@kindex exit
@cindex exit recursive editing
@cindex aborting
  To invoke a recursive editing level, call the function
@code{recursive-edit}.  This function contains the command loop; it also
contains a call to @code{catch} with tag @code{exit}, which makes it
possible to exit the recursive editing level by throwing to @code{exit}
(@pxref{Catch and Throw}).  If you throw a value other than @code{t},
then @code{recursive-edit} returns normally to the function that called
it.  The command @kbd{C-M-c} (@code{exit-recursive-edit}) does this.
Throwing a @code{t} value causes @code{recursive-edit} to quit, so that
control returns to the command loop one level up.  This is called
@dfn{aborting}, and is done by @kbd{C-]} (@code{abort-recursive-edit}).

  Most applications should not use recursive editing, except as part of
using the minibuffer.  Usually it is more convenient for the user if you
change the major mode of the current buffer temporarily to a special
major mode, which should have a command to go back to the previous mode.
(The @kbd{e} command in Rmail uses this technique.)  Or, if you wish to
give the user different text to edit recursively, create and select
a new buffer in a special mode.  In this mode, define a command to
complete the processing and go back to the previous buffer.  (The
@kbd{m} command in Rmail does this.)

  Recursive edits are useful in debugging.  You can insert a call to
@code{debug} into a function definition as a sort of breakpoint, so that
you can look around when the function gets there.  @code{debug} invokes
a recursive edit but also provides the other features of the debugger.

  Recursive editing levels are also used when you type @kbd{C-r} in
@code{query-replace} or use @kbd{C-x q} (@code{kbd-macro-query}).

@deffn Command recursive-edit
@cindex suspend evaluation
This function invokes the editor command loop.  It is called
automatically by the initialization of Emacs, to let the user begin
editing.  When called from a Lisp program, it enters a recursive editing
level.

If the current buffer is not the same as the selected window's buffer,
@code{recursive-edit} saves and restores the current buffer.  Otherwise,
if you switch buffers, the buffer you switched to is current after
@code{recursive-edit} returns.

In the following example, the function @code{simple-rec} first
advances point one word, then enters a recursive edit, printing out a
message in the echo area.  The user can then do any editing desired, and
then type @kbd{C-M-c} to exit and continue executing @code{simple-rec}.

@example
(defun simple-rec ()
  (forward-word 1)
  (message "Recursive edit in progress")
  (recursive-edit)
  (forward-word 1))
     @result{} simple-rec
(simple-rec)
     @result{} nil
@end example
@end deffn

@deffn Command exit-recursive-edit
This function exits from the innermost recursive edit (including
minibuffer input).  Its definition is effectively @code{(throw 'exit
nil)}.
@end deffn

@deffn Command abort-recursive-edit
This function aborts the command that requested the innermost recursive
edit (including minibuffer input), by signaling @code{quit}
after exiting the recursive edit.  Its definition is effectively
@code{(throw 'exit t)}.  @xref{Quitting}.
@end deffn

@deffn Command top-level
This function exits all recursive editing levels; it does not return a
value, as it jumps completely out of any computation directly back to
the main command loop.
@end deffn

@defun recursion-depth
This function returns the current depth of recursive edits.  When no
recursive edit is active, it returns 0.
@end defun

@node 禁用命令
@section Disabling Commands
@cindex disabled command

  @dfn{Disabling a command} marks the command as requiring user
confirmation before it can be executed.  Disabling is used for commands
which might be confusing to beginning users, to prevent them from using
the commands by accident.

@kindex disabled
  The low-level mechanism for disabling a command is to put a
non-@code{nil} @code{disabled} property on the Lisp symbol for the
command.  These properties are normally set up by the user's
init file (@pxref{Init File}) with Lisp expressions such as this:

@example
(put 'upcase-region 'disabled t)
@end example

@noindent
For a few commands, these properties are present by default (you can
remove them in your init file if you wish).

  If the value of the @code{disabled} property is a string, the message
saying the command is disabled includes that string.  For example:

@example
(put 'delete-region 'disabled
     "Text deleted this way cannot be yanked back!\n")
@end example

  @xref{Disabling,,, emacs, The GNU Emacs Manual}, for the details on
what happens when a disabled command is invoked interactively.
Disabling a command has no effect on calling it as a function from Lisp
programs.

@deffn Command enable-command command
Allow @var{command} (a symbol) to be executed without special
confirmation from now on, and alter the user's init file (@pxref{Init
File}) so that this will apply to future sessions.
@end deffn

@deffn Command disable-command command
Require special confirmation to execute @var{command} from now on, and
alter the user's init file so that this will apply to future sessions.
@end deffn

@defvar disabled-command-function
The value of this variable should be a function.  When the user
invokes a disabled command interactively, this function is called
instead of the disabled command.  It can use @code{this-command-keys}
to determine what the user typed to run the command, and thus find the
command itself.

The value may also be @code{nil}.  Then all commands work normally,
even disabled ones.

By default, the value is a function that asks the user whether to
proceed.
@end defvar

@node 命令历史
@section Command History
@cindex command history
@cindex complex command
@cindex history of commands

  The command loop keeps a history of the complex commands that have
been executed, to make it convenient to repeat these commands.  A
@dfn{complex command} is one for which the interactive argument reading
uses the minibuffer.  This includes any @kbd{M-x} command, any
@kbd{M-:} command, and any command whose @code{interactive}
specification reads an argument from the minibuffer.  Explicit use of
the minibuffer during the execution of the command itself does not cause
the command to be considered complex.

@defvar command-history
This variable's value is a list of recent complex commands, each
represented as a form to evaluate.  It continues to accumulate all
complex commands for the duration of the editing session, but when it
reaches the maximum size (@pxref{Minibuffer History}), the oldest
elements are deleted as new ones are added.

@example
@group
command-history
@result{} ((switch-to-buffer "chistory.texi")
    (describe-key "^X^[")
    (visit-tags-table "~/emacs/src/")
    (find-tag "repeat-complex-command"))
@end group
@end example
@end defvar

  This history list is actually a special case of minibuffer history
(@pxref{Minibuffer History}), with one special twist: the elements are
expressions rather than strings.

  There are a number of commands devoted to the editing and recall of
previous commands.  The commands @code{repeat-complex-command}, and
@code{list-command-history} are described in the user manual
(@pxref{Repetition,,, emacs, The GNU Emacs Manual}).  Within the
minibuffer, the usual minibuffer history commands are available.

@node 键盘宏
@section Keyboard Macros
@cindex keyboard macros

  A @dfn{keyboard macro} is a canned sequence of input events that can
be considered a command and made the definition of a key.  The Lisp
representation of a keyboard macro is a string or vector containing the
events.  Don't confuse keyboard macros with Lisp macros
(@pxref{Macros}).

@defun execute-kbd-macro kbdmacro &optional count loopfunc
This function executes @var{kbdmacro} as a sequence of events.  If
@var{kbdmacro} is a string or vector, then the events in it are executed
exactly as if they had been input by the user.  The sequence is
@emph{not} expected to be a single key sequence; normally a keyboard
macro definition consists of several key sequences concatenated.

If @var{kbdmacro} is a symbol, then its function definition is used in
place of @var{kbdmacro}.  If that is another symbol, this process repeats.
Eventually the result should be a string or vector.  If the result is
not a symbol, string, or vector, an error is signaled.

The argument @var{count} is a repeat count; @var{kbdmacro} is executed that
many times.  If @var{count} is omitted or @code{nil}, @var{kbdmacro} is
executed once.  If it is 0, @var{kbdmacro} is executed over and over until it
encounters an error or a failing search.

If @var{loopfunc} is non-@code{nil}, it is a function that is called,
without arguments, prior to each iteration of the macro.  If
@var{loopfunc} returns @code{nil}, then this stops execution of the macro.

@xref{Reading One Event}, for an example of using @code{execute-kbd-macro}.
@end defun

@defvar executing-kbd-macro
This variable contains the string or vector that defines the keyboard
macro that is currently executing.  It is @code{nil} if no macro is
currently executing.  A command can test this variable so as to behave
differently when run from an executing macro.  Do not set this variable
yourself.
@end defvar

@defvar defining-kbd-macro
This variable is non-@code{nil} if and only if a keyboard macro is
being defined.  A command can test this variable so as to behave
differently while a macro is being defined.  The value is
@code{append} while appending to the definition of an existing macro.
The commands @code{start-kbd-macro}, @code{kmacro-start-macro} and
@code{end-kbd-macro} set this variable---do not set it yourself.

The variable is always local to the current terminal and cannot be
buffer-local.  @xref{Multiple Terminals}.
@end defvar

@defvar last-kbd-macro
This variable is the definition of the most recently defined keyboard
macro.  Its value is a string or vector, or @code{nil}.

The variable is always local to the current terminal and cannot be
buffer-local.  @xref{Multiple Terminals}.
@end defvar

@defvar kbd-macro-termination-hook
This normal hook is run when a keyboard macro terminates, regardless
of what caused it to terminate (reaching the macro end or an error
which ended the macro prematurely).
@end defvar
