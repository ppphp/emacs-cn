@c -*- mode: texinfo; coding: utf-8 -*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990--1995, 1998--2020 Free Software Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node 显示
@chapter Emacs Display

  本章介绍了一些与Emacs呈现给用户的显示相关的功能。

@menu
* 刷新屏幕::     清理屏幕并重新绘制屏幕上的所有内容。
* 强制重显::     强制重显
* 截断::         折叠或包裹长文本行。
* 回音区::       在屏幕底部显示信息。
* 警告::         显示用户的警告信息。
* 隐形文本::     隐藏部分缓冲区文本。
* 选择性显示::   隐藏部分缓冲区文字（老方法）。
* 临时显示::     自动消失的显示。
* 叠加::         使用叠加来突出显示缓冲区的部分内容。
* 显示文字的大小::显示的文字的大小。 显示文字的大小。
* 行高::        控制行的高度。
* 字形::        一个字型定义了文本字符的图形样式，包括字体、颜色等。
* 边缘::        控制窗口边缘。
* 滚动条::      控制滚动条。
* 窗口分隔线::  控制窗口的分割。
* 显示属性::    控制图像、边距、文字大小等。
* 图像::        在Emacs缓冲区中显示图像。
* Xwidgets::    在Emacs缓冲区中显示本地部件。
* 按钮::        在Emacs缓冲区中添加可点击的按钮。
* 抽象显示::    Emacs的对象集合小部件。
* 闪烁::        Emacs如何显示匹配的开放括号。
* 字符显示::    Emacs显示单个字符的方式。
* 哔哔声::     给用户的声音信号。
* 窗口系统::   正在使用的窗口系统。
* 工具提示::   Emacs中的工具提示显示。
* 双向显示::   显示双向文本，如阿拉伯语和波斯语。
@end menu

@node 刷新屏幕
@section Refreshing the Screen
@cindex refresh the screen
@cindex screen refresh

  函数@code{redraw-frame}清除并重新显示给定窗帧（@pxref{Frames}）的全部
内容。这在屏幕有错误时非常有用。

@defun redraw-frame &optional frame
此函数清除并重新显示@var{frame}帧。如果@var{frame}被省略或者@code{nil}被
忽略，则重新显示当前所选的帧。
@end defun

  更强大的是@code{redraw-display}。

@deffn Command redraw-display
这个函数清除并重新显示所有可见的帧。
@end deffn

  在Emacs中，处理用户输入比重新显示优先。如果你在有输入时调用这些函数，它
们不会立即重新显示，但要求的重新显示最终会发生--在所有输入被处理后。

  在文本终端上，暂停和恢复Emacs通常也会刷新屏幕。一些终端仿真器为Emacs等
以显示为主的程序和普通的顺序显示的程序分别记录内容。如果你使用的是这样的终
端，你可能会想抑制恢复时的重新显示。

@defopt no-redraw-on-reenter
@cindex suspend (cf. @code{no-redraw-on-reenter})
@cindex resume (cf. @code{no-redraw-on-reenter})
这个变量控制Emacs暂停和恢复后是否重绘整个屏幕。非@code{nil}表示不需要重绘
，@code{nil}表示需要重绘。 默认为@code{nil}。
@end defopt

@node 强制重显
@section Forcing Redisplay
@cindex forcing redisplay

  Emacs正常情况会在等待输入时尝试重新显示屏幕。使用下面的函数，你可以在
Lisp代码中间请求立即尝试重新显示屏幕，而不需要等待输入。

@defun redisplay &optional force
这个函数会立即尝试重新显示。可选参数@var{force}如果是非@code{nil}，则强
制执行重新显示，而不是在输入待定的情况下被抢占。

如果函数确实重新显示，则返回@code{t}，否则返回@code{nil}。@code{t}的值并
不意味着重新显示已经完成；它可能已经被新到达的输入所取代。
@end defun

  虽然@code{redisplay}会立即尝试重新显示，但它并没有改变Emacs决定重新显
示框架中哪些部分的方式。对比之下，下面的函数将某些窗口加入到等待重新显示的
工作中（就像它们的内容已经完全改变了一样），但并没有立即尝试执行重新显示。

@defun force-window-update &optional object
这个函数强制在下次Emacs进行重新显示时更新部分或全部窗口。如果@var{object}
是一个窗口，那么该窗口将被更新。如果@var{object}是一个缓冲区或缓冲区名称
，那么所有显示该缓冲区的窗口都将被更新。如果@var{object}是@code{nil}。(
或省略)，所有的窗口都将被更新。

这个函数不会立即进行重新显示；Emacs会在等待输入时或调用函数
@code{redisplay}时进行重新显示。
@end defun

@defvar pre-redisplay-function
在重新显示之前运行的一个函数。调用该函数时有一个参数，即要重新显示的窗口集
。这个集合可以是@code{nil},表示只显示当前选定的窗口，也可以是@code{t},表
示所有的窗口。
@end defvar

@defvar pre-redisplay-functions
这个钩子是在重新显示之前运行的。它在每个即将被重新显示的窗口中被调用一次，
@code{current-buffer}设置为该窗口中显示的缓冲区。
@end defvar

@node 截断
@section Truncation
@cindex line wrapping
@cindex line truncation
@cindex continuation lines
@cindex @samp{$} in display
@cindex @samp{\} in display

  当一行文本延伸到窗口的右边缘之外时，Emacs可以@dfn{continue}行（使它包到
下一个屏幕行），或者@dfn{truncate}行（将它限制在一个屏幕行）。用于显示长文
本行的额外屏幕行称为@dfn{continuation}行。延续与填充不同。续行只发生在屏幕
上，而不是在缓冲区的内容中，而且它是在右边的空白处断行，而不是在字的边界处
。@xref{Filling}。

  在图形显示器上，窗口边缘的微小箭头图像表示截断和延续的行数(
@pxref{边缘})。在文本终端上，窗口最右边一列的@samp{$}表示截断；最右边
一列的@samp{\}表示绕行。(显示表可以指定替代字符来使用；@pxref{显示表})。

@defopt truncate-lines
如果这个缓冲区本地变量是非@code{nil}，那么超出窗口右边缘的行将被截断；否则
，它们将被继续。作为一个特殊的例外，@code{truncat-partial-width-windows}
变量优先于@dfn{partial-width}窗口（即不占用整个窗帧宽度的窗口）。
@end defopt

@defopt truncate-partial-width-windows
@cindex partial-width windows
这个变量控制@dfn{partial-width}窗口的截行。局部宽度窗口是指不占用整个窗帧
宽度的窗口(@pxref{分割窗口})。如果值是@code{nil}，则截断行数由
@code{truncat-lines}变量决定。(见上文)。如果值是一个整数@var{n}，如果部分
宽度窗口的列数少于@var{n}，则无论@code{truncat-lines}的值如何，都会对行进
行截断；如果部分宽度窗口有@var{n}或更多的列数，则行的截断由
@code{truncat-lines}决定。对于其他任何非@code{nil}的值，无论
@code{truncat-lines}的值是多少，每个局部宽度窗口的行都会被截断。
@end defopt

  当在窗口中使用水平滚动（@pxref{水平滚动}）时，会强制截断。

@defvar wrap-prefix
如果这个缓冲区本地变量是非@code{nil}，它就会定义一个@dfn{wrap prefix}，
Emacs会在每一个延续行的开头显示这个变量。(如果行被截断，则不会使用
@code{wrap-prefix}。)它的值可以是一个字符串或图像 (
@pxref{其他显示规格})，或者是一段空白空间，如@code{:width}或
@code{:align-to}显示属性(@pxref{指定空白})所指定的。该值的解释方式与
@code{display}文本属性相同。@xref{显示属性}。

也可以使用@code{wrap-prefix}文本或覆盖属性，为文本区域指定一个包覆前缀。
这优先于@code{wrap-prefix}变量。@xref{Special Properties}。
@end defvar

@defvar line-prefix
如果这个缓冲区本地变量是非@code{nil}，它定义了一个
@dfn{line prefix}，Emacs会在每一个非延续行开头显示。它的值可以是字符串
或图像(@pxref{其他显示规格})，也可以是一段空白，如@code{:width}
或@code{:align-to}显示属性(@pxref{指定空白})所指定。该值的解释
方式与@code{display}文本属性相同。@xref{显示属性}。
也可以使用@code{line-prefix}文本或覆盖属性为文本区域指定行前缀。这优先于
在@code{line-prefix}变量。@xref{Special Properties}。
@end defvar

@ignore
  如果您的缓冲区只包含很短的行，您可能会发现最好将@code{cache-long-scans}
设置为@code{nil}。

@defvar cache-long-scans
如果该变量是非@code{nil}(默认)，则各种缩进和运动功能，以及Emacs重新显示，
都会缓存扫描缓冲区的结果，并查阅缓存，以避免重新扫描缓冲区的区域，除非它们
被修改。

关闭缓存会在一定程度上加快短行的处理速度。

这个变量在每个缓冲区中都是自动的缓冲区局部。
@end defvar
@end ignore

@node 回音区
@section The Echo Area
@cindex error display
@cindex echo area

@c FIXME: 为什么不直接用@xref{Minibuffers}?  --xfq
  @dfn{echo area}用于显示错误信息(@pxref{Errors})，用于显示用
@code{message}基元编写的信息，以及用于回声击键。它与迷你缓冲区不同，尽管迷
你缓冲区（在激活时）与回声区在屏幕上的位置相同。 @xref{Minibuffer,, The Minibuffer, emacs, The GNU Emacs Manual}.

除了本节中提到的功能外，您还可以通过指定@code{t}作为输出流，将 Lisp
对象打印到回声区。@xref{Output Streams}。

@menu
* 显示信息::    在回音区明确显示文字。
* 进度::        告知用户长时间操作的进度。
* 记录信息::    回音区信息为用户记录。
* 回音区自定义:: 控制回音区。
@end menu

@node 显示信息
@subsection Displaying Messages in the Echo Area
@cindex display message in echo area

  本节介绍在回音区显示信息的标准功能。

@defun message format-string &rest arguments
这个函数在回声区显示一条信息。@var{format-string}是一个格式字符串，
@var{arguments}是参数对象它的格式规范，就像@code{format-message}函数 (
@pxref{Formatting Strings})一样。由此产生的格式化字符串会显示在回声区；如
果它包含@code{face}文本属性，则会以指定的字体显示(@pxref{Faces})。该字符
串也会被添加到@file{*Messages*}缓冲区中，但不包含文本属性（
@pxref{Logging Messages}）。

通常，格式中的重音和撇号会转化为匹配的弯引号，例如，
@t{"Missing `%s'"}可能会导致@t{"Missing ‘foo’"}。
@xref{Text Quoting Style}，了解如何影响或抑制该翻译。

在批处理模式下，消息会被打印到标准的错误流中，后面是一个新行。

当@code{inhibit-message}是非@code{nil}时，回音区不会显示任何消息，只会记
录到@samp{*Messages*}。

如果@var{format-string}为@code{nil}或空字符串，则@code{message}会清除回
音区；如果回音区已自动展开，这将使其恢复到正常大小。如果minibuffer处于活动
状态，则会立即将minibuffer的内容恢复到屏幕上。

@example
@group
(message "Reverting `%s'..." (buffer-name))
 @print{} Reverting ‘subr.el’...
@result{} "Reverting ‘subr.el’..."
@end group

@group
---------- Echo Area ----------
Reverting ‘subr.el’...
---------- Echo Area ----------
@end group
@end example

要在回声区或弹出式缓冲区中按照大小自动显示信息，请使用
@code{display-message-or-buffer}（见下文）。

@strong{Warning:}如果您想使用您自己的字符串作为消息，请使用
@code{display-messag-or-buffer}（见下文）。逐字逐句，不要只写
@code{(message @var{string})}。如果@var{string}包含@samp{%}, @samp{`},
或@samp{'},则可能是重新格式化，结果不理想。相反，使用
@code{(message "%s" @var{string})}。
@end defun

@defvar set-message-function
如果这个变量是非@code{nil}，那么它应该是一个参数的函数，即在回音区显示的信
息文本。这个函数将被@code{message}和相关函数调用。如果函数返回@code{nil}
，则消息会像往常一样显示在回音区。如果该函数返回一个字符串，则该字符串将代
替原来的字符串显示在回音区。如果这个函数返回其他非@code{nil}的值，意味着消
息已经被处理了，所以@code{message}不会在回音区显示任何内容。也请参见
@code{clear-messag-function}，它可以用来清除该函数所显示的消息。

默认值是当minibuffer处于活动状态时，在minibuffer末端显示消息的函数。但是
，如果活动的迷你缓冲区中显示的文本在某个字符上具有
@code{minibuffer-message}文本属性(
@pxref{Special Properties})，则消息将显示在具有该属性的第一个字符之前。
@end defvar

@defvar clear-message-function
如果这个变量是非@code{nil}，那么当@code{message}和相关函数的参数信息为
@code{nil}或空字符串时，就会调用这个没有参数的函数。

通常这个函数在显示回音区消息后的下一个输入事件到来时被调用。该函数将清除由
@code{set-messag-function}指定的对应函数所显示的消息。

默认值是清除活动迷你缓冲区中显示的消息的函数。
@end defvar

@defvar inhibit-message
当这个变量是非@code{nil}时，@code{message}和相关函数将不会使用回音区来显
示消息。
@end defvar

@defmac with-temp-message message &rest body
在执行@var{body}的过程中，这个构造暂时在回声区显示一条消息。它显示
@var{message}，执行@var{body}，然后返回最后一个body表单的值，同时恢复之前
的回音区内容。
@end defmac

@defun message-or-box format-string &rest arguments
这个函数像@code{message}一样显示一条消息，但可能会在对话框中显示，而不是在
回音区显示。如果这个函数在使用鼠标调用的命令中被调用---更准确地说，如果
@code{last-nonmenu-event}(@pxref{命令循环信息})是@code{nil}或列表---使用对
话框或弹出菜单来显示消息。否则它使用回声区。(这与@code{y-or-n-p}用于做出类似决定的
标准相同；参见@ref{Yes-or-No Queries})。

您可以通过在调用附近将@code{last-nonmenu-event}绑定一个合适的值来强制使用
鼠标或回声区。
@end defun

@defun message-box format-string &rest arguments
@anchor{message-box}
这个函数显示的消息与@code{message}类似，但只要可能，就使用对话框（或弹出式
菜单）。如果因为终端不支持对话框或弹出式菜单而无法使用，那么
@code{message-box}就可以使用回音区，比如@code{message}。
@end defun

@defun display-message-or-buffer message &optional buffer-name action frame
该函数显示消息@var{message}，它可以是一个字符串或缓冲区。如果它比
@code{max-mini-window-height}定义的回声区的最大高度要短，则使用
@code{message}在回声区显示。否则，使用@code{display-buffer}将其显示在弹出
的缓冲区中。

返回在回声区显示的字符串，或者当使用弹出式缓冲区时，返回用于显示该字符串的
窗口。

如果@var{message}是一个字符串，那么可选的参数@var{buffer-name}是用于显示
它的缓冲区的名称，当一个使用弹出式缓冲区，默认为@file{*Message*}。在
@var{message}是字符串并显示在回音区的情况下，都不指定是否将内容插入缓冲区
。

可选参数@var{action}和@var{frame}与@code{display-buffer}一样，仅在显示缓
冲区时使用。
@end defun

@defun current-message
该函数返回当前显示在回音区的信息，如果没有，则返回@code{nil}。
@end defun

@node 进度
@subsection Reporting Operation Progress
@cindex progress reporting

  当一个操作可能需要一段时间才能完成时，你应该告知用户它的进度。这样用户就
可以估计剩余的时间，并清楚地看到Emacs正在忙碌地工作，而不是挂起。一个方便
的方法是使用@dfn{progress reporter}。

  下面是一个没有任何用处的使用例子:

@smallexample
(let ((progress-reporter
       (make-progress-reporter "Collecting mana for Emacs..."
                               0  500)))
  (dotimes (k 500)
    (sit-for 0.01)
    (progress-reporter-update progress-reporter k))
  (progress-reporter-done progress-reporter))
@end smallexample

@defun make-progress-reporter message &optional min-value max-value current-value min-change min-time
这个函数创建并返回一个进度报告对象，你将使用它作为下面列出的其他函数的参数
。想法是尽可能多地预计算数据，使进度报告的速度非常快。

当随后使用这个进度报告器时，它将在回声区显示@var{message}，然后是进度百分
比。@var{message}被视为一个简单的字符串。如果您需要它依赖于一个文件名，例
如，在调用这个函数之前使用@code{format-message}。

参数@var{min-value}和@var{max-value}应该是代表操作的起始和最终状态的数字
。例如，一个扫描缓冲区的操作应该相应地设置为@code{point-min}和
@code{point-max}的结果。@var{max-value}应该大于@var{min-value}。

或者，您可以将@var{min-value}和@var{max-value}设置为@code{nil}。在这种情
况下，进度报告器不会报告进程百分比，而是在每次更新进度报告器时显示一个"旋转
器"，这个旋转器会旋转一个缺口。

如果@var{min-value}和@var{max-value}是数字，可以给参数
@var{current-value}一个数值，指定初始进度；如果省略，默认为
@var{min-value}。

其余参数控制回音区的更新速度。进度报告器将至少等待@var{min-change}更多百分
比的操作完成后才打印下一条信息，默认为1%。@var{min-time}指定了连续打印之间
的最小时间（以秒为单位），默认为0.2秒。在某些操作系统上，进度报告器可能会以
不同的精度来处理秒的分数）。

这个函数调用@code{progress-reporter-update}，所以第一条消息会立即打印出来
。
@end defun

@defun progress-reporter-update reporter &optional value suffix
这个函数主要负责报告操作的进度。它显示@var{reporter}的消息，然后是由
@var{value}确定的进度百分比。如果百分比为零，或者根据@var{min-change}和
@var{min-time}参数足够接近，那么它将从输出中省略。

@var{reporter}必须是调用@code{make-progress-reporter}的结果。@var{value}
指定了您的操作的当前状态，并且必须介于传递给@code{make-progress-reporter}
的@var{min-value}和@var{max-value}之间（含）。例如，如果您扫描了一个缓冲
区，那么@var{value}应该是调用@code{point}的结果。

可选参数@var{suffix}是一个字符串，用于显示在@var{reporter}的主信息和进度
文本之后。如果@var{reporter}是一个非数字报告器，那么@var{value}应该是
@code{nil}，或者是一个字符串来代替@var{suffix}。

这个函数关心会查看传递给@code{make-progress-reporter}的@var{min-change}
和@var{min-time}，因此不会在每次调用时输出新的消息。因此，它的速度非常快，
通常情况下，您不应该试图减少对它的调用次数：由此产生的开销很可能会抵消您的
努力。
@end defun

@defun progress-reporter-force-update reporter &optional value new-message suffix
这个函数类似于@code{progress-reporter-update}，只是它无条件地在echo区域打
印一条消息。

@var{reporter},@var{value},和@var{suffix}与
@code{progress-reporter-update}的含义相同。可选的@var{new-message}允许您
更改@var{reporter}的消息。因为这个函数总是更新回声区，所以这样的改变会立即
呈现给用户。
@end defun

@defun progress-reporter-done reporter
这个函数应该在操作完成后被调用。它在回声区打印@var{reporter}的信息，后面跟
着@samp{done}字样。

您应该始终调用这个函数，而不是希望@code{progress-reporter-update}打印
@samp{100%}。首先，它可能永远也不会打印出来，有很多充分的理由让它不发生。
其次，@samp{done}更明确。
@end defun

@defmac dotimes-with-progress-reporter (var count [result]) reporter-or-message body@dots{}
这是一个方便的宏，它的工作方式与@code{dotimes}的工作方式相同，但也使用上面
描述的函数报告循环进度。它允许您节省一些打字工作。参数
@var{reporter-or-message}可以是一个字符串或一个进度报告对象。

你可以使用这个宏重写本小节开头的例子，如下所示：
@example
@group
(dotimes-with-progress-reporter
    (k 500)
    "Collecting some mana for Emacs..."
  (sit-for 0.01))
@end group
@end example

如果您想在@var{make-progress-reporter}中指定可选的参数，那么使用报告器对
象作为@var{reporter-or-message}参数是很有用的。例如，你可以把前面的例子写
成如下：

@example
@group
(dotimes-with-progress-reporter
    (k 500)
    (make-progress-reporter "Collecting some mana for Emacs..." 0 500 0 1 1.5)
  (sit-for 0.01))
@end group
@end example
@end defmac

@defmac dolist-with-progress-reporter (var count [result]) reporter-or-message body@dots{}
这是另一个方便的宏，它的工作方式与@code{dolist}相同，但也使用上面描述的函
数报告循环进度。和@code{dotimes-with-progress-reporter}一样，
@code{reporter-or-message}可以是一个进度报告，也可以是一个字符串。你可以
用这个宏重写前面的例子，如下:

@example
@group
(dolist-with-progress-reporter
    (k (number-sequence 0 500))
    "Collecting some mana for Emacs..."
  (sit-for 0.01))
@end group
@end example
@end defmac

@node 记录信息
@subsection Logging Messages in @file{*Messages*}
@cindex logging echo-area messages

  几乎所有显示在回音区的消息都被记录在@file{*Messages*}缓冲区中，以便用户
可以回溯这些消息。这包括所有用@code{message}输出的消息。默认情况下，这个缓
冲区是只读的，并使用主要模式@code{messages-buffer-mode}。没有什么可以阻止
用户杀死@file{*Messages*}缓冲区，但下一次显示消息时会重新创建它。任何需要
直接访问@file{*Messages*}缓冲区的Lisp代码，并希望确保它的存在，应该使用函
数@code{messages-buffer}。

@defun messages-buffer
该函数返回@file{*Messages*}缓冲区。如果它不存在，则创建它，并将其切换到
@code{messages-buffer-mode}。
@end defun

@defopt message-log-max
这个变量用于指定在@file{*Messages*}缓冲区中保留多少行。值@code{t}表示对保
留的行数没有限制。值@code{nil}表示完全禁用消息记录。下面是如何显示消息并防
止其被记录的方法：

@example
(let (message-log-max)
  (message @dots{}))
@end example
@end defopt

  为了让用户更方便地使用@file{*Messages*}，日志记录功能将连续的相同消息合
并起来。此外，它还将连续的相关消息结合起来，以便于两种情况：先问后答和一系
列的进度消息。

  一个问题和之后一个答案有两条消息，就像@code{y-or-n-p}产生的消息一样：第
一条是@samp{@var{question}}，第二条是
@samp{@var{question}...@var{answer}}。第一条消息没有传递除第二条消息以外
的额外信息，所以记录第二条消息时，会将第一条消息从日志中删除。

一系列的进度消息有连续的消息，就像@code{make-progress-reporter}产生的消息
一样。它们的形式是@samp{@var{base}...@var{how-far}}，其中@var{base}每一
个时间都是一样的，而@var{how-far}则不同。只要是连续的消息，就会丢弃前一条
消息。

函数@code{make-progress-reporter}和@code{y-or-n-p}不需要做任何特别的事情
就可以激活消息日志组合功能。只要有两个连续的消息被记录下来，并且共享一个以
@samp{...} 结尾的共同前缀，它就会发挥作用。

@node 回音区自定义
@subsection Echo Area Customization
@cindex echo area customization

  这些变量控制了回音区工作的细节。

@defvar cursor-in-echo-area
这个变量控制了在回音区显示消息时光标的位置，如果它是非@code{nil}，那么光标
就会出现在消息的最后。如果它是非@code{nil}，那么光标就会出现在消息的最后。
否则，光标就会出现在点上------根本不在回音区。

该值通常是@code{nil}；Lisp程序在短时间内将其绑定到@code{t}。
@end defvar

@defvar echo-area-clear-hook
每当回声区被清除时，这个正常的钩子就会被运行--无论是通过
@code{(message nil)}还是任何其他原因。
@end defvar

@defopt echo-keystrokes
这个变量决定了命令字符回声前应该经过多少时间。它的值必须是一个数字，并指定
在回声之前要等待的秒数。如果用户输入了一个前缀键（如@kbd{C-x}），然后在继
续之前延迟了这么多秒，那么前缀键就会在回声区域中回声。（一旦在一个键序中开
始回声，同一键序中的所有后续字符都会立即回声）。

如果该值为零，则命令输入不被回声。
@end defopt

@defvar message-truncate-lines
通常情况下，显示一条长消息时，会调整回音区的大小以显示整条消息。但如果变量
@code{message-truncat-lines}是非@code{nil}，则回音区不会调整大小，而是将
消息截断以适应它。
@end defvar

  变量@code{max-mini-window-height}，指定了调整minibuffer窗口大小的最大
高度，也适用于回音区（其实就是minibuffer窗口的一种特殊用途；
@pxref{Minibuffer Windows}）。

@node 警告
@section Reporting Warnings
@cindex warnings

  @dfn{Warnings}是程序通知用户可能出现的问题，但继续运行的设施。

@menu
* 警告基础::     警告的概念和报告它们的功能。
* 警告变量::     程序绑定的变量，用于自定义警告。
* 警告选项::     用户设置变量来控制警告的显示。
* 延迟警告::     将警告延迟到命令结束。
@end menu

@node 警告基础
@subsection Warning Basics
@cindex severity level

  每一个警告都有一个文本信息，为用户解释问题，还有一个
@dfn{severity level}，这是一个符号。下面是可能的严重性级别，按严重性递减的
顺序排列，以及它们的含义：

@table @code
@item :emergency
如果不及时处理，很快就会严重影响Emacs的运行。
@item :error
报告的数据或情况本身就是错误的。
@item :warning
报告的数据或情况本身没有问题，但会引起对可能问题的怀疑。
@item :debug
如果你在调试时，可能有用的信息报告。
@end table

  当你的程序遇到无效的输入数据时，它可以通过调用@code{error}或
@code{signal}来发出Lisp错误信号，或者报告一个严重程度为@code{:error}的警
告。发出Lisp错误信号是最简单的事情，但这意味着程序不能继续处理。如果你想费
尽心思地实现一种在数据不好的情况下仍能继续处理的方法，那么报告一个严重程度
为@code{:error}的警告是告知用户问题的正确方法。例如，Emacs
Lisp字节编译器就可以这样报告错误，并继续编译其他函数。(如果程序发出Lisp错
误信号，然后用@code{condition-case}处理，用户不会看到错误信息，它可以通过
报告为警告的方式向用户显示该信息。)

@c FIXME：为什么用"(bytecomp)"而不是"'bytecomp'"，或者干脆在这里用
@c "bytecomp"？括号是警告型格式的一部分，但是不属于警告类型。--xfq
@cindex warning type
  每个警告都有一个@dfn{warning type}来对其进行分类。这个类型是一个符号列
表。第一个符号应该是你用于程序用户选项的自定义组。例如，字节编译器警告使用
警告类型@code{(bytecomp)}。如果你愿意，你也可以通过在列表中使用更多的符号
对警告进行子分类。

@defun display-warning type message &optional level buffer-name
这个函数报告一个警告，使用@var{message}作为消息，@var{type}作为警告类型。
@var{level}为严重程度，默认为@code{:warning}。

@var{buffer-name}，如果非@code{nil}，则指定用于记录警告的缓冲区的名称。默
认情况下，是@file{*Warnings*}。
@end defun

@defun lwarn type level message &rest args
这个函数使用@code{(format-message @var{message} @var{args}...)}的值作为
@file{*Warnings*}缓冲区中的消息来报告一个警告。在其他方面，它相当于
@code{display-warning}。
@end defun

@defun warn message &rest args
这个函数使用@code{(format-message @var{message} @var{args}...)}的值作为
消息，@code{(emacs)}作为类型，@code{:warning}作为严重程度来报告一个警告。
它的存在只是为了兼容性，我们建议不要使用它，因为你应该指定一个特定的警告类
型。
@end defun

@node 警告变量
@subsection Warning Variables
@cindex warning variables

  程序可以通过绑定本节中描述的变量来自定义警告的显示方式。

@defvar warning-levels
该列表定义了警告严重程度级别的含义和严重程度顺序。每个元素定义一个严重程度
级别，它们按严重程度递减的顺序排列。

每个元素的形式为@code{(@var{level} @var{string} @var{function})}，其中
@var{level}是它所定义的严重程度级别。@var{string}指定了这个级别的文字描述
。@var{string}应该使用@samp{%s}来指定将警告类型的信息放在哪里，也可以省略
@samp{%s}，这样就不会包含这些信息。

可选的@var{function}，如果是非@code{nil}，则是调用一个没有参数的函数，以
引起用户的注意。

通常情况下，你不应该改变这个变量的值。
@end defvar

@defvar warning-prefix-function
如果非@code{nil}，则该值是一个用于生成警告前缀文本的函数。程序可以将该变量
绑定到一个合适的函数上。@code{display-warning}在当前警告缓冲区的情况下调
用这个函数，该函数可以在其中插入文本。该文本成为警告信息的开头。

调用该函数时有两个参数，即严重程度和它在@code{warning-levels}中的条目。它
应该返回一个列表作为条目（这个值不需要是@code{warning-levels}的实际成员）
。通过构造这个值，函数可以改变警告的严重性，或者为给定的严重性级别指定不同
的处理方式。

如果变量的值是@code{nil}，那么就没有函数可以调用。
@end defvar

@defvar warning-series
程序可以将这个变量绑定到@code{t}上，表示下一个警告应该开始一个系列。当几个
警告形成一个系列时，这意味着要把点留在系列的第一个警告上，而不是为每个警告
不断移动它，使它出现在最后一个警告上。当本地绑定被解除时，系列结束，
@code{warning-series}又变成@code{nil}。

这个值也可以是一个带有函数定义的符号。这等同于@code{t}，只是下一个警告也会
调用这个没有参数的函数，并且警告缓冲区是当前的。该函数可以插入文本，作为一
系列警告的标题。

一旦一个系列开始，该值就是一个标记，它指向系列开始的警告缓冲区中的缓冲位置
。

该变量的正常值为@code{nil}，即分别处理每个警告。
@end defvar

@defvar warning-fill-prefix
当这个变量是非@code{nil}时，它指定了一个填充前缀，用于填充每个警告的文本。
@end defvar

@defvar warning-fill-column
填充警告的列。
@end defvar

@defvar warning-type-format
这个变量指定了在警告信息中显示警告类型的格式。在@code{warning-levels}中的
字符串的控制下，这样格式化类型的结果会被包含在消息中。默认值是
@code{" (%s)"}。如果您将其绑定为 @code{""}，那么警告类型将完全不会出现。
@end defvar

@node 警告选项
@subsection Warning Options
@cindex warning options

  这些变量被用户用来控制当一个Lisp程序报告一个警告时发生的事情。

@defopt warning-minimum-level
这个用户选项指定了应该立即显示给用户的最小严重程度。默认值是
@code{:warning}，这意味着除了@code{:debug}警告之外，要立即显示所有警告。
@end defopt

@defopt warning-minimum-log-level
这个用户选项指定了在警告缓冲区中记录的最小严重程度。默认值是
@code{:warning}，这意味着除了@code{:debug}之外的所有警告都会被记录。
@end defopt

@defopt warning-suppress-types
这个列表指定了哪些警告类型不应该立即为用户显示。列表中的每个元素应该是一个
符号列表。如果它的元素与警告类型中的第一个元素相匹配，那么该警告就不会立即
显示。
@end defopt

@defopt warning-suppress-log-types
这个列表指定了哪些警告类型不应该被记录在警告缓冲区中。列表中的每个元素应该
是一个符号列表。如果它与警告类型中的前几个元素相匹配，那么该警告就不会被记
录。
@end defopt

@node 延迟警告
@subsection Delayed Warnings
@cindex delayed warnings

有时，您可能希望避免在命令运行时显示警告，而只在命令结束后才显示。您可以使
用函数@code{delay-warning}来实现这一点。

@defun delay-warning type message &optional level buffer-name
这个函数是@code{display-warning}的延迟对应函数。(@pxref{警告基础})，并以相同的
参数调用它。警告信息被排入@code{delayed-warnings-list}。
@end defun

@defvar delayed-warnings-list
这个变量的值是当前命令结束后要显示的警告列表。每个元素必须是一个列表

@smallexample
(@var{type} @var{message} [@var{level} [@var{buffer-name}]])
@end smallexample

@noindent
与@code{display-warning}的参数列表具有相同的形式和含义。在运行
@code{post-command-hook}(@pxref{命令概述})后，Emacs命令循环会立即显示该变量指
定的所有警告，然后将其重置为@code{nil}。
@end defvar

  需要进一步定制延迟警告机制的程序可以更改@code{delayed-warnings-hook}变
量：

@defvar delayed-warnings-hook
这是一个普通的钩子，由Emacs命令循环在@code{post-command-hook}之后运行，以
便处理和显示延迟的警告。

其默认值是两个函数的列表：

@smallexample
(collapse-delayed-warnings display-delayed-warnings)
@end smallexample

@findex collapse-delayed-warnings
@findex display-delayed-warnings
@noindent
函数@code{collapse-delayed-warnings}删除@code{delayed-warnings-list}中
的重复条目。函数@code{display-delayed-warnings}依次调用
@code{display-warning}在@code{delayed-warnings-list}中的每个条目，然后将
@code{delayed-warnings-list}设置为@code{nil}。
@end defvar

@node 隐形文本
@section Invisible Text

@cindex invisible text
您可以使用@code{invisible}属性使@dfn{invisible}字符不出现在屏幕上。这可以
是一个文本属性(@pxref{Text Properties})或覆盖属性(@pxref{叠加})。光
标运动也会部分忽略这些字符，如果命令循环在命令后发现点在不可见文本的范围内
，就会将点重新定位到文本的另一侧。

在最简单的情况下，任何非@code{nil}。@code{invisible}属性使一个字符不可见
。这是默认的情况--如果你不改变@code{buffer-invisibility-spec}的默认值，这
就是@code{invisible}属性的工作方式。如果你不打算自己设置
@code{buffer-invisibility-spec}，通常应该使用@code{t}作为
@code{invisible}属性的值。

更一般地说，您可以使用@code{buffer-invisibility-spec}变量来控制
@code{invisible}属性的哪些值使文本不可见。这允许您预先将文本分为不同的子集
，赋予它们不同的@code{invisible}值，然后通过改变
@code{buffer-invisibility-spec}的值使不同的子集可见或不可见。

用@code{buffer-invisibility-spec}控制可见性在显示数据库中的条目列表的程序
中特别有用。它允许实现方便的过滤命令，只查看数据库中的一部分条目。设置这个
变量的速度非常快，比扫描缓冲区中的所有文本寻找要改变的属性要快得多。

@defvar buffer-invisibility-spec
这个变量指定了哪些@code{invisible}属性会让一个字符不可见。设置这个变量可以
使其成为缓冲区的局部属性。

@table @asis
@item @code{t}
如果一个字符的@code{invisible}属性是非@code{nil}，则该字符是不可见的。这是
默认的。

@item a list
列表中的每个元素都指定了一个隐形功能的标准；如果一个角色的@code{invisible}
属性符合其中任何一个标准，那么这个角色就是隐形的。列表可以有两种元素：

@table @code
@item @var{atom}
如果一个字符的@code{invisible}属性值是@var{atom}，或者它是一个以
@var{atom}为成员的列表，那么这个字符是不可见的；用@code{eq}进行比较。

@item (@var{atom} . t)
如果一个字符的 @code{invisible} 属性值是 @var{atom}，或者它是一个以
@var{atom}为成员的列表，那么这个字符是不可见的；比较是通过@code{eq}来完成
的。此外，这样的字符序列会显示为省略号。
@end table
@end table
@end defvar

  我们特别提供了两个函数，用于向@code{buffer-invisibility-spec}中添加元素
和从其中移除元素。

@defun add-to-invisibility-spec element
这个函数将@var{element}元素添加到@code{buffer-invisibility-spec}中。如果
@code{buffer-invisibility-spec}是@code{t}，那么它就会变成一个列表，
@code{(t)}，这样@code{invisible}属性为@code{t}的文本就会保持不可见。
@end defun

@defun remove-from-invisibility-spec element
从@code{buffer-invisibility-spec}中删除@var{element}元素。如果
@var{element}不在列表中，则不做任何操作。
@end defun

  使用@code{buffer-invisibility-spec}的惯例是，主要模式应该使用模式本身的
名称作为@code{buffer-invisibility-spec}的元素，并作为@code{invisible}属
性的值：

@example
;; @r{If you want to display an ellipsis:}
(add-to-invisibility-spec '(my-symbol . t))
;; @r{If you don't want ellipsis:}
(add-to-invisibility-spec 'my-symbol)

(overlay-put (make-overlay beginning end)
             'invisible 'my-symbol)

;; @r{When done with the invisibility:}
(remove-from-invisibility-spec '(my-symbol . t))
;; @r{Or respectively:}
(remove-from-invisibility-spec 'my-symbol)
@end example

  您可以使用以下功能检查隐身性：

@defun invisible-p pos-or-prop
如果@var{pos-or-prop}是一个标记或数字，如果该位置的文本当前是不可见的，则
该函数返回一个非@code{nil}值。

如果@var{pos-or-prop}是任何其他类型的Lisp对象，则表示@code{invisible}文本
或覆盖属性的可能值。在这种情况下，如果这个值会导致文本不可见，那么这个函数
将根据@code{buffer-invisibility-spec}的当前值返回一个非@code{nil}值。

如果文字在显示时被完全隐藏，则该函数的返回值为@code{t}，如果文字被省略号代
替，则返回非@code{nil}、非@code{t}值。
@end defun

@vindex line-move-ignore-invisible
  通常情况下，对文本或移动点进行操作的函数并不关心文本是否隐形，它们对隐形
字符和可见字符都进行处理。用户级的移行命令，如@code{next-line}、
@code{previous-line}，如果@code{line-move-ignore-invisible}是非
@code{nil}，则会忽略不可见的新行。(默认值)，也就是说，就像这些不可见的新行
在缓冲区中并不存在一样，只是因为它们被明确地编程为这样做。

  如果一个命令的结尾点在不可见文本的内部或边界处，主编辑循环会将点重新定位
到不可见文本的两端之一。Emacs会选择重定位的方向，使其与命令的整体移动方向
相同；如果有疑问，它更倾向于选择插入的字符不会继承@code{invisible}属性的位
置。此外，如果文本没有被省略号代替，而命令只是在不可见的文本中移动，那么点
会被多移动一个字符，以便尝试通过光标的可见移动来反映命令的移动。

  因此，如果命令将点移动到一个不可见的范围（具有通常的粘性），Emacs将点移
动到该范围的开始。如果命令将点向前移动到一个不可见的范围，Emacs将点向前移
动到不可见文本后面的第一个可见字符，然后再向前移动一个字符。

  通过将@code{disable-point-adjustment}设置为非@code{nil}值，可以禁用这
些最终在隐形文本中间的点的@dfn{adjustments}。@xref{Adjusting Point}。

  增量搜索可以使不可见的覆盖层在匹配中包含不可见文本时暂时和/或永久可见。要
启用这个功能，覆盖层应该有一个非@code{nil}的
@code{isearch-open-invisible}属性。属性值应该是一个以覆盖层为参数调用的函
数。这个函数应该使覆盖层永久可见；当匹配在退出搜索时与覆盖层重叠时，就会使
用这个函数。

  在搜索过程中，通过临时修改这些覆盖层的不可见和无形属性，使其暂时可见。如
果你想对某个覆盖层进行不同的操作，可以给它一个
@code{isearch-open-invisible-temporary}属性，它是一个函数。调用该函数时
有两个参数：第一个是覆盖层，第二个是@code{nil}使覆盖层可见，或者@code{t}使
其再次不可见。

@node 选择性显示
@section Selective Display
@c @cindex selective display   Duplicates selective-display

  @dfn{选择性显示}指的是一对相关功能，用于隐藏屏幕上的某些行。

@cindex explicit selective display
  第一个变体，显式选择性显示，是为在Lisp程序中使用而设计的：它通过改变文本
来控制哪些行被隐藏。这种隐藏方式现在已经过时并被废弃了；相反，你应该使用
@code{invisible} 属性 (@pxref{Invisible Text}) 来获得同样的效果。

  在第二个变体中，根据缩进情况自动选择要隐藏的行。这种变体设计为用户级功能
。

  控制显式选择性显示的方法是用回车（control-m）代替换行（control-j）。原本
是一行的文本在换行符之后就被隐藏了。严格地说，它暂时不是一行，因为只有换行
符才能分隔行，它现在是前一行的一部分。

  选择性显示不直接影响编辑命令。例如，@kbd{C-f}。(@code{forward-char})毫
不犹豫地将点移动到隐藏文本中。然而，用回车字符代替换行字符会影响一些编辑命
令。例如，@code{next-line}会跳过隐藏的行，因为它只搜索换行符。使用选择性显
示的模式也可以定义一些考虑到换行符的命令，或者控制文本的哪些部分被隐藏。

  当你把一个有选择地显示的缓冲区写入文件时，所有的control-m都以换行符的形
式输出。这意味着当你下一次读入文件时，它看起来是OK的，没有任何隐藏。选择性
显示效果只有在Emacs中才能看到。

@defvar selective-display
这个缓冲区局部变量可以实现选择性显示。这意味着行或行的一部分可以被隐藏。

@itemize @bullet
@item
如果@code{selective-display}的值是@code{t}，那么字符control-m标志着隐藏
文本的开始；control-m以及它后面的其余行都不显示。这就是显式选择性显示。

@item
如果@code{selective-display}的值是一个正整数，则不显示以多于该列缩进开始
的行。
@end itemize

当缓冲区的某些部分被隐藏时，垂直移动命令的操作就像该部分不存在一样，允许一
个@code{next-line}命令跳过任何数量的隐藏行。然而，字符移动命令（如
@code{forward-char}）并不跳过隐藏部分，而且可以在隐藏部分中插入或删除文本
（尽管很取巧）。

在下面的示例中，我们展示了缓冲区@code{foo}的@emph{显示外观}，它随着
@code{selective-display}的值而改变。缓冲区的@emph{内容}不会改变。

@example
@group
(setq selective-display nil)
     @result{} nil

---------- Buffer: foo ----------
1 on this column
 2on this column
  3n this column
  3n this column
 2on this column
1 on this column
---------- Buffer: foo ----------
@end group

@group
(setq selective-display 2)
     @result{} 2

---------- Buffer: foo ----------
1 on this column
 2on this column
 2on this column
1 on this column
---------- Buffer: foo ----------
@end group
@end example
@end defvar

@defopt selective-display-ellipses
如果这个缓冲区本地变量是非@code{nil}，那么Emacs会在行末的隐藏文本后面显示
出@samp{@dots{}}。这个例子是上一个例子的延续。

@example
@group
(setq selective-display-ellipses t)
     @result{} t

---------- Buffer: foo ----------
1 on this column
 2on this column ...
 2on this column
1 on this column
---------- Buffer: foo ----------
@end group
@end example

您可以使用一个显示表格来代替省略号的其他文本（@samp{@dots{}}）。@xref{显示表}。
@end defopt

@node 临时显示
@section Temporary Displays
@cindex temporary display
@cindex temporary buffer display

  临时显示被Lisp程序用来将输出放入缓冲区，然后呈现给用户浏览而不是编辑。许
多帮助命令都使用了这个功能。

@defmac with-output-to-temp-buffer buffer-name body@dots{}
这个函数执行@var{body}中的窗体，同时安排将它们打印的任何输出插入到名为
@var{buffer-name}的缓冲区中，必要时首先创建该缓冲区，并将其放入Help模式。
(参见下面类似的窗体@code{with-temp-buffer-window})最后，在某个窗口中显示
缓冲区，但该窗口没有被选中。(参见下面类似的窗体
@code{with-temp-buffer-window}。)最后，缓冲区会显示在某个窗口中，但该窗口
不被选中。

如果@var{body}中的表单没有改变输出缓冲区的主要模式，使其在执行结束时仍然是
Help模式，那么@code{with-output-to-temp-buffer}就会使这个缓冲区在最后变成
只读模式，并且还会扫描其中的函数和变量名，使其成为可点击的交叉引用。
@xref{Docstring hyperlinks, , Tips for Documentation Strings}，特别是关
于文档字符串中的超链接这一项，了解更多细节。

字符串@var{buffer-name}指定临时缓冲区，它不需要已经存在。参数必须是一个字
符串，而不是一个缓冲区。缓冲区最初会被擦除（不问任何问题），在
@code{with-output-to-temp-buffer}退出后，它被标记为未修改。

@code{with-output-to-temp-buffer}将@code{standard-output}绑定到临时缓冲
区，然后它运行@var{body}中的表单。使用@var{body}中的Lisp输出函数的输出，
默认会进入该缓冲区(但屏幕显示和回声区中的信息，尽管它们在一般意义上是"输出"
，但不受影响)。@xref{Output Functions}.

有几个钩子可用于自定义该构造的行为；它们被列在下面。

@var{body}中最后一个表单的值会返回。

@example
@group
---------- Buffer: foo ----------
 This is the contents of foo.
---------- Buffer: foo ----------
@end group

@group
(with-output-to-temp-buffer "foo"
    (print 20)
    (print standard-output))
@result{} #<buffer foo>

---------- Buffer: foo ----------

20

#<buffer foo>

---------- Buffer: foo ----------
@end group
@end example
@end defmac

@defopt temp-buffer-show-function
如果这个变量是非@code{nil}，@code{with-output-to-temp-buffer}就会以函数
的形式调用它来完成显示帮助缓冲区的工作。该函数得到一个参数，即它应该显示的
缓冲区。

这个函数最好和@code{with-output-to-temp-buffer}正常情况一样，
@code{save-selected-window}和当前选择的窗口和缓冲区内部运行
@code{temp-buffer-show-hook}。
@end defopt

@defvar temp-buffer-setup-hook
这个正常的钩子是由@code{with-output-to-temp-buffer}在评估@var{body}之前
运行的。当这个钩子运行时，临时缓冲区是当前的。这个钩子通常与一个函数一起设
置，以使缓冲区进入帮助模式。
@end defvar

@defvar temp-buffer-show-hook
这个正常的钩子是由@code{with-output-to-temp-buffer}在显示临时缓冲区后运行
的。当该钩子运行时，临时缓冲区是当前的，并且它所显示的窗口被选中。
@end defvar

@defmac with-temp-buffer-window buffer-or-name action quit-function body@dots{}
这个宏类似于@code{with-output-to-temp-buffer}。和那个构造一样，它在执行
@var{body}的同时，安排将它打印的任何输出插入到名为@var{buffer-or-name}的
缓冲区中，并在某个窗口中显示该缓冲区。但与
@code{with-output-to-temp-buffer}不同的是，它不会自动将该缓冲区切换到Help
模式。

参数@var{buffer-or-name}指定了临时缓冲区。它可以是一个已经存在的缓冲区，也
可以是一个字符串，在这种情况下，如果需要的话，会创建一个同名的缓冲区。当
@code{with-temp-buffer-window}退出时，缓冲区被标记为未修改和只读。

这个宏没有调用@code{temp-buffer-show-function}，而是将@var{action}参数传
递给@code{display-buffer}。而是将@var{action}参数传递给
@code{display-buffer}。(@pxref{Choosing Window})，以便显示缓冲区。

除非指定了参数@var{quit-function}，否则将返回@var{body}中最后一个表单的值
。在这种情况下，调用它时有两个参数：显示缓冲区的窗口和@var{body}的结果。最
后的返回值就是@var{quit-function}所返回的值。

@vindex temp-buffer-window-setup-hook
@vindex temp-buffer-window-show-hook
这个宏使用普通的钩子@code{temp-buffer-window-setup-hook}和
@code{temp-buffer-window-show-hook}来代替
@code{with-output-to-temp-buffer}运行的类似钩子。
@end defmac

接下来描述的两个构造与@code{with-temp-buffer-window}大部分相同，但与它的
不同之处在于以下的规定:

@defmac with-current-buffer-window buffer-or-name action quit-function &rest body
这个宏和@code{with-temp-buffer-window}类似，但不同的是，它使
@var{buffer-or-name}指定的缓冲区成为运行@var{body}的当前缓冲区。
@end defmac

一个显示临时缓冲区的窗口，可以使用以下模式将该缓冲区的大小装入：

@defopt temp-buffer-resize-mode
启用该次要模式后，显示临时缓冲区的窗口会自动调整大小以适应缓冲区的内容。

如果且仅当一个窗口是为缓冲区专门创建的，那么它就会被调整大小。特别是，之前
显示过其他缓冲区的窗口不会被调整大小。默认情况下，该模式使用
@code{fit-window-to-buffer}(@pxref{调整窗口大小})来调整大小。您可以
通过自定义下面的@code{temp-buffer-max-height}和
@code{temp-buffer-max-width}选项来指定不同的函数。
@end defopt

@defopt temp-buffer-max-height
这个选项指定了当@code{temp-buffer-resize-mode}被启用时，窗口显示临时缓冲
区的最大高度（以行为单位）。它也可以作为一个函数被调用来选择这样一个缓冲区
的高度。它得到一个参数，即缓冲区，并且应该返回一个正整数。在调用该函数时，
需要调整大小的窗口被选中。
@end defopt

@defopt temp-buffer-max-width
这个选项指定了当@code{temp-buffer-resize-mode}被启用时，窗口显示临时缓冲
区的最大宽度（以列为单位）。它也可以作为一个函数被调用来选择缓冲区的宽度。
它得到一个参数，即缓冲区，并且应该返回一个正整数。在调用该函数时，需要调整
大小的窗口被选中。
@end defopt

以下功能使用当前缓冲区进行临时显示：

@defun momentary-string-display string position &optional char message
这个函数在当前缓冲区的@var{position}处暂时显示@var{string}。它对撤销列表
或缓冲区的修改状态没有影响。

在下一个输入事件发生之前，瞬时显示一直保持。如果下一个输入事件是@var{char}
，@code{momentary-string-display}会忽略它并返回。否则，该事件仍将被缓冲，
以便后续作为输入使用。因此，键入@var{char}将简单地从显示中移除字符串，而键
入 (比如)@kbd{C-f}将从显示中移除字符串，并在之后(大概)将点向前移动。参数
@var{char}默认是一个空格。

@code{momentary-string-display}的返回值是没有意义的。

如果字符串@var{string}不包含控制字符，您可以通过使用@code{before-string}
属性创建（然后随后删除）一个覆盖层，以更通用的方式完成同样的工作。
@xref{叠加属性}。

如果@var{message}是非@code{nil}，则显示在回音区，而@var{string}则显示在缓
冲区。如果是@code{nil}，则默认消息说要输入@var{char}来继续。

在这个例子中，点最初位于第二行的开头:

@example
@group
---------- Buffer: foo ----------
This is the contents of foo.
@point{}Second line.
---------- Buffer: foo ----------
@end group

@group
(momentary-string-display
  "**** Important Message! ****"
  (point) ?\r
  "Type RET when done reading")
@result{} t
@end group

@group
---------- Buffer: foo ----------
This is the contents of foo.
**** Important Message! ****Second line.
---------- Buffer: foo ----------

---------- Echo Area ----------
Type RET when done reading
---------- Echo Area ----------
@end group
@end example
@end defun

@node 叠加
@section Overlays
@cindex overlays
@c FIXME：在本节中提到间隔？

您可以使用@dfn{overlays}来改变一个缓冲区的文字在屏幕上的外观，以达到展示特
性的目的。叠加是一个属于特定缓冲区的对象，它有一个指定的开始和结束。它也有
你可以检查和设置的属性，这些属性会影响覆盖层中文本的显示。

@cindex scalability of overlays
@cindex overlays, scalability
叠加的视觉效果与对应的文本属性(@pxref{Text Properties})是一样的。然而，由
于实现方式不同，覆盖层通常不能很好地扩展（许多操作所需的时间与缓冲区中覆盖
层的数量成正比）。如果您需要影响缓冲区中许多部分的视觉外观，我们建议使用文
本属性。

叠加使用标记来记录它的开头和结尾，因此，编辑缓冲区的文本会调整每个叠加的开头和结尾，使其与文本保持一致。在创建叠加时，您可以指定在开头插入的文本应该在叠加内还是在叠加外，同样也可以指定叠加的结尾。

@menu
* 管理叠加::   创建和移动叠加。
* 叠加属性::   如何读取和设置属性。属性对屏幕显示的作用。
* 寻找叠加::   搜索叠加。
@end menu

@node 管理叠加
@subsection Managing Overlays
@cindex managing overlays
@cindex overlays, managing

  本节介绍了创建、删除、移动叠加以及检查叠加内容的功能。由于叠加不是缓冲区
内容的一部分，因此叠加的更改不会记录在缓冲区的撤销列表中。

@defun overlayp object
如果@var{object}是，则该函数返回@code{t}。
@end defun

@defun make-overlay start end &optional buffer front-advance rear-advance
此函数创建并返回一个属于@var{buffer}的覆盖层，覆盖范围从@var{start}到
@var{end}。@var{start}和@var{end}都必须指定缓冲区的位置，它们可以是整数或
标记。如果省略了@var{buffer}，则会在当前的缓冲区中创建覆盖层。

@cindex empty overlay
@cindex overlay, empty
一个覆盖层的@var{start}和@var{end}指定了相同的缓冲区位置，称为@dfn{empty}
。如果@var{start}和@var{end}之间的文本被删除，一个非空的覆盖层就会变成空的
。当这种情况发生时，默认情况下，覆盖层不会被删除，但您可以通过给它设置
@samp{evaporate}属性(@pxref{Overlay Properties, evaporate property})来
使它被删除。

参数@var{front-advance}和@var{rear-advance}分别指定了叠加开始和叠加结束
的标记插入类型@xref{Marker Insertion Types}。如果它们都是@code{nil}，也
就是默认值，那么覆盖层将扩展到包括任何在开头插入的文本，但不包括在结尾插入
的文本。如果@var{front-advance}是非@code{nil}，那么在叠加开始处插入的文本
将被排除在叠加之外。如果@var{rear-advance}是非@code{nil}，那么在覆载结束
时插入的文本将被包含在覆载中。
@end defun

@defun overlay-start overlay
此函数以整数形式返回@var{overlay}的起始位置。
@end defun

@defun overlay-end overlay
此函数以整数形式返回@var{overlay}结束的位置。
@end defun

@defun overlay-buffer overlay
此函数返回@var{overlay}所属的缓冲区，如果@var{overlay}已被删除，则返回
@code{nil}。
@end defun

@defun delete-overlay overlay
这个函数删除了@var{overlay}。覆盖层作为一个Lisp对象继续存在，它的属性列表
没有变化，但它不再附着在它所属的缓冲区上，也不再对显示有任何影响。

被删除的叠加不会被永久断开。你可以通过调用@code{move-overlay}来重新给它在
缓冲区中的位置。
@end defun

@defun move-overlay overlay start end &optional buffer
这个函数将@var{overlay}移动到@var{buffer}，并将其边界置于@var{start}和
@var{end}。参数@var{start}和@var{end}都必须指定缓冲区的位置，可以是整数，
也可以是标记。

如果省略了@var{buffer}，@var{overlay}会停留在它已经关联的那个缓冲区中；如
果删除了@var{overlay}，它就会进入当前的缓冲区。

返回值是@var{overlay}。

这是更改覆盖图端点的唯一有效方法。不要尝试手动修改叠加中的标记，因为这样做
无法更新其他重要的数据结构，并可能导致一些叠加丢失。
@end defun

@defun remove-overlays &optional start end name value
这个函数可以删除@var{start}和@var{end}之间所有属性@var{name}的值为
@var{value}的覆盖层。它可以移动区域内覆盖层的端点，或者分割它们。

如果省略@var{name}或者@code{nil}，表示删除指定区域的所有覆盖层。如果
@var{start}和/或@var{end}被省略或@code{nil}，表示分别删除缓冲区的开始和结
束。因此，@code{(remove-overlays)}删除了当前缓冲区中的所有覆盖。
@end defun

@defun copy-overlay overlay
此函数返回@var{overlay}的副本。这个副本的端点和属性与@var{overlay}相同。
但是，覆盖层开始和结束的标记插入类型被设置为默认值（
@pxref{Marker Insertion Types}）。
@end defun

  下面是一些例子：

@example
;; @r{Create an overlay.}
(setq foo (make-overlay 1 10))
     @result{} #<overlay from 1 to 10 in display.texi>
(overlay-start foo)
     @result{} 1
(overlay-end foo)
     @result{} 10
(overlay-buffer foo)
     @result{} #<buffer display.texi>
;; @r{Give it a property we can check later.}
(overlay-put foo 'happy t)
     @result{} t
;; @r{Verify the property is present.}
(overlay-get foo 'happy)
     @result{} t
;; @r{Move the overlay.}
(move-overlay foo 5 20)
     @result{} #<overlay from 5 to 20 in display.texi>
(overlay-start foo)
     @result{} 5
(overlay-end foo)
     @result{} 20
;; @r{Delete the overlay.}
(delete-overlay foo)
     @result{} nil
;; @r{Verify it is deleted.}
foo
     @result{} #<overlay in no buffer>
;; @r{A deleted overlay has no position.}
(overlay-start foo)
     @result{} nil
(overlay-end foo)
     @result{} nil
(overlay-buffer foo)
     @result{} nil
;; @r{Undelete the overlay.}
(move-overlay foo 1 20)
     @result{} #<overlay from 1 to 20 in display.texi>
;; @r{Verify the results.}
(overlay-start foo)
     @result{} 1
(overlay-end foo)
     @result{} 20
(overlay-buffer foo)
     @result{} #<buffer display.texi>
;; @r{Moving and deleting the overlay does not change its properties.}
(overlay-get foo 'happy)
     @result{} t
@end example

  Emacs将每个缓冲区的覆盖存储在两个列表中，围绕一个任意的中心位置进行划分
。一个列表从中心位置向后延伸，另一个列表从中心位置向前延伸。中心位置可以是
缓冲区的任何位置。

@defun overlay-recenter pos
这个函数将当前缓冲区中@var{pos}位置周围的覆盖层进行更新。这样一来，对于靠
近@var{pos}的位置，覆盖查找的速度会更快，但对于远离@var{pos}的位置，覆盖查
找的速度会更慢。
@end defun

  循环向前扫描缓冲区，创建叠加，如果先做
@code{(overlay-recenter (point-max))}，可以运行得更快。

@node 叠加属性
@subsection Overlay Properties
@cindex overlay properties

  覆盖属性和文本属性一样，改变字符显示方式的属性可以来自任何一个来源。但在
大多数方面，它们是不同的。@xref{Text Properties}，作为比较。

  文本属性被认为是文本的一部分；覆盖层及其属性被特别认为不是文本的一部分。
因此，在各种缓冲区和字符串之间复制文本会保留文本属性，但不会尝试保留覆盖层
。更改缓冲区的文本属性会标记该缓冲区被修改，而移动覆盖层或更改其属性则不会
。与文本属性的改变不同，覆盖层属性的改变不会记录在缓冲区的撤销列表中。

  由于多个覆盖层可以为同一个字符指定一个属性值，Emacs允许你为每个覆盖层指
定一个优先值。优先权值用来决定哪个重叠的覆盖层会"赢"。

  这些函数读取和设置覆盖层的属性:

@defun overlay-get overlay prop
这个函数返回@var{overlay}中记录的@var{prop}属性的值（如果有）。如果
@var{overlay}没有记录任何属性值，但是它有一个@code{category}属性，而这个
属性是一个符号，那么就使用这个符号的@var{prop}属性。否则，其值就是
@code{nil}。
@end defun

@defun overlay-put overlay prop value
此函数将记录在@var{overlay}中的@var{prop}属性值设置为@var{value}。返回
@var{value}。
@end defun

@defun overlay-properties overlay
返回@var{overlay}的属性列表的副本。
@end defun

  也请参见函数@code{get-char-property}，它可以检查给定字符的覆盖属性和文
本属性。@xref{Examining Properties}。

  许多叠加属性都有特殊的含义，下面是它们的表格：

@table @code
@item priority
@kindex priority @r{(overlay property)}
此属性的值决定了叠加的优先级。如果您想指定一个优先级值，请使用@code{nil}(
或零)，或一个正整数。任何其他的值都是未定义的行为。

当两个或两个以上的覆盖层覆盖同一个字符，并且都指定了相同的属性时，优先级就
很重要；@code{priority}值较大的那个覆盖层会覆盖另一个覆盖层。(对于
@code{face}属性，优先级较高的覆盖层的值并不完全覆盖另一个值；相反，它的字
体属性覆盖优先级较低的@code{face}属性的字体属性。)如果两个覆盖层具有相同的
优先级值，并且一个覆盖层嵌套在另一个覆盖层中，那么内部的覆盖层将优先于外部
的覆盖层。如果两个叠加都没有嵌套在另一个叠加中，那么您就不应该对哪个叠加优
先做出假设。

目前，所有覆盖物都优先于文本属性。

请注意，Emacs有时会对一些内部覆盖使用非数字优先级值，所以不要试图对覆盖的
优先级进行运算（除非是你创建的覆盖）。特别是，用于显示区域的叠加使用了一个
优先级值，其形式为@w{@code{(@var{primary} . @var{secondary})}}，其中
@var{primary}如上介绍，而@var{secondary}则是当@var{primary}和嵌套考虑不
能解决覆盖层之间的优先级时使用的后备值。但是，建议你不要根据这个实现细节来
设计Lisp程序，如果你需要将覆盖物按优先级排序，请使用@code{overlays-at}的
@var{sorted}参数。@xref{寻找叠加}.

@item window
@kindex window @r{(overlay property)}
如果@code{window}属性是非@code{nil}，那么叠加只适用于该窗口。

@item category
@kindex category @r{(overlay property)}
如果一个覆盖层有一个@code{category}属性，我们把它称为覆盖层的
@dfn{category}。它应该是一个符号。属性的符号作为叠加属性的默认值。

@item face
@kindex face @r{(overlay property)}
此属性控制文本的外观(@pxref{字形})。该属性的值可以是以下几种:

@itemize @bullet
@item
一个字体名（一个符号或字符串）。

@item
一个匿名的字体：一个@code{(@var{keyword} @var{value} @dots{})}形式的
属性列表，其中每个@var{keyword}是一个字体属性名，@var{value}是该属性
的一个值。

@item
一个字体的列表。每个列表元素应该是一个字体名称或一个匿名字体。这指定
了一个字体，它是每一个被列出的字体的属性的集合。列表中较早出现的字体
有较高的优先级。

@item
一个形式为@code{(foreground-color . @var{color-name})}或
@code{(background-color . @var{color-name})}的cons cell。指定前景或
背景颜色，类似于@code{(:foreground @var{color-name})}或
@code{(:background @var{color-name})}。这种形式只是为了向后兼容而支
持，应该避免使用。
@end itemize

@item mouse-face
@kindex mouse-face @r{(overlay property)}
当鼠标在覆盖范围内时，这个属性会代替@code{face}使用。然而，Emacs会忽
略此属性中所有改变文本大小的字体属性（例如@code{:height}、
@code{:weight}和@code{:slant}）。这些属性总是与未加亮的文本相同。

@item display
@kindex display @r{(overlay property)}
此属性可激活各种改变文本显示方式的功能。例如，它可以使文本显示得更高
或更短、更高或更低、更宽或更窄，或用图像代替。
@xref{Display Property}。

@item help-echo
@kindex help-echo @r{(overlay property)}
如果一个覆盖层有@code{help-echo}属性，那么当您将鼠标移动到覆盖层中的
文本上时，Emacs会在回声区域或工具提示窗口中显示帮助字符串。详情请看
@ref{Text help-echo}。

@item field
@kindex field @r{(overlay property)}
@c 复制自特殊属性。
具有相同@code{field}属性的连续字符构成一个@emph{field}。一些运动函数
，包括@code{forward-word}和@emph{field}。@code{beginning-of-line}在
字段边界处停止移动。@xref{Fields}。

@item modification-hooks
@kindex modification-hooks @r{(overlay property)}

此属性的值是一个函数列表，当覆盖层中的任何字符被更改或严格在覆盖层中
插入文本时，将被调用。

钩子函数在每次修改之前和之后都会被调用。如果函数保存它们收到的信息，
并在调用之间进行比较，它们就可以确定缓冲区文本中到底发生了什么变化。

当在修改前调用时，每个函数都会收到四个参数：覆盖层、@code{nil}和要修
改的文本范围的开始和结束。

修改后调用时，每个函数都会收到五个参数：覆盖层、@code{t}、刚刚修改的
文本范围的开头和结尾、被该范围替换的修改前文本的长度。对于插入，修改
前的长度为零；对于删除，该长度为删除的字符数，修改后的开头和结尾相等
）。

当这些函数被调用时，@code{inhibit-modification-hooks}被绑定到非
@code{nil}。如果这些函数对缓冲区进行了修改，您可能希望将
@code{inhibit-modification-hooks}绑定到@code{nil}上，以便使变更钩子
为这些修改运行。然而，这样做可能会递归地调用你自己的变更钩子，所以一
定要做好准备。@xref{Change Hooks}。

文本属性也支持@code{modification-hooks}属性，但细节有些不同（
@pxref{Special Properties}）。

@item insert-in-front-hooks
@kindex insert-in-front-hooks @r{(overlay property)}
此属性的值是在覆盖的开始处插入文本之前和之后要调用的函数列表。调用惯
例与@code{modification-hooks}函数相同。

@item insert-behind-hooks
@kindex insert-behind-hooks @r{(overlay property)}
此属性的值是在覆盖层的末尾插入文本之前和之后要调用的函数列表。调用惯
例与@code{modification-hooks} 函数相同。

@item invisible
@kindex invisible @r{(overlay property)}
@code{invisible}属性可以使覆盖中的文本不可见，也就是说它不会出现在屏
幕上。详情请参考@xref{Invisible Text}。

@item intangible
@kindex intangible @r{(overlay property)}
覆盖层上的@code{intangible}属性与@code{intangible}文本属性一样。它已
经过时了。详情请参考@xref{Special Properties}。

@item isearch-open-invisible
这个属性告诉增量搜索，如果最终匹配重叠，如何使一个不可见的覆盖层永久
可见。@xref{Invisible Text}.

@item isearch-open-invisible-temporary
此属性告诉增量搜索如何在搜索过程中暂时使不可见的覆盖层可见。
@xref{Invisible Text}.

@item before-string
@kindex before-string @r{(overlay property)}
这个属性的值是一个字符串，要添加到叠加开始的显示中。该字符串不会出现
在任何意义上的缓冲区中，只会出现在屏幕上。

@item after-string
@kindex after-string @r{(overlay property)}
这个属性的值是一个字符串，要添加到叠加结束时的显示中。该字符串不会出
现在缓冲区中，只出现在屏幕上。

@item line-prefix
此属性指定了在显示时要预置到每个非延续行的显示规范。@xref{Truncation}.

@item wrap-prefix
此属性指定了在显示时要预置到每个延续行的显示规范。@xref{Truncation}.

@item evaporate
@kindex evaporate @r{(overlay property)}
如果这个属性是非@code{nil}，那么如果覆盖层变成了空的（也就是说，如果它的长
度变成了零），就会自动删除它。如果您给空叠加
(@pxref{Managing Overlays, empty overlay})一个非@code{nil}的属性。
@code{evaporate}属性，会立即将其删除。请注意，除非覆盖层有这个属性，否则当它的起始位置和结束位置之间的文本从缓冲区中删除时，它不会被删除。

@item keymap
@cindex keymap of character (and overlays)
@kindex keymap @r{(overlay property)}
如果此属性为非@code{nil}，则为文本的一部分指定一个键图。当点后的字符在覆盖
范围内时，这个键位图就会被使用，并且优先于其他大多数键位图。
@xref{Active Keymaps}.

@item local-map
@kindex local-map @r{(overlay property)}
@code{local-map}属性类似于@code{keymap}，但它替换了缓冲区的局部地图，而不
是增加现有的键值。这也意味着它的优先级比次要模式的键图低。
@end table

@code{keymap}和@code{local-map}属性不会影响@code{before-string}、
@code{after-string}或@code{display}属性所显示的字符串。这只与鼠标点击和其
他落在字符串上的鼠标事件有关，因为点从来不在字符串上。要为字符串绑定特殊的鼠标事件，请为它分配一个@code{keymap}或@code{local-map}文本属性。
@xref{Special Properties}。

@node 寻找叠加
@subsection Searching for Overlays
@cindex searching for overlays
@cindex overlays, searching for

@defun overlays-at pos &optional sorted
该函数返回当前缓冲区中所有覆盖在@var{pos}位置上的字符的列表。如果
@var{sorted}是非@code{nil}，则列表按优先级递减，否则没有特定顺序。如果覆
盖的位置始于@var{pos}或在@var{pos}之前，而结束于@var{pos}之后，则覆盖的位
置包含@var{pos}。

为了说明使用方法，下面是一个Lisp函数，它返回了一个为点上字符指定属性
@var{prop}的覆盖列表:

@smallexample
(defun find-overlays-specifying (prop)
  (let ((overlays (overlays-at (point)))
        found)
    (while overlays
      (let ((overlay (car overlays)))
        (if (overlay-get overlay prop)
            (setq found (cons overlay found))))
      (setq overlays (cdr overlays)))
    found))
@end smallexample
@end defun

@defun overlays-in beg end
此函数返回与@var{beg}到@var{end}区域重叠的覆盖层列表。如果一个叠加区域中包
含一个或多个字符，那么它就会与该区域重叠；如果空叠加（
@pxref{Managing Overlays, empty overlay}）位于@var{beg}，严格来说是在
@var{beg}和@var{end}之间，或者当@var{end}表示缓冲区末端的位置时位于
@var{end}，那么它们就会重叠。
@end defun

@defun next-overlay-change pos
此函数在返回@var{pos}之后，叠加的下一个开始或结束的缓冲区位置。如果没有，
则返回@code{(point-max)}。
@end defun

@defun previous-overlay-change pos
这个函数返回在@var{pos}之前，覆盖层的前一个开始或结束的缓冲区位置。如果没
有，则返回@code{(point-min)}。
@end defun

  举个例子，这里有一个简化的（低效的）基元函数
@code{next-single-char-property-change}的版本。(@pxref{Property Search}
)。它从位置@var{pos}开始向前搜索下一个位置，在这个位置上，从覆盖或文本属性
获得的给定属性@code{prop}的值发生了变化。

@smallexample
(defun next-single-char-property-change (position prop)
  (save-excursion
    (goto-char position)
    (let ((propval (get-char-property (point) prop)))
      (while (and (not (eobp))
                  (eq (get-char-property (point) prop) propval))
        (goto-char (min (next-overlay-change (point))
                        (next-single-property-change (point) prop)))))
    (point)))
@end smallexample

@node 显示文字的大小
@section Size of Displayed Text
@cindex size of text on display
@cindex character width on display

由于不是所有的字符都有相同的宽度，这些函数可以让你检查一个字符的宽度。
@xref{Primitive Indent},和@ref{Screen Lines}，了解相关功能。

@defun char-width char
该函数返回以列为单位的@var{char}字符的宽度，如果该字符在当前缓冲区中显示的
话（即，考虑到缓冲区的显示表，如果有的话；@pxref{Display Tables}）。tab
字符的宽度通常是@code{tab-width}。(@pxref{Usual Display})。
@end defun

@defun string-width string
该函数返回字符串@var{string}的列宽，如果它显示在当前的缓冲区和选定的窗口中
。
@end defun

@defun truncate-string-to-width string width &optional start-column padding ellipsis
此函数将@var{string}中塞得下@var{width}列的部分作为一个新的字符串返回。

如果@var{string}宽度没有够到@var{width}，那么结果将在@var{string}结束的地
方结束。如果@var{string}中的一个多列字符跨越了@var{width}列，那么这个字符
就不包含在结果中。因此，结果可以不超过@var{width}，但不能超过@var{width}
。

可选参数@var{start-column}指定了起始列。如果这个参数是非@code{nil}，那么字符串的第一列@var{start-column}将从值中省略。如果@var{string}中的一个多列字符跨越了@var{start-column}列，那么这个字符将不被包含。

可选参数@var{padding}，如果不是@code{nil}，则是在结果字符串的开头和结尾添加一个padding字符，以使其正好扩展到@var{width}列。如果结果少于@var{width}，则在结果的结尾使用padding字符。如果@var{string}中的一个多列字符跨越了@var{start-column}列，也会在结果的开头使用padding字符。

@vindex truncat-string-ellipsis
如果@var{ellipsis}是非@code{nil}，它应该是一个字符串，它将取代
@var{string}的结尾(包括任何padding)，除非@var{string}的显示宽度等于或小于
@var{ellipsis}的显示宽度。如果@var{ellipsis}是非@code{nil}而不是字符串，
那么它就代表变量@code{truncat-string-ellipsis}的值。

@example
(truncate-string-to-width "\tab\t" 12 4)
     @result{} "ab"
(truncate-string-to-width "\tab\t" 12 4 ?\s)
     @result{} "    ab  "
@end example
@end defun

下面的函数以像素为单位，返回文本在给定窗口中显示时的大小。这个函数被
@code{fit-window-to-buffer}和@code{fit-frame-to-buffer}(
@pxref{调整窗口大小})使用，以使窗口的大小与它所包含的文本完全相同。

@defun window-text-pixel-size &optional window from to x-limit y-limit mode-and-header-line
此函数返回@var{window}缓冲区中文本的大小，单位为像素。@var{window}必须是
一个实时窗口，默认为所选窗口。返回值是任意文本行的最大像素宽度和所有文本行
的最大像素高度的cons。

可选参数@var{from}，如果不是@code{nil}，则指定要考虑的第一个文本位置，默认
为缓冲区的最小可访问位置。如果@var{from}是@code{t}，则使用非换行符的最小可
访问位置。可选参数@var{to}，如果不是@code{nil}，则指定要考虑的最后一个文本
位置，默认为缓冲区的最大可访问位置。如果@var{to}是@code{t}，则使用非换行字
符的最大可访问位置。

可选参数@var{x-limit}，如果不是@code{nil}，则指定可以返回的最大像素宽度。
@var{x-limit}@code{nil}或省略代表使用@var{window}的主体的像素宽度 (
@pxref{窗口大小})；当调用者不打算改变@var{window}的宽度时，这很有用。
否则，调用者应该在这里指定@var{window}的主体可能承担的最大宽度。X坐标超出
@var{x-limit}的文本将被忽略。由于计算长行的宽度需要一定的时间，所以最好将
这个参数设置得越小越好；尤其是当缓冲区中可能包含长行时，无论如何都会被截断
。

可选参数@var{y-limit}，如果不是@code{nil}，则指定可以返回的最大像素高度。
y坐标超过@var{y-limit}的文本行将被忽略。由于计算一个大的缓冲区的像素高度可
能需要一些时间，所以指定这个参数是有意义的；尤其是当调用者不知道缓冲区的大
小时。

可选参数@var{mode-and-header-line}@code{nil}或省略表示在返回值中不包含
@var{window}的模式行或标题行的高度。如果是符号@code{mode-line}或
@code{header-line}，则在返回值中只包含该行的高度（如果存在的话）；如果是
@code{t}，则在返回值中包含两者的高度（如果存在）。
@end defun

@code{window-text-pixel-size}将窗口中显示的文本作为一个整体来处理，而不关
心单个行的大小。下面的函数则是如此。

@defun window-lines-pixel-dimensions &optional window first last body inverse left
这个函数计算指定的@var{window}中显示的每一行的像素尺寸。它的计算方法是遍历
@var{window}的当前字形矩阵--一个存储@var{window}中当前显示的每个缓冲字符
的字形(@pxref{字元})的矩阵。如果成功，它将返回一个cons对的列表，代表每行
最后一个字符的右下角的x和y坐标。坐标是以@var{window}左上角为原点(0,0)，以
像素为单位测量。@var{window}必须是一个实时窗口，默认为选定的窗口。

如果可选的参数@var{first}是一个整数，它表示要返回@var{window}的字形矩阵的第一行的索引（从0开始）。请注意，如果@var{window}有一个头行，那么索引为0的
行就是那个头行。如果@var{first}是@code{nil}，那么要考虑的第一行由可选参数
@var{body}的值决定：如果@var{body}是非@code{nil}，则意味着从@var{window}
主体的第一行开始，跳过任何头行（如果存在）。否则，这个函数将从@var{window}的字形矩阵的第一行开始，可能是头行。

如果可选的参数@var{last}是一个整数，它表示将返回@var{window}的字形矩阵的
最后一行的索引。如果@var{last}是@code{nil}，那么最后一行的索引由
@var{body}的值决定。如果@var{body}是非@code{nil}，这意味着使用
@var{window}的body的最后一行，省略@var{window}的模式行（如果存在的话）。
否则，这意味着使用@var{window}的最后一行，这可能是模式行。

可选参数@var{inverse}，如果是@code{nil}，意味着任何一行返回的y-pixel值指
定了从@var{window}的左边缘（如果@var{body}是非@code{nil}，则为主体边缘）
到该行最后一个字形的右边缘的像素距离。如果@var{inverse}是非@code{nil}意味
着任何一行返回的y-pixel值指定了从该行最后一个字形的右边缘到@var{window}的
右边缘(如果@var{body}是非@code{nil}，则为主体边缘)的距离，单位为像素。这
对于确定每行末尾的空余空间非常有用。

可选参数@var{left}，如果非@code{nil}则表示返回每行最左边字符的左下角的x和
y坐标。对于那些主要从右到左显示文字的窗口，应该使用这个值。

如果@var{left}是非@code{nil}，而@var{inverse}是@code{nil}，这意味着任何
一行返回的y-pixel值都指定了从该行最后（最左边）字形的左边缘到@var{window}
的右边缘（如果@var{body}是非@code{nil}，则为主体边缘）的像素距离。如果
@var{left}和@var{inverse}都是非@code{nil}，则任何一行返回的y-pixel值指定
了从@var{window}的左边缘（如果@var{body}是非@code{nil}，则为主体边缘）到
该行最后一个（最左）字形的左边缘的距离。

如果当前@var{window}的字形矩阵不是最新的，这个函数返回@code{nil}，这通常
发生在Emacs繁忙的时候，例如处理命令时。当这个函数在一个空闲的定时器中运行
时，其值应该是可以被检索到的，延迟时间为0秒。

@end defun

@defun line-pixel-height
此函数返回所选窗口中某点的行高度，单位为像素。此值包括了线条的行距（
@pxref{Line Height}）。
@end defun

当缓冲区显示行号时(@pxref{Display Custom,,,emacs,The GNU Emacs Manual})
，有时需要知道显示行号的宽度。下面的函数适用于需要这些信息进行布局计算的
Lisp程序。

@defun line-number-display-width &optional pixelwise
本函数返回所选窗口中用于显示行号的宽度。如果可选参数@var{pixelwise}是符号
@code{columns}，则返回值是窗帧的规范列数的浮点数；如果@var{pixelwise}是
@code{t}或其他任何非@code{nil}值，则该值是以像素为单位的整数。如果
@var{pixelwise}被省略或@code{nil}，则该值是为@code{line-number}面定义的
字体的整数列，不包括用来衬托显示数字的2列。如果行号没有在选定的窗口中显示，
那么无论@var{pixelwise}的值是多少，该值都是零。使用
@code{with-selected-window}。(@pxref{Selecting Windows})，如果您需要另一
个窗口的信息。
@end defun


@node 行高
@section Line Height
@cindex line height
@cindex height of a line

  每个显示行的总高度由行内内容的高度，加上显示行上方或下方可选的额外垂直行
距组成。

  行内容的高度是该显示行中任何字符或图像的最大高度，包括最后的换行（如果有
的话）。(一个被延续的显示行不包括最后的换行。)如果你没有指定更大的高度，这
是默认的行高。(在最常见的情况下，这等于相应框架的默认字体的高度，参见
@ref{Frame Font}。)

  有几种方法可以明确指定更大的行高，可以指定显示行的绝对高度，也可以指定垂
直空间。但是，无论您如何指定，实际的行高都不能小于默认值。

@kindex line-height @r{(text property)}
  一个新行可以有一个@code{line-height}文本或覆盖属性，控制以该新行结束的显
示行的总高度。

  如果属性值为@code{t}，换行符对行的显示高度没有任何影响--只有可见的内容才
能决定高度。下面描述的@code{line-spacing}属性在这种情况下也会被忽略。这对
于平铺小图像（或图像切片）而不在图像之间添加空白区域非常有用。

  如果属性值是一个@code{(@var{height} @var{total})}形式的列表，那就会给显
示行@emph{下}增加额外的空间。首先Emacs使用@var{height}作为高度规范来控制
行@emph{上}额外的空间；然后它增加足够的空间到行@emph{下}，来使总行高达到
@var{total}。在这种情况下，新行的@code{line-spacing}属性的任何值都会被忽
略。

@cindex height spec
  任何其他类型的属性值都是高度规格，它可以转化为一个数字---指定的行高。有
几种写入高度规格的方法，下面是每种方法如何转化为一个数字：

@table @code
@item @var{integer}
如果高度规格是一个正整数，高度值就是这个整数。
@item @var{float}
如果高度规格是浮点数，@var{float}，数字高度值是@var{float}乘以窗帧的默认
行高。
@item (@var{face} . @var{ratio})
如果高度规格是所示格式的cons，那么数字高度是@var{ratio}乘以字体@var{face}
的高度。@var{ratio}可以是任何类型的数字，也可以是@code{nil}，表示比值为1
，如果@var{face}是@code{t}，则是指当前的字体。
@item (nil . @var{ratio})
如果高度规格是所示格式的cons，则数字高度为@var{ratio}乘以行内容的高度。
@end table

  因此，任何有效的高度规格都会以像素为单位，以某种方式确定高度。如果行内容
的高度小于这个高度，Emacs会在行上面增加额外的垂直空间，以达到指定的总高度
。

  如果您没有指定@code{line-height}属性，行高由内容的高度加上行距组成。有几
种方法可以为Emacs文本的不同部分指定行距。

  在图形终端上，您可以使用@code{line-spacing}窗帧参数(
@pxref{Layout Parameters})来指定一个框架中所有行的行距，但是如果
@code{line-spacing}的默认值是非@code{nil}，则会覆盖窗帧的
@code{line-spacing}参数。一个整数，指定行下的像素数。浮点数指定相对于窗帧
默认行高的间距。

@vindex line-spacing
  你可以通过缓冲区本地@code{line-spacing}变量来指定缓冲区中所有行的行距。
一个整数指定了行下的像素数，一个浮点数指定了相对于默认帧行高的间距。浮点数
指定相对于默认帧行高的间距。这将覆盖为窗帧指定的行距。

@kindex line-spacing @r{(text property)}
  最后，一个新行可以有一个@code{line-spacing}文本或覆盖属性，它可以放大默
认的帧行距和缓冲区本地@code{line-spacing}变量：如果它的值大于缓冲区或帧的默认值，那么对于以该新行结束的显示行，将使用该较大的值。

  这些机制以一种或另一种方式为每行的间距指定一个Lisp值。该值是一个高度规格
，它转化为一个Lisp值，如上所述。然而，在这种情况下，数字高度值指定的是行间
距，而不是行高。

  在文本终端上，行距不能改变。

@node 字形
@section Faces
@cindex faces

  一个@dfn{face}是用于显示文本的图形属性的集合：字体、前景色、背景色、可选
的下划线等。字形控制Emacs如何在缓冲区中显示文本，以及窗帧的其他部分，如模式行。

@cindex anonymous face
  表示一个字形的一种方式是属性列表，比如
@code{(:foreground "red" :weight bold)}。这样的列表称为
@dfn{anonymous face}。例如，您可以指定一个匿名的字形作为@code{face}文本属
性的值，Emacs将显示具有指定属性的底层文本。@xref{Special Properties}。

@cindex face name
  更常见的是，一个面孔是通过@dfn{face name}来引用的：一个与一组字形属性相
关联的Lisp符号@footnote{为了向后兼容，你也可以使用一个字符串来指定一个字形
名；这相当于一个具有相同名称的Lisp符号}。命名的字形是使用@code{defface}宏
（@pxref{Defining Faces}）来定义的。Emacs自带了几个标准的命名面(
@pxref{基本字形})。

  Emacs的某些部分需要命名的字形（例如，在@ref{Attribute Functions}中记载
的函数）。除非另有说明，否则我们将使用@dfn{face}来表示命名的字形。

@defun facep object
如果@var{object}是一个命名的字形：一个作为字形名的Lisp符号或字符串，那么这
个函数返回一个非@code{nil}值。否则，它将返回@code{nil}值。
@end defun

@menu
* 字形属性::     什么是字形？
* 定义字形::     如何定义一个字形。
* 属性函数::     检查和设置字形属性的函数。
* 显示字形::     Emacs如何组合字符指定的字形。
* 字形重映射::   将字形重映射到其他定义。
* 字形函数::     如何定义和检查字形。
* 自动字形::     自动字形分配的钩子。
* 基本字形::     默认定义的字形。
* 字体选择::     为字形寻找最佳可用字体。
* 字体查询::     查询可用字体的名称和相关信息。
* 字体集::       字体集是指处理一系列字符集的字体的集合。
* 低级字体::     字符显示字体的Lisp表示。
@end menu

@node 字形属性
@subsection Face Attributes
@cindex face attributes
  @dfn{Face attributes}决定了字形的视觉外观。下表列出了所有的字形属性、它
们可能的值和它们的效果。

  除了下面给出的值之外，每个字形属性可以有@code{unspecified}这个值。这个特
殊的值意味着该字形没有直接指定该属性。一个@code{unspecified}属性会告诉
Emacs引用一个父字形(见下面@code{:inherit}属性的描述)；或者，如果不能引用
，则引用一个底层字形(@pxref{显示字形})。@code{default}字形必须指
定所有属性。

  其中有些属性只对某些类型的显示器有意义。如果您的显示器不能处理某个属性，
则该属性将被忽略。

@table @code
@item :family
字体族名称（字符串）。@xref{Fonts,,,emacs,The GNU Emacs Manual},可以获得
更多关于字体家族的信息。函数@code{font-family-list}。(见下文)返回一个可用
的姓氏清单。

@item :foundry
由@code{:family}属性（字符串）指定的字体系列的
@dfn{font foundry}名称。@xref{Fonts,,,emacs, The GNU Emacs Manual}。

@item :width
相对字符宽度。应该是@code{ultra-condensed}、@code{extra-condensed}、
@code{condensed}、@code{semi-condensed}、@code{normal}、
@code{semi-expanded}、@code{expanded}、@code{extra-expanded}或
@code{ultra-expanded}中的一个符号。

@item :height
字体的高度。在最简单的情况下，这是一个以1/10点为单位的整数。

该值也可以是浮点或函数，它指定了相对于@dfn{underlying face}的高度。(
@pxref{显示字形})。浮点值指定了缩放底层字形的高度的数量。调用函数
值时，只需要一个参数，即底层字形的高度，并返回新字形的高度。如果函数的参数
是整数，则必须返回一个整数。

默认字形的高度必须使用整数来指定，不允许使用浮点和函数值。

@item :weight
字体权重------@code{ultra-bold}、@code{extra-bold}、@code{bold}、
@code{semi-bold}、@code{normal}、@code{semi-light}、@code{light}、
@code{extra-light}、@code{ultra-light}中的一个符号（从最浓到最淡）。在支
持可变亮度文字的文本终端上，大于正常值的文字显示为特亮，小于正常值的文字显
示为半亮。

@cindex italic text
@item :slant
字体倾斜---@code{italic}、@code{oblique}、@code{normal}、
@code{reverse-italic}或@code{reverse-oblique}等符号之一。在支持可变亮度
文本的文本终端上，倾斜的文本显示为半亮。

@item :foreground
前景色，一个字符串。该值可以是系统定义的颜色名称，也可以是十六进制的颜色规
格。@xref{Color Names}。在黑白显示器上，某些灰度是通过点阵图案来实现的。

@item :distant-foreground
替代前景色，一个字符串。这和@code{:foreground}类似，但只有当背景色接近于本
应使用的前景色时，才会使用该颜色作为前景色。例如，在标记文本（即区域面）时
，这很有用。如果文本的前景与区域面可见，则使用该前景。如果前景在区域面背景
附近，则使用@code{:distant-foreground}来代替，这样文本就可读了。

@item :background
背景色，一个字符串。该值可以是一个系统定义的颜色名称，也可以是一个十六进制
的颜色规格。@xref{Color Names}。

@cindex underlined text
@item :underline
是否应该对字符进行下划线，以及以何种方式进行。@code{:underline}属性的可能
值是：

@table @asis
@item @code{nil}
不要下划线。

@item @code{t}
用字形的前景色下划线。

@item @var{color}
颜色下划线@var{color}，一个指定颜色的字符串。

@item @code{(:color @var{color} :style @var{style})}
@var{color}是一个字符串，或者符号@code{foreground-color}，意思是字形的前
景色。省略@code{:color}属性，表示使用字形的前景色。@var{style}应该是符号
@code{line}或@code{wave}，意思是使用直线或波浪线。省略@code{:style}属性，
表示使用直线。
@end table

@cindex overlined text
@item :overline
是否要对字符上划线，以及用什么颜色划线。如果值是@code{t}，则使用字面的前景
色。如果值是字符串，则使用该颜色进行叠加。值为@code{nil}表示不上划线。

@cindex strike-through text
@item :strike-through
字符是否应该被删除，以及用什么颜色。这个值的用法和@code{:overline}的用法一
样。

@cindex 2D box
@cindex 3D box
@item :box
是否应该在字符周围画一个方框，它的颜色，方框线的宽度，以及3D外观。以下是
@code{:box}属性的可能值，以及它们的含义:

@table @asis
@item @code{nil}
不要画一个盒子。

@item @code{t}
用前景色画一个宽度为1的线条的方框。

@item @var{color}
绘制一个宽度为1的方框，颜色为@var{color}。

@item @code{(:line-width (@var{vwidth} . @var{hwidth}) :color @var{color} :style @var{style})}
这样你就可以明确地指定盒子的所有方面。值@var{vwidth}和@var{hwidth}分别指
定要绘制的垂直线和水平线的宽度，它们默认为(1 . 1)。负的水平或垂直宽度
@minus{}@var{n}意味着要画一条宽度为@var{n}的线，占用底层文本的空间，从而
避免字符高度或宽度的增加。为了简化，宽度可以只用一个数字@var{n}来代替列表
，这种情况相当于@code{((abs @var{n}) . @var{n})}。

值@var{color}指定了要绘制的颜色。默认情况下，对于简单的方框，是字形的前景
色，对于3D方框，是字形的背景色。

值@var{style}指定是否要绘制一个3D框。如果是@code{released-button}，则该框
看起来像一个没有被按下的3D按钮。如果是@code{pressed-button}，则该框看起来
像一个正在被按下的3D按钮。如果是@code{nil}或省略，则使用普通的2D框。
@end table

@item :inverse-video
是否应该在反转视频中显示字符。该值应该是@code{t}(是)或@code{nil}(否)。

@item :stipple
背景点图，是一个位图。

值可以是一个字符串，应该是包含外部格式X位图数据的文件名。该文件在
@code{x-bitmap-file-path}变量中列出的目录中找到。

另外，也可以直接指定位图的值，其列表形式为
@code{(@var{width} @var{height} @var{data})}。这里，@var{width}和
@var{height}以像素为单位指定大小，@var{data}是一个字符串，包含位图的原始
位，一行一行的。每一行都占据了字符串中@math{(@var{width} + 7) / 8}连续的
字节（为了达到最佳效果，应该是一个单字节的字符串）。这意味着每一行至少要占
用一个完整的字节。

如果值是@code{nil}，表示不使用点图图案。

通常情况下，你不需要设置点图属性，因为它会自动用于处理某些灰度。

@item :font
用于显示字形的字体。它的值应该是一个字体对象或字体集。
@xref{Low-Level Font}，用于了解字体对象、字体规格和字体实体的信息。
@xref{Fontsets}，用于获取字体集的信息。

@anchor{face-font-attribute}
当使用@code{set-face-attribute}或@code{set-face-font}来指定这个属性时。(
@pxref{Attribute Functions})，您也可以提供一个字体规格、一个字体实体或一
个字符串。Emacs会将这些值转换为适当的字体对象，并将该字体对象存储为实际的
属性值。如果你指定的是一个字符串，字符串的内容应该是一个字体名称（
@pxref{Fonts,,,emacs,The GNU Emacs Manual}）；如果字体名称是一个包含通配
符的XLFD，Emacs会选择第一个与这些通配符匹配的字体。指定这个属性也会改变
@code{:family}、@code{:foundry}、@code{:width}、@code{:height}、
@code{:weight}和@code{:slant}属性的值。

@cindex inheritance, for faces
@item :inherit
继承属性的字形的名称，或字形名称的列表。来自继承的字形的属性会像底层字形一
样被合并到字形中，其优先级高于底层字形(@pxref{显示字形})。如果要
继承的面孔是@code{unspecified}，则与@code{nil}处理相同，因为Emacs从不合并
@code{:inherit}属性。如果使用了一个字形列表，那么列表中前面的字形的属性会
覆盖后面的字形的属性。

@item :extend
这个字形是否会被扩展到行尾之外，并影响行尾和窗口边缘之间空隙的显示。这个值
应该是@code{t}使用这个面来显示行尾和窗口边缘之间的空位，或者@code{nil}不使
用这个字形来显示行尾和窗口边缘之间的空位。当Emacs合并几个字形来显示行尾以
外的空格时，只有那些带有@code{:extension}非@code{nil}的字形会被合并。默认
情况下，只有少数字形，特别是@code{region}，有这个属性。这个属性与其他属性
不同的是，当一个主题没有为某个字形指定一个显式的值时，会继承@code{defface}
从原始字形定义中得到的值（@pxref{Defining Faces}）。

@end table

@defun font-family-list &optional frame
这个函数返回一个可用的字体家族名称列表。可选参数@var{frame}指定显示文字的
窗帧；如果是@code{nil}，则使用选定的窗帧。
@end defun

@defopt underline-minimum-offset
该变量指定了显示下划线文本时，基线和下划线之间的最小距离，单位为像素。
@end defopt

@defopt x-bitmap-file-path
这个变量为@code{:stippple}属性指定了一个用于搜索位图文件的目录列表。
@end defopt

@defun bitmap-spec-p object
如果@var{object}是有效的位图规格，则返回@code{t}，适合与@code{:stipple}一
起使用(见上文)。否则返回@code{nil}。
@end defun

@node 定义字形
@subsection Defining Faces
@cindex defining faces

@cindex face spec
  通常定义一个字形的方法是通过@code{defface}宏。这个宏将一个字形的名称（一
个符号）与一个默认的@dfn{face spec}关联起来。字形规格是一个结构，它指定了
一个字形在任何给定的终端上应该具有的属性；例如，一个字形规格可以指定在高色
终端上使用一种前景色，而在低色终端上使用不同的前景色。

  人们有时会想创建一个变量，其值是一个字形名。在绝大多数情况下，没有必要这
样做，通常的程序是用@code{defface}定义一个字形，然后直接使用它的名字。

@cindex face (non-removability of)
请注意，一旦你定义了一个字形（通常使用@code{defface}），你以后就不能安全地
取消定义这个字形，除非重新启动 Emacs。

@defmac defface face spec doc [keyword value]@dots{}
这个宏声明@var{face}为一个命名的字形，其默认字形的规格由@var{spec}提供。
您不应该引用符号@var{face}，也不应该以@samp{-face}结尾。(那就太多余了)。
参数@var{doc}是字形的文档字符串。附加的@var{keyword}参数的含义与
@code{defgroup}和@code{defcustom}相同。(@pxref{Common Keywords})。

如果@var{face}已经有一个默认的字形规格，那么这个宏就不会有任何作用。

当没有定制生效时，默认的字形规格决定了@var{face}的外观(
@pxref{Customization})。如果@var{face}已经被自定义（通过自定义主题或从
init文件中读取的自定义），它的外观由自定义的字形规格决定，它覆盖了默认的字
形规格@var{spec}。然而，如果随后删除了自定义，@var{face}的外观将再次由其默
认的字形规格决定。

@cindex @code{eval-defun}, and @code{defface} forms
作为一个例外，如果您在Emacs Lisp模式下使用@kbd{C-M-x}(@code{eval-defun})
运行@code{defface}表单，@code{eval-defun}的一个特殊的功能覆盖任何自定义的
字形规格，使字形完全反映@code{defface}的内容。

参数@var{spec}是一个@dfn{face spec}，它说明了不同类型的终端上的字形应该如
何显示。它应该是一个alist，每个元素的形式是

@example
(@var{display} . @var{plist})
@end example

@noindent
@var{display}指定了一个终端的类别（见下文）。@var{plist}是一个字形属性及
其值的属性列表，指定了字形在这些终端上的显示方式。为了向后兼容，您也可以将
一个元素写成 @code{(@var{display} @var{plist})}。

@var{spec}元素的@var{display}部分决定了该元素匹配的终端。如果@var{spec}中
有多个元素与给定的终端匹配，那么第一个匹配的元素就是用于该终端的元素。
@var{display}有三种可能:

@table @asis
@item @code{default}
@var{spec}的这个元素并不匹配任何终端，而是指定了适用于所有终端的默认值。如
果使用这个元素，它必须是@var{spec}的第一个元素。下面的每个元素都可以覆盖这
些默认值中的任何一个或全部。

@item @code{t}
@var{spec}的这个元素匹配所有的终端。因此，@var{spec}的任何后续元素都不会被
使用。通常@code{t}会被用于@var{spec}的最后一个（或唯一）元素。

@item a list
如果@var{display}是一个列表，那么每个元素的形式应该是
@code{(@var{characteristic} @var{value}@dots{})}。这里，
@var{characteristic}指定了对终端进行分类的方式，@var{value}s是
@var{display}应该适用的可能分类。以下是@var{characteristic}的可能值:

@table @code
@item type
窗口系统终端的种类使用@code{graphic}(任何可显示图形的显示器),@code{x},
@code{pc}(MS-DOS控制台)，@code{w32}(适用于MS Windows 9X/NT/2K/XP)，或
@code{tty}(非图形功能的显示器).@xref{Window Systems, window-system}.

@item class
终端支持的颜色种类---@code{color},@code{grayscale},或@code{mono}.

@item background
背景的种类---@code{light}或@code{dark}.

@item min-colors
一个整数，表示终端应该支持的最小颜色数量。如果终端的
@code{display-color-cells}值至少是指定的整数，则与之匹配。

@item supports
终端是否可以显示@var{value}@dots{}中给出的字形属性。(
@pxref{Face Attributes})。@xref{Display Face Attribute Testing}，了解
更多关于这个测试具体如何进行的信息。
@end table

如果@var{display}的一个元素为给定的@var{characteristic}指定了一个以上的
@var{value}，那么这些值中的任何一个都是可以接受的。如果@var{display}有一
个以上的元素，则每个元素都应该指定一个不同的@var{characteristic}；那么终端
的@emph{each}特性必须与@var{display}中为其指定的@var{value}之一相匹配。
@end table
@end defmac

  例如，这里是标准字形的定义@code{highlight}：

@example
(defface highlight
  '((((class color) (min-colors 88) (background light))
     :background "darkseagreen2")
    (((class color) (min-colors 88) (background dark))
     :background "darkolivegreen")
    (((class color) (min-colors 16) (background light))
     :background "darkseagreen2")
    (((class color) (min-colors 16) (background dark))
     :background "darkolivegreen")
    (((class color) (min-colors 8))
     :background "green" :foreground "black")
    (t :inverse-video t))
  "Basic face for highlighting."
  :group 'basic-faces)
@end example

  在内部，Emacs在其@code{face-defface-spec}符号属性(
@pxref{Symbol Properties})中存储了每个字形的默认规格。@code{saved-face}
属性存储了用户使用自定义缓冲区保存的任何字形规格；@code{customized-face}
属性存储了为当前会话定制的字形规格，但没有保存；@code{theme-face}属性存储
了一个将活动的自定义设置和自定义主题与该字形规格关联起来的列表。字形的文档
字符串存储在@code{face-documentation}属性中。

  通常情况下，一个字形只声明一次，使用@code{defface}，对其外观的任何进一步
更改都是使用自定义框架（例如，通过自定义用户界面或通过
@code{custom-set-faces}函数；@pxref{Applying Customizations}），或通过字
形重映射（@pxref{字形重映射}）。在极少数情况下，您需要直接从Lisp中
更改字形规格，您可以使用@code{face-spec-set}函数。

@defun face-spec-set face spec &optional spec-type
本函数将@var{spec}应用为@code{face}的字形规格。@var{spec}应该是一个字形的
规格，如上面文档中对@code{defface}的描述。

这个函数还定义了@var{face}作为有效的字形名称（如果还没有的话），并（重新）
计算现有窗帧的属性。

@cindex override spec @r{(for a face)}
可选参数@var{spec-type}决定了要设置哪个规格。如果省略了@code{nil}或
@code{face-override-spec}，这个函数将设置@dfn{override spec}，它将覆盖下
面提到的所有其他类型的@var{face}的字形规格。当在自定义代码之外调用这个函数
时，这个功能非常有用。如果@var{spec-type}是@code{customized-face}或
@code{saved-face}，这个函数将分别设置自定义的规格或保存的自定义规格。如果
是@code{face-defface-spec}，这个函数将设置默认的字形规格（与
@code{defface}设置的规格相同）。如果是@code{reset}，这个函数将清空所有自
定义的规格，并覆盖@var{face}中的规格。(在这种情况下，@var{spec}的值会被忽
略)。其他任何@var{spec-type}的值对字形的影响都是保留给内部使用的，但函数仍
然会定义@var{face}本身，并重新计算其属性，如上所述。
@end defun

@node 属性函数
@subsection Face Attribute Functions
@cindex face attributes, access and modification

  本节介绍了直接访问和修改命名面的属性的函数。

@defun face-attribute face attribute &optional frame inherit
此函数返回@var{frame}上 @var{face}的@var{attribute}属性值。

如果@var{frame}被省略或@code{nil}，则表示选定的窗帧（
@pxref{Input Focus}）。如果@var{frame}是@code{t}，这个函数将返回新创建的
窗帧的指定属性值（通常是@code{unspecified}，除非您使用
@code{set-face-attribute}指定了一些值；见下文）。

如果@var{inherit}是非@code{nil}，则只考虑@var{face}直接定义的属性，所以返
回值可能是@code{unspecified}，或者一个相对值。如果@var{inherit}是非
@code{nil}，则@var{face}对@var{attribute}的定义会与@code{:herit}属性所指
定的字形合并，但返回值可能仍然是@code{unspecified}或相对值。如果
@var{inherit}是一个字形或一个字形的列表，那么结果将进一步与该字形（或多个
字形）合并，直到它成为指定的和绝对的。

为了确保返回值始终是指定的和绝对的，对@var{inherit}使用@code{default}的值
；这将通过与@code{default}面（始终是完全指定的）合并来解决任何未指定或相对
值。

例如,

@example
(face-attribute 'bold :weight)
     @result{} bold
@end example
@end defun

@c FIXME:增加一个"相对面属性"的索引，也许在这里？--xfq
@defun face-attribute-relative-p attribute value
如果@var{value}作为字形属性@var{attribute}的值是相对的，那么这个函数返回
非@code{nil}。这意味着它将修改而不是完全覆盖任何来自于字形列表中后续字形的
值，或者是继承自其他字形的值。

对于所有属性来说，@code{:unspecified}是一个相对值。对于@code{:height}，浮
点和函数值也是相对的。

例如：

@example
(face-attribute-relative-p :height 2.0)
     @result{} t
@end example
@end defun

@defun face-all-attributes face &optional frame
这个函数返回一个@var{face}的属性列表。结果中的元素是名称-值对，其形式为
@w{@code{(@var{attr-name} . @var{attr-value})}}。可选参数@var{frame}指
定要返回@var{face}定义的框架；如果省略或@code{nil}，则返回的值描述了
@var{face}对新创建窗帧的默认属性。
@end defun

@defun merge-face-attribute attribute value1 value2
如果@var{value1}是字形属性@var{attribute}的相对值，则返回它与底层值
@var{value2}合并；否则，如果@var{value1}是字形属性@var{attribute}的绝对
值，则返回@var{value1}不变。
@end defun

  通常情况下，Emacs会使用每个面的规格来自动计算每个窗帧的属性（
@pxref{Defining Faces}）。函数@code{set-face-attribute}可以覆盖这种计算
方式，直接将属性分配给一个字形，无论是在特定的窗帧上还是在所有窗帧上。这个
函数主要用于内部使用。

@defun set-face-attribute face frame &rest arguments
此函数为@var{frame}设置@var{face}的一个或多个属性。这些属性覆盖了
@var{face}的字形规格。

额外的参数@var{arguments}指定了要设置的属性，以及它们的值，它们应该由要替
代的属性名（如@code{:family}或@code{:underline}）和值组成。因此，

@example
(set-face-attribute 'foo nil :weight 'bold :slant 'italic)
@end example

@noindent
将属性@code{:weight}设置为@code{bold}，将属性@code{:slant}设置为
@code{italic}。

如果@var{frame}是@code{t}，这个函数为新创建的窗帧设置默认属性，如果
@var{frame}是@code{nil}，这个函数为所有现有的窗帧以及新创建的窗帧设置属性
。如果@var{frame}为@code{nil}，则此函数为所有现有的窗帧以及新创建的窗帧设
置默认属性。
@end defun

  下面的命令和函数主要提供了与旧版本Emacs的兼容性。它们通过调用
@code{set-face-attribute}工作。@var{frame}参数的@code{t}和@code{nil}(或
省略)的值的处理方式与@code{set-face-attribute}和@code{face-attribute}一
样。如果是交互式调用的话，这些命令会使用minibuffer读取参数。

@deffn Command set-face-foreground face color &optional frame
@deffnx Command set-face-background face color &optional frame
这些设置将@var{face}的@code{:foreground}属性（或@code{:background}属性，
相对地）设置为@var{color}。
@end deffn

@deffn Command set-face-stipple face pattern &optional frame
这将@var{face}的@code{:stippple}属性设置为@var{pattern}。
@end deffn

@deffn Command set-face-font face font &optional frame
将@var{face}的字体相关属性改为@var{font}（一个字符串或字体对象）的相关属性
。@xref{face-font-attribute}，用于@var{font}参数的支持格式。这个函数设置
字体的属性@code{:font}，并间接设置字体定义的@code{:family}、
@code{:foundry}、@code{:width}、@code{:height}、@code{:weight}和
@code{:slant}属性。如果@var{frame}是非@code{nil}，则只改变指定窗帧的属性
。
@end deffn

@defun set-face-bold face bold-p &optional frame
如果@var{bold-p}是@code{nil}，则将@var{face}的@code{:weight}属性设置为
@var{normal}，否则设置为@var{bold}。
@end defun

@defun set-face-italic face italic-p &optional frame
如果@var{italic-p}是@code{nil}，则设置@var{face}的@code{:slant}属性为
@var{normal}，否则为@var{italic}。
@end defun

@deffn Command set-face-underline face underline &optional frame
这将@var{face}的@code{:underline}属性设置为@var{underline}。
@end deffn

@deffn Command set-face-inverse-video face inverse-video-p &optional frame
这将@var{face}的@code{:inverse-video}属性设置为@var{inverse-video-p}。
@end deffn

@deffn Command invert-face face &optional frame
这将交换字形@var{face}的前景色和背景色。
@end deffn

@deffn Command set-face-extend face extend &optional frame
这将@var{face}的@code{:extend}属性设置为@var{extend}。
@end deffn

  下面的函数检查一个字形的属性，它们主要提供了与旧版本Emacs的兼容性。它们
主要提供了与旧版本Emacs的兼容性。如果你没有指定@var{frame}，它们会指向所选
的窗帧；@code{t}指向新窗帧的默认数据。如果面没有为该属性定义任何值，它们会
返回@code{unspecified}。如果@var{inherit}是@code{nil}，则只返回一个由字
形直接定义的属性。如果@var{inherit}是非@code{nil}，那么由@code{:inherit}
属性指定的任何字形也会被考虑，如果@var{inherit}是一个字形或一个字形列表，
那么它们也会被考虑，直到找到一个指定的属性。为了确保返回值始终是指定的，请
为@var{inherit}使用@code{default}的值。

@defun face-font face &optional frame character
此函数返回字形@var{face}的字体名称。

如果指定了可选的参数@var{frame}，则返回该帧的@var{face}的字体名称。如果省
略了@var{frame}或@code{nil}，则使用选定的窗帧。在后一种情况下，如果提供了
可选的第三个参数@var{character}，则返回用于@var{character}的字体名称。
@end defun

@defun face-foreground face &optional frame inherit
@defunx face-background face &optional frame inherit
这些函数以字符串的形式返回字形@var{face}的前景色（或背景色）。如果没有指定
颜色，则返回@code{nil}。
@end defun

@defun face-stipple face &optional frame inherit
此函数返回面孔的背景图案名称@var{face}，如果没有，则返回@code{nil}。
@end defun

@defun face-bold-p face &optional frame inherit
如果@var{face}的@code{:weight}属性比正常情况下更粗（即@code{semi-bold}、
@code{bold}、@code{extra-bold}或@code{ultra-bold}中的一个），则该函数返
回一个非@code{nil}值。否则，它将返回@code{nil}。
@end defun

@defun face-italic-p face &optional frame inherit
如果@var{face}的@code{:slant}属性为@code{italic}或@code{oblique}，则该函
数返回一个非@code{nil}值，否则返回@code{nil}。
@end defun

@defun face-underline-p face &optional frame inherit
如果字形@var{face}指定了一个非@code{nil}的@code{:underline}属性，则该函数
返回非@code{nil}。
@end defun

@defun face-inverse-video-p face &optional frame inherit
如果字形@var{face}指定了一个非@code{nil}的@code{:inverse-video}属性，则
该函数返回非@code{nil}。
@end defun

@defun face-extend-p face &optional frame
如果字形@var{face}指定了一个非@code{nil}的@code{:extension}属性，则该函数
返回非@code{nil}。
@end defun


@node 显示字形
@subsection Displaying Faces
@cindex displaying faces
@cindex face merging

  当Emacs显示一段给定的文本时，文本的视觉外观可能由来自不同来源的字形决定
。如果这些不同的来源为一个特定的字符指定了多个字形，Emacs会合并不同字形的属性。以下是Emacs合并字形的顺序，从最高优先级到最低优先级:

@itemize @bullet
@item
如果文本由一个特殊的字形组成，则该字形可以指定一个特定的字形。@xref{字元}.

@item
如果文本位于活动区域内，Emacs会使用@code{region}面来高亮它。
@xref{Standard Faces,,,emacs, The GNU Emacs Manual}.

@item
如果文本位于一个非@code{nil}的@code{face}属性的覆盖范围内，Emacs就会应用
该属性所指定的字形。如果覆盖有@code{mouse-face}属性，并且鼠标离覆盖足够近
，Emacs会应用@code{mouse-face}属性指定的字形或字形属性。
@xref{Overlay Properties}。

当多个叠加覆盖一个字符时，优先级较高的叠加会覆盖优先级较低的叠加。
@xref{Overlays}.

@item
如果文本包含@code{face}或@code{mouse-face}属性，Emacs会应用指定的字形和字
形属性。@xref{Special Properties}。(字体锁定模式的面孔就是这样应用的。
@xref{Font Lock Mode}.)

@item
如果文字位于所选窗口的模式线内，Emacs应用@code{mode-line}字形。对于非选择
窗口的模式行，Emacs应用@code{mode-line-inactive}字形。对于页眉行，Emacs应
用@code{header-line}字形。对于标签行，Emacs应用@code{tab-line}字形。

@item
如果文本通过@code{before-string}或@code{after-string}属性(
@pxref{Overlay Properties})来自覆盖字符串，或来自显示字符串(
@pxref{Other Display Specs})，而该字符串并不包含@code{face}或
@code{mouse-face}属性，或者这些属性没有定义一些字形的属性，但受覆盖/显示属
性影响的缓冲区文本确实定义了一个字形或这些属性，Emacs就会应用“下层”缓冲区
文本的字形属性。请注意，即使覆盖或显示字符串显示在显示边距中，也是如此(
@pxref{显示边距})。

@item
如果在前面的步骤中没有指定任何给定的属性，Emacs会应用@code{default}字形的
属性。
@end itemize

  在每个阶段，如果一个字形有一个有效的@code{:inherit}属性，Emacs会将任何
具有@code{unspecified}值的属性视为具有来自父字形的相应值。
@pxref{Face Attributes}。请注意，父字形也可以不指定该属性，在这种情况下，
该属性在下一层次的面合并中仍未指定。

@node 字形重映射
@subsection Face Remapping
@cindex face remapping

  变量@code{face-remapping-alist}用于在缓冲区局部或全局改变一个字形的外观
。例如，它被用来实现@code{text-scale-adjust}命令(
@pxref{Text Scale,,,emacs, The GNU Emacs Manual})。

@defvar face-remapping-alist
这个变量的值是一个alist，其元素的形式是
@code{(@var{face} . @var{remapping})}。这将导致Emacs用@var{face}来显示
任何带有@var{face}字形的文本，而不是普通的@var{face}的定义。

@var{remapping}可以是任何适合@code{face}文本属性的字形规格：可以是一个字
形（即一个字形名或属性/值对的属性列表），也可以是一个字形列表。详情请参见
@ref{Special Properties}中对@code{face}文本属性的描述。@var{remapping}
是重映射面的完整规范----它取代了@var{face}的正常定义，而不是修改它。

如果@code{face-remapping-alist}是缓冲区本地的，那么它的局部值只在该缓冲区
内生效。如果@code{face-remapping-alist}包含了只适用于特定窗口的字形，那么
通过使用
@w{@code{(:filtered (:window @var{param} @var{val}) @var{spec})}}，字形
只在符合过滤条件的窗口中生效 (@pxref{Special Properties})。要暂时关闭字形
过滤，请将@code{face-filters-always-match}绑定到一个非@code{nil}的值，然
后所有的字形过滤器将匹配任何窗口。

注意：字形重映射是非递归的。如果@var{remapping}直接或通过@var{remapping}
中其它字形的@code{:inherit}属性引用了相同的字形名@var{face}，那么这个引用
将使用@var{face}的正常定义。例如，如果@code{modine-line}字形是使用
@code{face-remapping-alist}中的这个条目进行重映射的:

@example
(mode-line italic mode-line)
@end example

@noindent
那么新定义的@code{modine-line}字形就继承了@code{italic}字形，而
@emph{normal}字形则继承了@code{style}字形(非重映射的)@code{modine-line}
字形的定义。
@end defvar

@cindex relative remapping, faces
@cindex base remapping, faces
  下面的函数实现了@code{face-remapping-alist}的一个更高级别的接口，大多
数Lisp代码应该使用这些函数，而不是直接设置@code{face-remapping-alist}，以
避免践踏应用在其他地方的重映射。这些函数是用于缓冲区局部重映射的，所以它们
都会让@code{face-remapping-alist}成为缓冲区局部的副作用。它们管理
@code{face-remapping-alist}的形式

@example
  (@var{face} @var{relative-spec-1} @var{relative-spec-2} @var{...} @var{base-spec})
@end example

@noindent
其中，如上所述，@var{relative-spec-N}和@var{base-spec}中的每一个都是一个
字形名，或者是一个属性/值对的属性列表。@dfn{relative remapping}中的每一个
条目，@var{relative-spec-N}都由@code{face-remap-add-relative}和
@code{face-remap-remove-relative}函数管理；这些函数用于简单的修改，比如改
变文本大小。@dfn{base remapping}条目，@var{base-spec}，优先级最低，由
@code{face-remap-set-base}和@code{face-remap-reset-base}函数管理；它是
为了主要模式在其控制的缓冲区中重映射字形。

@defun face-remap-add-relative face &rest specs
这个函数将@var{specs}中的字形参数添加到当前缓冲区中的@var{face}中，作为字
形的相对重映射。其余的参数@var{specs}应该是一个字形名称列表，或者是一个属
性/值对的属性列表。

返回值是一个作为cookie的Lisp对象，如果以后需要删除重映射，可以将这个对象作
为参数传递给@code{face-remap-remove-relative}。

@example
;; Remap the 'escape-glyph' face into a combination
;; of the 'highlight' and 'italic' faces:
(face-remap-add-relative 'escape-glyph 'highlight 'italic)

;; Increase the size of the 'default' face by 50%:
(face-remap-add-relative 'default :height 1.5)
@end example
@end defun

@defun face-remap-remove-relative cookie
这个函数删除了之前由@code{face-remap-add-relative}添加的相对重映射。
@var{cookie}应该是@code{face-remap-add-relative}在添加相对重映射时返回的
Lisp对象。
@end defun

@defun face-remap-set-base face &rest specs
这个函数将当前缓冲区中@var{face}的基本重映射设置为@var{specs}。如果
@var{specs}为空，则恢复默认的基础重映射，类似于调用
@code{face-remap-reset-base}。(见下文)；请注意，这与@var{specs}包含一个
单一的值@code{nil}不同，后者的结果正好相反（@var{face}的全局定义被忽略）。

这将覆盖默认的@var{base-spec}，后者继承了全局的字形定义，所以如果需要的话
，由调用者来添加这种继承。
@end defun

@defun face-remap-reset-base face
此函数将@var{face}的基本重映射设置为默认值，默认值继承自@var{face}的全局定
义。
@end defun

@node 字形函数
@subsection Functions for Working with Faces

  以下是用于创建和处理字形的附加功能。

@defun face-list
该函数返回所有已定义的字形名列表。
@end defun

@cindex face number
@cindex face property of face symbols
@defun face-id face
这个函数返回@var{face}的@dfn{face number}。这是在Emacs中唯一标识一个字形
的数字。很少有必要用它的字形数来表示一个字形。然而，操作字形的函数，如
@code{make-glyph-code}和@code{glyph-face}。(@pxref{字元})内部访问字形
号。请注意，字形数是作为字形符号的@code{face}属性的值来存储的，所以我们建
议不要将面的该属性设置为自己的任何值。
@end defun

@defun face-documentation face
此函数返回字形的文档字符串@var{face}，如果没有指定，则返回@code{nil}。
@end defun

@defun face-equal face1 face2 &optional frame
如果@var{face1}和@var{face2}的显示属性相同，则返回@code{t}。
@end defun

@defun face-differs-from-default-p face &optional frame
如果字形@var{face}的显示方式与默认字形不同，则返回非@code{nil}。
@end defun

@cindex face alias
@cindex alias, for faces
一个@dfn{face alias}提供了一个等价的字形名称，您可以通过给
@code{face-alias}属性定义一个字形的别名，并赋予目标字形名称的值。下面的例
子让@code{modeline}成为@code{modline}字形的别名。

@example
(put 'modeline 'face-alias 'mode-line)
@end example

@defmac define-obsolete-face-alias obsolete-face current-face when
这个宏定义了@code{obsolete-face}作为@var{current-face}的别名，并将其标记
为过时，表示将来可能会被删除。@var{when}应该是一个字符串，表示
@code{obsolete-face}什么时候被淘汰的（通常是一个版本号字符串）。
@end defmac

@node 自动字形
@subsection Automatic Face Assignment
@cindex automatic face assignment
@cindex faces, automatic choice

  这个钩子用于自动为缓冲区中的文本分配面。它是实现Jit-Lock模式的一部分，被
Font-Lock使用。

@defvar fontification-functions
这个变量保存了Emacs重绘需要在重新显示之前调用的函数列表，在重绘之前。即使
在没有启用Font Lock Mode的情况下，这些函数也会被调用。当启用字体锁定模式时
，这个变量通常只保留一个函数，@code{jit-lock-function}。

这些函数的调用顺序是按照所列的顺序进行的，只有一个参数，即缓冲区位置
@var{pos}。所有函数都会尝试从@var{pos}开始为当前缓冲区中的文本分配面。

函数应该通过设置@code{face}属性来记录它们分配的字形。它们还应该添加一个非
@code{nil}属性。@code{fontified}属性为他们已分配给所有文本的字形。该属性
告诉重新显示已经为该文本分配了字形。

如果@var{pos}后面的字符已经有一个非@code{nil}的字符，那么函数不做任何操作
可能是个好主意。@code{fontified}属性，但这不是必须的。如果一个函数覆盖了前
一个函数的赋值，那么最后一个函数完成后的属性才是真正重要的。

为了提高效率，我们建议编写这些函数，使它们通常在每次调用时为大约400到600个
字符分配字形。
@end defvar

@node 基本字形
@subsection Basic Faces
@cindex basic faces

如果你的Emacs Lisp程序需要给文本分配一些字形，通常情况下，使用某些现有的字
形或从它们那里继承字形，而不是定义全新的字形是一个好主意。这样一来，如果其
他用户已经定制了基本的字形来给Emacs提供某种外观，你的程序将无需额外的定制
就能适应。

下面列出了Emacs中定义的一些基本字形。除此以外，如果高亮显示还没有被Font
Lock模式处理，或者一些Font Lock字形没有被使用，您可能会想使用Font
Lock字形来进行语法高亮显示。@xref{Faces for Font Lock}。

@table @code
@item default
默认字形，其属性都是指定的。所有其他的字形都隐含地继承了它的属性：任何未指
定的属性都默认为这个字形的属性 (@pxref{Face Attributes})。

@item bold
@itemx italic
@itemx bold-italic
@itemx underline
@itemx fixed-pitch
@itemx fixed-pitch-serif
@itemx variable-pitch
这些属性由它们的名字来表示（例如，@code{bold}有一个粗体的@code{:weight}属
性），其他的属性都没有指定（所以由@code{default}给出）。

@item shadow
用于被遮挡的文本。例如，它用于minibuffer中文件名的忽略部分（
@pxref{Minibuffer File,,Minibuffers for File Names,emacs,The GNU Emacs
Manual}）。

@item link
@itemx link-visited
对于可点击的文本按钮，将用户发送到不同的缓冲区或位置。

@item highlight
用于应该暂时突出的文本延伸。例如，它通常被分配给@code{mouse-face}属性，用
于光标高亮（@pxref{Special Properties}）。

@item match
@itemx isearch
@itemx lazy-highlight
用于文本匹配（分别是）永久搜索匹配、交互式搜索匹配和懒惰高亮当前交互式匹配
之外的其他匹配。

@item error
@itemx warning
@itemx success
用于有关错误、警告或成功的文本。例如，这些文字用于@file{*Compilation*}缓冲
区中的信息。
@end table

@node 字体选择
@subsection Font Selection
@cindex font selection
@cindex selecting a font

  在Emacs在图形显示上绘制一个字符之前，它必须为该字符选择一个@dfn{font}
@footnote{在此上下文中，术语@dfn{font}与字体锁定（
@pxref{Font Lock Mode}）无关。}
@xref{Fonts,,, emacs, The GNU Emacs Manual}。通常情况下，Emacs会根据分配
给该字符的字形自动选择字体--特别是字形属性@code{:family}、@code{:weight}
、@code{:slant}和@code{:width}。(@pxref{Face Attributes})。字体的选择也
取决于要显示的字符；有些字体只能显示有限的字符集。如果没有可用的字体完全符
合要求，Emacs就会寻找@dfn{closest matching font}。本节中的变量可以控制
Emacs如何进行这种选择。

@defopt face-font-family-alternatives
如果一个给定的字体族被指定了，但它不存在，这个变量就会指定要尝试的其他字库
。每个元素都应该有这种形式:

@example
(@var{family} @var{alternate-families}@dots{})
@end example

如果指定@var{family}，但不可用，Emacs会逐个尝试@var{alternate-families}
中给出的其他字体族，直到找到一个确实存在的字体族。
@end defopt

@defopt face-font-selection-order
如果没有与所有所需的字形属性（@code{:width}、@code{:height}、
@code{:weight}和@code{:slant}）完全匹配的字体，这个变量指定了在选择最接近
的匹配字体时应该考虑这些属性的顺序。该值应该是一个包含这四个属性符号的列表
，按重要性递减的顺序排列。默认值是
@code{(:width :height :weight :slant)}。

字体选择首先找到列表中第一个属性的最佳可用匹配；然后，在该方式最佳的字体中
，搜索第二个属性的最佳匹配，以此类推。

属性@code{:weight}和@code{:width}的符号值范围是以@code{normal}为中心。较
极端的匹配（离@code{normal}较远）比较不极端的匹配（离@code{normal}较近）
更受欢迎；这是为了确保非正常字形与正常字形尽可能形成对比。

这个变量发挥作用的一个例子是，当默认字体没有等效的斜体时。在默认的排序下，
@code{italic}面将使用与默认字体相似的非斜体字体。但是如果您将
@code{:slant}放在@code{:height}之前，@code{italic}字形将使用斜体字体，即
使它的高度不太合适。
@end defopt

@defopt face-font-registry-alternatives
如果指定了一个给定的注册表并且不存在，这个变量可以让你指定其他的字体注册表
来尝试。每个元素都应该有这种形式:

@example
(@var{registry} @var{alternate-registries}@dots{})
@end example

如果指定了@var{registry}但没有可用的注册表，Emacs会逐个尝试
@var{alternate-registries}中给出的其他注册表，直到找到一个确实存在的注册
表。
@end defopt

@cindex scalable fonts
  Emacs可以使用可扩展的字体，但默认情况下它不使用这些字体。

@defopt scalable-fonts-allowed
这个变量控制使用哪种可伸缩字体。默认值@code{nil}表示不使用可伸缩字体。
@code{t}表示使用任何适合文本的可伸缩字体。

否则，该值必须是一个正则表达式的列表。然后，如果可扩展字体的名称与列表中的
任何正则表达式相匹配，则启用可扩展字体以供使用。例如,

@example
(setq scalable-fonts-allowed '("iso10646-1$"))
@end example

@noindent
允许使用注册表@code{iso10646-1}的可扩展字体。
@end defopt

@defvar face-font-rescale-alist
这个变量指定某些字形的缩放比例。它的值应该是一个元素列表，其形式是

@example
(@var{fontname-regexp} . @var{scale-factor})
@end example

如果@var{fontname-regexp}与即将使用的字体名称相匹配，这就说明要根据
@var{scale-factor}这个因子选择更大的类似字体。如果某些字体比其标称的高度和
宽度大或小，您可以使用这个功能来规范字体大小。
@end defvar

@node 字体查询
@subsection Looking Up Fonts
@cindex font lookup
@cindex looking up fonts

@defun x-list-fonts name &optional reference-face frame maximum width
这个函数返回与@var{name}匹配的可用字体名称列表。@var{name}应该是一个包含字
体名称的字符串，其格式为Fontconfig、GTK+或XLFD格式（
@pxref{Fonts,,,emacs,The GNU Emacs Manual}）。在XLFD字符串中，可以使用通
配符：@samp{*}字符匹配任何子串，@samp{?}字符匹配任何单个字符。匹配字体名称
时，忽略大小写。

如果指定了可选的参数@var{reference-face}和@var{frame}，则返回的列表只包括
与@var{reference-face}大小相同的字体。(字形名称)当前在框架@var{frame}上。

可选参数@var{maximum}设置了返回字体的数量限制。如果它是非@code{nil}，那么
返回值会在第一个@var{maximum}匹配字体之后被截断。为@var{maximum}指定一个
小值可以使这个函数在许多字体匹配模式的情况下变得更快。

可选参数@var{width}指定了一个所需的字体宽度，如果它是非@code{nil}，则函数
只返回那些字符宽度为@var{width}倍的字体。如果参数为非@code{nil}，则函数只
返回字符宽度为(平均)@var{width}倍@var{reference-face}的字体。
@end defun

@defun x-family-fonts &optional family frame
此函数返回一个列表，描述@var{family}家族在@var{frame}上的可用字体。如果
@var{family}被省略或是@code{nil}，那么这个列表适用于所有的字体家族，因此
，它包含了所有可用的字体，否则，@var{family}必须是一个字符串。否则，
@var{family} 必须是一个字符串；它可能包含通配符@samp{?}和@samp{*}。

该列表描述了@var{frame}所处的显示；如果@var{frame}被省略或@code{nil}，则
适用于所选窗帧的显示（@pxref{Input Focus}）。

列表中的每个元素都是以下形式的向量:

@example
[@var{family} @var{width} @var{point-size} @var{weight} @var{slant}
 @var{fixed-p} @var{full} @var{registry-and-encoding}]
@end example

前五个元素对应的是字形属性，如果你为一个字形指定了这些属性，它就会使用这个
字体。

最后三个元素给出了关于字体的附加信息。如果字体是固定间距的,@var{fixed-p}是
非@code{nil}。@var{full}是字体的全名，@var{registry-and-encoding}是一个
字符串，给出字体的注册和编码。
@end defun

@node 字体集
@subsection Fontsets
@cindex fontset

一个@dfn{fontset}是一个字体的列表，每个字体都被分配到一个字符代码的范围。
单个字体不能显示Emacs支持的全部字符范围，但字体集可以。正如字体一样，字体
集也有名称，当你为一个框架或一个面指定字体时，你可以使用字体集的名称来代替
字体名称。下面是关于在Lisp程序控制下定义字体集的信息:

@smallexample
@var{fontpattern}, @r{[}@var{charset}:@var{font}@r{]@dots{}}
@end smallexample

@noindent
忽略逗号前后的空白字符。

字符串的第一部分，@var{fontpattern}，应该是标准X字体名称的形式，但最后两个
字段应该是@samp{fontset-@var{alias}}。

新的字体集有两个名字，一个是长名，一个是短名。长名是@var{fontpattern}的全
部内容。短名是@samp{fontset-@var{alias}}。您可以通过以下两种名称来引用字
体集。如果已经存在一个同名的字体集，则会发出错误信号，除非@var{noerror}是
非@code{nil}，在这种情况下，这个函数什么都不做。

如果可选参数@var{style-variant-p}是非@code{nil}，那就说要把字体集的粗体、
斜体和粗体-黑体变体也创建出来。这些变体字体集没有短名，只有长名，通过改变
@var{fontpattern}来表示粗体和/或斜体状态。

规格字符串还说了要在字体集中使用哪些字体。详情请看下文。
@end defun

  构造@samp{@var{charset}:@var{font}}指定了一个特定字符集要使用的字体（在
这个字体集中）。这里，@var{charset}是一个字符集的名称，@var{font}是该字符
集要使用的字体。您可以在规范字符串中任意多次使用这个构造。

  对于其余的字符集，也就是那些你没有明确指定的字符集，Emacs会根据
@var{fontpattern}来选择字体：它取代了@samp{fontset-@var{alias}}，其值为
一个字符集。对于@acronym{ASCII}字符集，@samp{fontset-@var{alias}}用
@samp{ISO8859-1}代替。

  此外，当几个连续的字段是通配符时，Emacs会将它们折叠成一个通配符。这是为
了防止使用自动缩放的字体。通过缩放较大的字体制作的字体不能用于编辑，而缩放
较小的字体也没有用，因为最好使用较小字体的自身大小，Emacs就是这样做的。

  因此，如果@var{fontpattern}是这个,

@example
-*-fixed-medium-r-normal-*-24-*-*-*-*-*-fontset-24
@end example

@noindent
@acronym{ASCII}字符的字体规范是这样的:

@example
-*-fixed-medium-r-normal-*-24-*-ISO8859-1
@end example

@noindent
而中文GB2312字符的字体规范是这样的:

@example
-*-fixed-medium-r-normal-*-24-*-gb2312*-*
@end example

  您可能没有任何符合上述字体规范的中文字体。大多数X发行版只包含在
@var{family}字段中含有@samp{宋体}或@samp{方宋体}的中文字体。在这种情况下
，@samp{Fontset-@var{n}}可以按如下方式指定:

@smallexample
Emacs.Fontset-0: -*-fixed-medium-r-normal-*-24-*-*-*-*-*-fontset-24,\
        chinese-gb2312:-*-*-medium-r-normal-*-24-*-gb2312*-*
@end smallexample

@noindent
那么，除中文GB2312字外，其他字的字体规格都有在@var{family}字段中的
@samp{fixed}，以及字体规范中的中文GB2312字符在@var{family}字段中有一个通
配符 @samp{*}。

@defun set-fontset-font name character font-spec &optional frame add
此函数修改了现有的字体集@var{name}，使其与指定了@var{character}的
@var{font-spec}的字体匹配。

如果@var{name}是@code{nil}，则该函数修改所选框架的字体集；如果@var{frame}
不是@code{nil}，则修改@var{frame}的字体集。

如果@var{name}是@code{t}，则此函数将修改默认字体集，其简称为
@samp{fontset-default}。

除了指定一个单一的代码点之外，@var{character}也可以是一个cons
@code{(@var{from} . @var{to})}，其中@var{from}和@var{to}是字符代码点。在
这种情况下，使用@var{font-spec}来表示@var{from}和@var{to}(包括)范围内的所
有字符。

@var{character}可能是一个字符集(@pxref{Character Sets})。在这种情况下，
使用@var{font-spec} 来表示该字符集中的所有字符。

@var{character}可能是一个脚本名称（@pxref{Character Properties}）。在这
种情况下，使用@var{font-spec}来表示属于脚本的所有字符。

@var{character}可以是@code{nil}，也就是说，对于没有指定字体规格的字符，可
以使用@var{font-spec}。

@var{font-spec}可以是一个由函数@code{font-spec}创建的字体规格对象。(
@pxref{Low-Level Font})。

@var{font-spec}可以是一个cons; @code{(@var{family} . @var{registry})}，
其中@var{family}是一个字体的家族名（可能在头部包括一个厂商名），
@var{registry}是一个字体的注册名（可能在尾部包括一个编码名）。

@var{font-spec}可以是一个字体名称，一个字符串。

@var{font-spec}可以是@code{nil}，它明确地指定了指定的@var{character}没有
字体。这很有用，例如，可以避免在整个系统中为没有字型的字符搜索昂贵的字体，
比如那些来自Unicode专用区（PUA）的字符。

可选参数@var{add}，如果是非@code{nil}，则指定如何将@var{font-spec}添加到
之前设置的字体规格中。如果是@code{prepend}，则@var{font-spec}会被预先添加
。如果是@code{append}，则会将@var{font-spec}添加到后面。默认情况下，
@var{font-spec}会覆盖之前的设置。

例如，这就改变了默认的字体集，将属于字符集@code{japanese-jisx0208}的所有
字符使用@samp{Kochi Gothic}的字体。

@smallexample
(set-fontset-font t 'japanese-jisx0208
                  (font-spec :family "Kochi Gothic"))
@end smallexample
@end defun

@defun char-displayable-p char
如果Emacs应该能够显示@var{char}，这个函数返回@code{t}。更准确的说，如果所
选框架的字体集有一个字体可以显示@var{char}所属的字符集，则返回@code{t}。

字体集可以在每个字符的基础上指定字体；当字体集这样做时，这个函数的值可能不
准确。
@end defun

@node 低级字体
@subsection Low-Level Font Representation
@cindex font property

  通常情况下，不需要直接操作字体。如果您需要这样做，本节将解释如何操作。

  在Emacs Lisp中，字体是用三种不同的Lisp对象类型来表示的，分别是
@dfn{font objects}、@dfn{font specs}和@dfn{font entities}。

@defun fontp object &optional type
如果@var{object}是一个字体对象、字体规格或字体实体，则返回@code{t}。否则，
返回@code{nil}。

可选参数@var{type}，如果不是@code{nil}，则决定要检查的Lisp对象的确切类型
。在这种情况下，@var{type}应该是@code{font-object}、@code{font-spec}或
@code{font-entity}中的一个。
@end defun

@cindex font object
  字体对象是一个Lisp对象，表示Emacs所拥有@dfn{opened}的字体。在Lisp中不能
修改字体对象，但可以被检查。

@defun font-at position &optional window string
返回用于在@var{position}窗口中显示@var{window}位置上的字符的字体对象，如
果@var{window}是@code{nil}，则默认为选定的窗口。如果@var{string}是
@code{nil}，则@var{position}指定当前缓冲区中的一个位置；否则，
@var{string}应该是一个字符串，@var{position}指定该字符串中的一个位置。
@end defun

@cindex font spec
  字体规格是一个Lisp对象，它包含了一组可用于查找字体的规格。在一个字体规格
中，可能有一个以上的字体与之匹配。

@defun font-spec &rest arguments
使用@var{arguments}中的规格返回一个新的字体规格，它应该以
@code{property}-@code{value}对的形式出现。可能的字体规格如下:

@table @code
@item :name
字体名称（字符串），可以是XLFD、Fontconfig或GTK+格式。
@xref{Fonts,,,emacs, The GNU Emacs Manual}。

@item :family
@itemx :foundry
@itemx :weight
@itemx :slant
@itemx :width
这些与同名的字形属性具有相同的含义。@xref{Face Attributes}。
@code{:family}和@code{:foundry}是字符串，而其他三个是符号。作为示例值，
@code{:slant}可以是@code{italic}，@code{:weight}可以是@code{bold}，
@code{:width}可以是@code{normal}。

@item :size
字体大小——指定像素大小的非负整数，或指定点大小的浮点数。

@item :adstyle
字体的附加排版风格信息，如@samp{sans}。该值应该是一个字符串或符号。

@cindex font registry
@item :registry
字体的字符集注册表和编码，如@samp{iso8859-1}。该值应为字符串或符号。

@item :script
字体必须支持的文字（符号）。

@item :lang
字体应该支持的语言。该值应该是一个符号，其名称是两个字母的ISO-639语言名称
。在X上，如果字体的XLFD名称中的"附加样式"字段是非空的，则该值与之匹配。在
MS-Windows上，需要匹配规范的字体来支持语言所需的代码页。目前，只有一小部分
中日韩语言支持这个属性：@samp{ja}、@samp{ko}和@samp{zh}。

@item :otf
@cindex OpenType font
字体必须是支持这些OpenType特性的OpenType字体，前提是Emacs要用一个库来编译
，如在GNU/Linux上的@samp{libotf}，支持复杂的文本布局以满足脚本的需要。值
必须是一个列表，其形式为

@smallexample
@code{(@var{script-tag} @var{langsys-tag} @var{gsub} @var{gpos})}
@end smallexample

其中@var{script-tag}是OpenType脚本标签符号；@var{langsys-tag}是OpenType
语言系统标签符号，或者@code{nil}使用默认的语言系统；@code{gsub}是OpenType
GSUB特征标签符号的列表，如果不需要，则@code{nil}；@code{gpos}是OpenType
GPOS特征标签符号的列表，如果不需要，则@code{nil}。如果@code{gsub}或
@code{gpos}是一个列表，则该列表中的@code{nil}元素意味着字体必须不与任何其
余的标签符号匹配。可以省略@code{gpos}元素。
@end table
@end defun

@defun font-put font-spec property value
将字体规格@var{font-spec}中的字体属性@var{property}设置为@var{value}。
@end defun

@cindex font entity
  字体实体是对字体的引用，不需要打开。它的属性介于字体对象和字体规格之间：
与字体对象一样，与字体规格不同的是，它指的是单一的、特定的字体。与字体对象
不同，创建字体实体并不会将该字体的内容加载到计算机内存中。Emacs可以从一个
指代可扩展字体的字体实体中打开多个不同大小的字体对象。

@defun find-font font-spec &optional frame
本函数返回与@var{frame}框架上的字体规格@var{font-spec}最匹配的字体实体。
如果@var{frame}是@code{nil}，则默认为所选窗帧的字体。
@end defun

@defun list-fonts font-spec &optional frame num prefer
这个函数返回所有符合字体规格@var{font-spec}的字体实体列表。

可选参数@var{frame}，如果不是@code{nil}，则指定显示字体的窗帧。可选参数
@var{num}，如果是非@code{nil}，则应该是一个整数，指定返回列表的最大长度。
可选参数@var{prefer}，如果是非@code{nil}，应该是另一个字体规格，用于控制
返回列表的顺序；返回的字体实体按照与该字体规格的亲密度递减的顺序排序。
@end defun

  如果您调用@code{set-face-attribute}，并传递一个字体规格、字体实体或字体
名称字符串作为@code{:font}属性的值，Emacs就会打开可供显示的最佳匹配字体。
然后，它将相应的字体对象存储为该面的@code{:font}属性的实际值。

  下面的函数可以用来获取字体的信息，对于这些函数，@var{font}参数可以是字体
对象、字体实体或字体规格。

@defun font-get font property
此函数返回@var{font}的字体属性@var{property}的值。

如果@var{font}是一个字体规范，而字体规范没有指定@var{property}，那么返回
值是@code{nil}。如果@var{font}是一个字体对象或字体实体，那么@var{:script}
属性的值可以是一个字体支持的脚本列表。
@end defun

@defun font-face-attributes font &optional frame
此函数返回与@var{font}对应的字体属性列表。参数@var{frame}为可选参数，指定
显示字体的窗帧，如果是@code{nil}，则使用选定的窗帧。如果参数为@code{nil}，
则使用选定的窗帧。返回值的形式是

@smallexample
(:family @var{family} :height @var{height} :weight @var{weight}
   :slant @var{slant} :width @var{width})
@end smallexample

其中@var{family},@var{height},@var{weight},@var{slant},和@var{width}的
值是字形属性值。如果这些键属性对没有被@var{font}指定，那么它们中的一些可能
会从列表中被省略。
@end defun

@defun font-xlfd-name font &optional fold-wildcards
此函数返回XLFD（X逻辑字体描述符），是一个字符串，匹配@var{font}。关于XLFD
的信息，请参考@xref{Fonts,,,emacs, The GNU Emacs Manual}。如果名称对于
XLFD来说太长（最多可以包含255个字符），函数返回@code{nil}。

如果可选参数@var{fold-wildcards}是非@code{nil}，则XLFD中的连续通配符将被
折叠成一个。
@end defun

以下两个函数返回字体的重要信息。

@defun font-info name &optional frame
本函数返回由@var{name}（字符串）指定的字体信息，因为它是在@var{frame}上使
用的。如果省略了@var{frame}或者@code{nil}，则默认为选定的窗帧。

函数返回的值是一个
@code{[@var{opened-name} @var{full-name} @var{size} @var{height}
@var{baseline-offset} @var{relative-compose} @var{default-ascent}
@var{max-width} @var{ascent} @var{descent} @var{space-width}
@var{average-width} @var{filename} @var{capability}]}
形式的向量。下面是这个向量的各个组成部分的描述:

@table @var
@item opened-name
用于打开字体的名称，一个字符串。

@item full-name
字体的全称，一个字符串。

@item size
字体的像素大小。

@item height
字体的高度，单位为像素。

@item baseline-offset
从@acronym{ASCII}基线出发的偏移量，以像素为单位，正数向上。

@item relative-compose
@itemx default-ascent
控制如何组成字符的数字。

@item max-width
字体的最大前进宽度。

@item ascent
@itemx descent
这个字体的上升和下降。这两个数字之和应该等于上面@var{height}的值。

@item space-width
字体的空格字符的宽度，以像素为单位。

@item average-width
字体字符的平均宽度。如果这个值为0，Emacs在计算文字布局时使用
@var{space-width}的值。

@item filename
字体的文件名，作为一个字符串。如果字体后端没有提供查找字体文件名的方法，则
可以是@code{nil}。

@item capability
一个列表，其第一个元素是代表字体类型的符号，是@code{x}、@code{opentype}、
@code{truetype}、@code{type1}、@code{pcf}或@code{bdf}中的一个。对于
OpenType字体，这个列表包括两个额外的元素，描述字体支持的@sc{gsub}和
@sc{gpos}特性。每一个元素都是一个列表，其形式为
@code{((@var{script} (@var{langsys} @var{feature} @dots{}) @dots{})
@dots{})}，其中@var{script}是一个代表OpenType脚本标签的符号，
@var{langsys}是一个代表OpenType langsys标签的符号（或@code{nil}，代表默
认的langsys），每个@var{feature}是一个代表OpenType特征标签的符号。
@end table
@end defun

@defun query-font font-object
这个函数返回@var{font-object}的信息。(这与@code{font-info}不同，
@code{font-info}的参数是一个字符串，字体名称。)

函数返回的值是一个
@code{[@var{name} @var{filename} @var{pixel-size} @var{max-width}
@var{ascent} @var{descent} @var{space-width} @var{average-width}
@var{capability}]}形式的向量。下面是这个向量的各个组成部分的描述:

@table @var
@item name
字体名称，一个字符串。

@item filename
字体的文件名，作为一个字符串。如果字体后台没有提供查找字体文件名的方法。如
果字体后端没有提供查找字体文件名的方法，则可以是@code{nil}。

@item pixel-size
用于打开字体的像素大小。

@item max-width
字体的最大前进宽度。

@item ascent
@itemx descent
这个字体的上升和下降。这两个数字之和就是字体的高度。

@item space-width
字体的空格字符的宽度，以像素为单位。

@item average-width
字体字符的平均宽度。如果这个值为0，Emacs在计算文字布局时使用
@var{space-width}的值。

@item capability
一个列表，其第一个元素是代表字体类型的符号，是@code{x}、@code{opentype}、
@code{truetype}、@code{type1}、@code{pcf}或@code{bdf}中的一个。对于
OpenType字体，这个列表包括两个额外的元素，描述字体支持的@sc{gsub}和
@sc{gpos}特性。每一个元素都是一个列表，其形式为
@code{((@var{script} (@var{langsys} @var{feature} @dots{}) @dots{})
@dots{})}，其中@var{script}是一个代表OpenType脚本标签的符号，
@var{langsys}是一个代表OpenType langsys标签的符号（或@code{nil}，代表默
认的langsys），每个@var{feature}是一个代表OpenType特征标签的符号。
@end table
@end defun

@cindex font information for layout
下面的四个函数返回了各种字体的大小信息，允许在Lisp程序中进行各种布局考虑。
这些函数考虑到了字形重映射，如果相关的字形被重映射，则返回有关重映射字形的
信息。@xref{字形重映射}.

@defun default-font-width
该函数返回当前缓冲区默认字形的字体的平均宽度，以像素为单位，因为该字形是为
所选窗帧定义的。
@end defun

@defun default-font-height
该函数返回当前缓冲区默认字形的字体的高度，以像素为单位，因为该字形是为所选
窗帧定义的。
@end defun

@defun window-font-width &optional window face
此函数返回@var{face}在@var{window}中使用的字体的平均宽度，单位为像素。指
定的@var{window}必须是一个实时窗口。如果@code{nil}被省略，则@var{window}
默认为选定的窗口，@var{face}默认为@var{window}中的默认字形。
@end defun

@defun window-font-height &optional window face
此函数以像素为单位返回@var{face}在@var{window}中使用的字体高度。指定的
@var{window}必须是一个实时窗口，如果@code{nil}被省略，则@var{window}默认
为选定的窗口。如果@code{nil}被省略，则@var{window}默认为选定的窗口，
@var{face}默认为@var{window}中的默认字形。
@end defun

@node 边缘
@section Fringes
@cindex fringes

  在图形显示上，Emacs会在每个窗口旁边绘制@dfn{fringes}：细细的竖条向下，可
以显示表示截断、延续、水平滚动等的位图。

@menu
* 边缘尺寸/位置::  指定窗口边缘的位置。
* 边缘指示器::     在窗口边缘显示指示图标。
* 边缘光标::       在右侧边缘显示光标。
* 边缘位图::       为边缘指示器指定位图。
* 自定义位图::     在边缘指定自己的位图。
* 叠加箭头::       显示箭头以指示位置。
@end menu

@node 边缘尺寸/位置
@subsection Fringe Size and Position

  以下缓冲区局部变量控制了显示该缓冲区的窗口中边缘的位置和宽度。

@defvar fringes-outside-margins
边缘通常出现在显示边框和窗口文字之间。如果数值是非@code{nil}，则出现在显示
边框之外。@xref{显示边距}。
@end defvar

@defvar left-fringe-width
这个变量如果不是@code{nil}，则指定左边缘的宽度，单位为像素。值为@code{nil}
表示使用窗口框架的左边缘宽度。
@end defvar

@defvar right-fringe-width
这个变量如果不是@code{nil}，则指定右边缘的宽度，单位为像素。值为@code{nil}
表示使用窗口框架中的右边缘宽度。
@end defvar

  任何没有为这些变量指定值的缓冲区都会使用@code{left-fringe}和
@code{right-fringe}窗框参数（@pxref{Layout Parameters}）指定的值。

  上述变量实际上是通过函数@code{set-window-buffer}来实现的。(
@pxref{Buffers and Windows})，它调用@code{set-window-fringes}作为一个子
程序。如果您更改了其中一个变量，除非您在每个受影响的窗口中再次调用
@code{set-window-buffer}，否则在显示缓冲区的现有窗口中，边缘显示不会更新
。您也可以使用 @code{set-window-fringes} 来控制各个窗口的边缘显示。

@defun set-window-fringes window left &optional right outside-margins persistent
此函数用于设置@var{window}窗口的边缘宽度。如果@var{window}为@code{nil}，
则使用选定的窗口。

参数@var{left}指定了左边边缘的宽度，以像素为单位，同样@var{right}也指定了
右边边缘的宽度。任意一个如果为非@code{nil}，则代表默认宽度。如果
@var{outside-margins}是非@code{nil}，则指定边缘应该出现在显示边框之外。

如果@var{window}的大小不足以容纳所需宽度的边缘，那么@var{window}的边缘将
保持不变。

这里指定的值可以在以后通过在@var{window}上调用@code{set-window-buffer}来
覆盖。(@pxref{Buffers and Windows})，其@var{keep-margins}参数为
@code{nil}或省略。然而，如果第五个参数@var{persistent}是非@code{nil}，并
且其他参数都被成功处理，那么这里指定的值将无条件地在后续调用
@code{set-window-buffer}时继续存在。这可以用来永久关闭minibuffer窗口中的
边缘，请参考@code{set-window-scroll-bar}的描述，以了解一个例子(
@pxref{Scroll Bars})。
@end defun

@defun window-fringes &optional window
此函数返回关于@var{window}窗口边缘的信息，如果@var{window}被省略或是
@code{nil}，则使用选定的窗口。值的形式为@code{(@var{left-width} @var{right-width} @var{outside-margins} @var{persistent})}。
@end defun


@node 边缘指示器
@subsection Fringe Indicators
@cindex fringe indicators
@cindex indicators, fringe

  @dfn{Fringe indicators}是显示在窗口边缘的微小图标，用于指示截断或延续的
行、缓冲区边界等。

@defopt indicate-empty-lines
@cindex fringes, and empty line indication
@cindex empty lines, indicating
当这个值是非@code{nil}时，Emacs会在缓冲区末尾的每一行空行的边缘显示一个特
殊的字形。@xref{Fringes}。在每个缓冲区中，这个变量都是自动的缓冲区本地变量
。
@end defopt

@defopt indicate-buffer-boundaries
@cindex buffer boundaries, indicating
这个缓冲区局部变量控制缓冲区边界和窗口滚动在窗口边缘的显示方式。

Emacs可以在缓冲区边界--即缓冲区的第一行和最后一行--出现在屏幕上时用角度图
标表示。此外，Emacs还可以在边框中显示一个向上的箭头来表示屏幕上方有文字，
而向下的箭头则表示屏幕下方有文字。

基本值有三种：

@table @asis
@item @code{nil}
不要显示任何这些边缘的图标。
@item @code{left}
在左边缘显示角度图标和箭头。
@item @code{right}
在右边缘中显示角度图标和箭头。
@item any non-alist
在左边缘中显示角度图标，不要显示箭头。
@end table

否则，该值应该是一个alist，指定哪些边缘指标要显示，在哪里显示。alist的每个
元素应该是@code{(@var{indicator} . @var{position})}的形式。这里，
@var{indicator}是@code{top}、@code{bottom}、@code{up}、@code{down}和
@code{t}中的一个。(它涵盖了所有尚未指定的图标)，而@var{position}是
@code{left}、@code{right}和@code{nil}中的一个。

例如，@code{((top .left) (t .right))}将上角位图放在左边缘，下角位图和两个
箭头位图放在右边缘。如果要在左边缘显示角度位图，而不显示箭头位图，请使用
@code{((top . left) (bottom . left))}。
@end defopt

@defvar fringe-indicator-alist
这个缓冲区局部变量指定了从逻辑边缘指示器到窗口边缘显示的实际位图的映射。值
是一个元素@code{(@var{indicator} . @var{bitmaps})}的列表，其中
@var{indicator}指定了一个逻辑指标类型，@var{bitmaps}指定了该指标的边缘位
图。

  每一个@var{indicator}应该是以下符号之一：

@table @asis
@item @code{truncation}, @code{continuation}.
用于截断和延续线。

@item @code{up}, @code{down}, @code{top}, @code{bottom}, @code{top-bottom}
当@code{indicate-buffer-boundaries}是非@code{nil}时使用。@code{up}和
@code{down}表示缓冲区边界位于窗口边缘的上方或下方；@code{top}和
@code{bottom}表示缓冲区最上方和最下方的文字行；@code{top-bottom}
表示缓冲区中只有一行文字的地方。

@item @code{empty-line}
当@code{indicat-empty-lines}是非@code{nil}时，用于指示缓冲区结束后的空行
。

@item @code{overlay-arrow}
用于叠加箭头（@pxref{Overlay Arrow}）。
@c 这在哪里用过？
@c @item 未知位图指示器:
@c @code{unknown}.
@end table

  每个@var{bitmaps}值可以是一个符号列表@code{(@var{left} @var{right}
[@var{left1} @var{right1}])}。@var{left}和@var{right}符号指定了特定指标
在左边和/或右边边缘显示的位图。@var{left1}和@var{right1}是针对
@code{bottom}和@code{top-bottom}指标的，用来表示最后一行文字没有最后的换
行。另外，@var{bitmaps}也可以是一个单一的符号，它同时用于左、右边缘。

  @xref{Fringe Bitmaps}，提供标准位图符号的列表以及如何定义您自己的位图。
此外，@code{nil}代表空位图（即没有显示的指示符）。

  当@code{fringe-indicator-alist}具有缓冲区局部值，且没有为逻辑指标定义位
图，或者位图为@code{t}时，将使用@code{fringe-indicator-alist}默认值中的对
应值。
@end defvar

@node 边缘光标
@subsection Fringe Cursors
@cindex fringe cursors
@cindex cursor, fringe

  当一行与窗口的宽度完全相同时，Emacs将光标显示在右侧的边缘，而不是使用两
行。根据当前缓冲区的光标类型，使用不同的位图来表示光标在边缘的位置。

@defopt overflow-newline-into-fringe
如果是非@code{nil}，那么与窗口完全一样宽的行（不包括最后的换行符）将不会继
续。相反，当点在行尾时，光标会出现在右边的边缘。
@end defopt

@defvar fringe-cursor-alist
这个变量指定了从逻辑光标类型到实际边缘位图的映射。这个值是一个列表，里面每
个元素的形式为@code{(@var{cursor-type} . @var{bitmap})}，表示使用边缘位
图@var{bitmap}来显示类型为@var{cursor-type}的游标。

每个@var{cursor-type}应该是@code{box}、@code{hollow}、@code{bar}、
@code{hbar}或@code{hollow-small}中的一个。前四个参数的含义与
@code{cursor-type}窗框参数（@pxref{Cursor Parameters}）相同。当正常的
@code{hollow-rectangle}位图太高，无法在特定的显示行上显示时，就会使用
@code{hollow-small}类型来代替@code{hollow}。

每个@var{bitmap}都应该是一个符号，指定该逻辑光标类型的边缘位图。
@iftex
详见下一小节。
@end iftex
@ifnottex
@xref{Fringe Bitmaps}.
@end ifnottex

@c FIXME: 我找不到fringes-indicator-alist变量。也许应该是
@c fringe-indicator-alist还是fringe-cursor-alist？--xfq
当@code{fringe-cursor-alist}有一个缓冲区本地值，并且没有为游标类型定义位
图时，将使用@code{fringe-indicator-alist}默认值中的对应值。
@end defvar

@node 边缘位图
@subsection Fringe Bitmaps
@cindex fringe bitmaps
@cindex bitmaps, fringe

  @dfn{fringe bitmaps}是实际的位图，它表示截断或继续的线条、缓冲区边界、
覆盖箭头等的逻辑边缘指标。每个位图用一个符号表示。
@iftex
这些符号由变量@code{fringe-indicator-alist}和@code{fringe-cursor-alist}
来引用，在前面的小节中已经介绍过。
@end iftex
@ifnottex
这些符号由@code{fringe-indicator-alist}变量和@code{fringe-cursor-alist}
变量引用，前者将边缘指示器映射到位图（@pxref{Fringe Indicators}），后者将
边缘光标映射到位图（@pxref{Fringe Cursors}）。
@end ifnottex

  Lisp程序也可以直接在左边缘或右边缘显示位图，通过对行中出现的一个字符使用
@code{display}属性（@pxref{Other Display Specs}）。这种显示规范的形式是

@example
(@var{fringe} @var{bitmap} [@var{face}])
@end example

@noindent
@var{fringe}是符号@code{left-fringe}或@code{right-fringe}。@var{bitmap}
是一个标识要显示的位图的符号。可选的@var{face}是一个字形，它的前景色是用来
显示位图的；这个字形会自动与@code{fringe}字形合并。

  例如，如果要在左侧边缘中显示一个箭头，使用@code{warning}字形，你可以这样
写：

@lisp
(overlay-put
 (make-overlay (point) (point))
 'before-string (propertize
                 "x" 'display
                 `(left-fringe right-arrow warning)))
@end lisp

  这里是Emacs中定义的标准边缘位图的列表，以及它们目前在Emacs中的使用方式（
通过@code{fringe-indicator-alist}和@code{fringe-cursor-alist}）。

@table @asis
@item @code{left-arrow}, @code{right-arrow}
用于表示截断的行。

@item @code{left-curly-arrow}, @code{right-curly-arrow}
用来表示续行。

@item @code{right-triangle}, @code{left-triangle}
前者由覆盖箭头使用。后者是不用的。

@item @code{up-arrow}, @code{down-arrow}
@itemx @code{bottom-left-angle}, @code{bottom-right-angle}
@itemx @code{top-left-angle}, @code{top-right-angle}
@itemx @code{left-bracket}, @code{right-bracket}
@itemx @code{empty-line}
用来表示缓冲区的边界。

@item @code{filled-rectangle}, @code{hollow-rectangle}
@itemx @code{filled-square}, @code{hollow-square}
@itemx @code{vertical-bar}, @code{horizontal-bar}。
用于不同类型的边缘光标。

@item @code{exclamation-mark}, @code{question-mark}
不被Emacs核心功能使用。
@end table

@noindent
下一小节介绍如何定义自己的边缘位图。

@defun fringe-bitmaps-at-pos &optional pos window
此函数返回窗口@var{window}中包含位置@var{pos}的显示行的边缘位图。返回值的
形式为@code{(@var{left} @var{right} @var{ov})}，其中@var{left}是左边缘的
边缘位图的符号（如果没有位图，则为@code{nil}），@var{right}是右边缘的类似
符号，如果左边缘有覆盖箭头，则@var{ov}是非@code{nil}。

如果@var{pos}在@var{window}中不可见，则该值为@code{nil}。如果
@var{window}是@code{nil}，则代表选定的窗口。如果@var{pos}是@code{nil}，
则代表@var{window}中的点的值。
@end defun

@node 自定义位图
@subsection Customizing Fringe Bitmaps
@cindex fringe bitmaps, customizing

@defun define-fringe-bitmap bitmap bits &optional height width align
这个函数定义符号@var{bitmap}为一个新的边缘位图，或者用该名称替换一个现有的
位图。

参数@var{bits}指定要使用的图像。它应该是一个字符串或整数向量，其中每个元素
（整数）对应于位图的一行。整数的每一个位对应于位图的一个像素，其中低位对应
于位图的最右边的像素。(请注意，这个位的顺序与XBM图像中的顺序相反；
@pxref{XBM Images}。)

高度通常是@var{bits}的长度。但是，您可以使用非@code{nil}的@var{height}指
定不同的高度。宽度通常是8，但你可以用非@code{nil}的@var{width}指定不同的
宽度。宽度必须是1到16之间的整数。

参数@var{align}指定了位图相对于使用它的行的范围的定位，默认为位图居中。允
许的值是@code{top}、@code{center}或@code{bottom}。

@var{align}参数也可以是一个列表@code{(@var{align} @var{periodic})}，其中
@var{align}的解释如上所述。如果@var{periodic}是非@code{nil}，则指定
@code{bits}中的行应该重复足够的次数以达到指定的高度。
@end defun

@defun destroy-fringe-bitmap bitmap
此函数销毁由@var{bitmap}识别的边缘位图。如果@var{bitmap}识别了一个标准的
边缘位图，那么它实际上会恢复该位图的标准定义，而不是完全删除它。
@end defun

@defun set-fringe-bitmap-face bitmap &optional face
这将边缘位图@var{bitmap}的字形设置为@var{face}。如果@var{face}是
@code{nil}，则选择@code{fringe}字形。位图的字形控制着绘制它的颜色。

@var{face}与@code{fringe}字形合并，所以通常@var{face}应该只指定前景色。
@end defun

@node 叠加箭头
@subsection The Overlay Arrow
@c @cindex 叠加箭头 重复变量名

  @dfn{overlay arrow}对于引导用户注意缓冲区中的某一行非常有用。例如，在用
于调试器接口的模式中，叠加箭头指示即将执行的代码行。这个功能与
@dfn{overlays}(@pxref{Overlays})无关。

@defvar overlay-arrow-string
这个变量保存了要显示的字符串，以引起对某一行的注意，如果没有使用箭头功能，
则显示@code{nil}。在图形显示中，字符串的内容会被忽略；相反，在显示区域左侧
的边缘区域会显示一个字形。
@end defvar

@defvar overlay-arrow-position
这个变量拥有一个标记，指示在哪里显示叠加箭头。它应该指向一行的开头。在非图
形化显示中，箭头文本出现在该行的开头，覆盖任何本来会出现的文本。由于箭头通
常很短，而且该行通常以缩进的方式开始，通常不会覆盖任何重要的内容。

如果该缓冲区中@code{overlay-arrow-position}的值指向该缓冲区，则在任何给定
的缓冲区中都会显示叠加箭头字符串。因此，可以通过创建
@code{overlay-arrow-position}的缓冲区本地绑定来显示多个叠加箭头字符串。然
而，通常使用 @code{overlay-arrow-variable-list} 来实现这一结果更为简洁。
@c !!! overlay-arrow-position: 但覆盖的字符串可以保留在其他缓冲区的显示中
@c 直到需要更新为止。这一点现在应该得到修正。是吗？
@end defvar

  您可以通过使用@code{before-string}属性创建一个叠加层来完成类似的工作。
@xref{Overlay Properties}。

  您可以通过变量@code{overlay-arrow-variable-list}定义多个叠加箭头。

@defvar overlay-arrow-variable-list
这个变量的值是一个变量列表，每个变量都指定了叠加箭头的位置。变量
@code{overlay-arrow-position}具有正常意义，因为它在这个列表中。
@end defvar

这个列表中的每个变量都可以拥有@code{overlay-arrow-string}和
@code{overlay-arrow-bitmap}属性，这些属性指定了要在相应的叠加箭头位置显示
的叠加箭头字符串（对于文本终端）或边缘位图（对于图形终端）。如果没有设置任
何一个属性，则使用默认的@code{overlay-arrow-string}或
@code{overlay-arrow}边缘指示器。

@node 滚动条
@section Scroll Bars
@cindex scroll bars

通常情况下，窗框参数@code{vertical-scroll-bar}控制窗框中的窗口是否有垂直
滚动条，以及它们是在左边还是右边。窗框参数@code{scroll-bar-width}指定了它
们的宽度（@code{nil} 表示默认值）。

窗框参数@code{horizontal-scroll-bar}控制窗框中的窗口是否有水平滚动条。窗
框参数@code{scroll-bar-height}指定了它们的高度（@code{nil}表示默认值）。
@xref{Layout Parameters}。

@vindex horizontal-scroll-bars-available-p
  并非所有平台上都有水平滚动条。函数
@code{horizontal-scroll-bar-available-p}不接受任何参数，如果它们在你的系
统上可用，则返回非@code{nil}。

  以下三个函数以一个默认为选定的实时窗框作为参数。

@defun frame-current-scroll-bars &optional frame
这个函数报告框架@var{frame}的滚动条类型。值是一个cons单元格
@code{(@var{vertical-type} .@: @var{horizontal-type})}，其中
@var{vertical-type}是@code{left}、@code{right}或@code{nil}。(这意味着没
有垂直滚动条。)@var{horizontal-type}是@code{bottom}或@code{nil}。这意味
着没有水平滚动条）。
@end defun

@defun frame-scroll-bar-width &optional frame
此函数返回@var{frame}的垂直滚动条的宽度，单位为像素。
@end defun

@defun frame-scroll-bar-height &optional frame
此函数返回@var{frame}的水平滚动条的高度，单位为像素。
@end defun

您可以通过使用以下功能覆盖各个窗口的窗框特定设置：

@defun set-window-scroll-bars window &optional width vertical-type height horizontal-type persistent
此函数用于设置窗口@var{window}的宽度和/或高度以及滚动条的类型。如果
@var{window}为@code{nil}，则使用选定的窗口。

@var{width}指定垂直滚动条的宽度，单位为像素(@code{nil}表示使用为窗框指定
的宽度)。@var{vertical-type}指定是否使用垂直滚动条，如果是，则指定在哪里使
用。可能的值有@code{left}、@code{right}、@code{t}（表示使用框架的默认值）
和@code{nil}（表示没有垂直滚动条）。

@var{height}指定水平滚动条的高度，单位为像素（@code{nil}表示使用窗框指定
的高度）。@var{horizontal-type}指定是否使用水平滚动条。可能的值是
@code{bottom}，@code{t}表示使用框架的默认值，@code{nil}表示没有水平滚动条
。请注意，对于迷你窗口来说，@code{t}和@code{nil}的含义相同，即不显示水平滚
动条。你必须明确指定@code{bottom}才能在迷你窗口中显示水平滚动条。

如果@var{window}不够大，无法容纳所需尺寸的滚动条，那么相应的滚动条将保持不
变。

这里指定的值可以在以后通过调用@code{set-window-buffer}来覆盖。(
@pxref{Buffers and Windows})上的@var{window}，其@var{keep-margins}参数
为@code{nil}或省略。然而，如果可选的第五个参数@var{persistent}是非
@code{nil}，并且其他参数都被成功处理，那么这里指定的值将无条件地在后续调用
@code{set-window-buffer}时继续存在。
@end defun

使用@code{set-window-scroll-bar}和@code{set-window-fringes}的
@var{persistent}参数。(@pxref{Fringe Size/Pos})您可以通过在您的早期初始文
件(@pxref{Init File})中添加以下代码段来可靠地永久关闭任何迷你缓冲区窗口中
的滚动条和/或边缘。

@smallexample
@group
(add-hook 'after-make-frame-functions
          (lambda (frame)
            (set-window-scroll-bars
             (minibuffer-window frame) 0 nil 0 nil t)
            (set-window-fringes
             (minibuffer-window frame) 0 0 nil t)))
@end group
@end smallexample

以下四个函数以一个默认为所选窗口的实时窗口作为参数。

@defun window-scroll-bars &optional window
这个函数返回一个形式为@code{(@var{width} @var{columns}
@var{vertical-type} @var{height} @var{lines} @var{horizontal-type}
@var{persistent})}的列表。

值@var{width}是为垂直滚动条的宽度指定的值（可能是@code{nil}）；
@var{columns}是垂直滚动条实际占用的列数（可能是四舍五入）。

值@var{height}是为水平滚动条的高度指定的值（可能是@code{nil}）；
@var{lines}是水平滚动条实际占用的行数（可能是四舍五入）。

@var{persistent}的值是最后一次成功调用@code{set-window-scroll-bar}时为
@var{window}指定的值，如果没有成功调用，则为@code{nil}。
@end defun

@defun window-current-scroll-bars &optional window
此函数报告窗口@var{window}的滚动条类型。值是一个cons单元格
@code{(@var{vertical-type} .@: @var{horizontal-type})}。与
@code{window-scroll-bar}不同的是，当考虑到框架默认值和
@code{scroll-bar-mode}时，这个函数报告的是实际使用的滚动条类型。
@end defun

@defun window-scroll-bar-width &optional window
此函数返回@var{window}的垂直滚动条的宽度，单位为像素。
@end defun

@defun window-scroll-bar-height &optional window
此函数返回@var{window}的水平滚动条的高度，单位为像素。
@end defun

如果您没有通过@code{set-window-scroll-bar}来指定窗口的滚动条设置，那么缓
冲区中的局部变量@code{vertical-scroll-bar}、@code{horizontal-scroll-bar}
、@code{scroll-bar-width}和@code{scroll-bar-height}将控制窗口的滚动条。
函数@code{set-window-buffer}检查这些变量。如果您改变了一个已经在窗口中可
见的缓冲区中的变量，您可以通过调用@code{set-window-buffer}指定已经显示的
同一缓冲区来使窗口注意到新的值。

您可以通过设置以下变量来控制特定缓冲区的滚动条的外观，这些变量在设置后会自
动成为缓冲区的本地变量。

@defvar vertical-scroll-bar
这个变量指定了垂直滚动条的位置。可能的值有@code{left}、@code{right}、
@code{t}（表示使用窗框的默认值）和@code{nil}（表示没有滚动条）。
@end defvar

@defvar horizontal-scroll-bar
这个变量指定了水平滚动条的位置。可能的值是@code{bottom}，@code{t}，表示使
用窗框的默认值，@code{nil}表示没有滚动条。
@end defvar

@defvar scroll-bar-width
这个变量指定了缓冲区垂直滚动条的宽度，以像素为单位。值为@code{nil}表示使用
窗框指定的值。
@end defvar

@defvar scroll-bar-height
这个变量指定了缓冲区水平滚动条的高度，以像素为单位。值为@code{nil}表示使用
窗框指定的值。
@end defvar

最后，您可以通过自定义@code{scroll-bar-mode}和
@code{horizontal-scroll-bar-mode}这两个变量来切换所有窗框上滚动条的显示。

@defopt scroll-bar-mode
这个变量控制是否在所有窗框中放置垂直滚动条以及放置在哪里。可能的值是
@code{nil}表示没有滚动条，@code{left}表示将滚动条放在左边，@code{right}表
示将滚动条放在右边。
@end defopt

@defopt horizontal-scroll-bar-mode
这个变量控制是否在所有窗框上显示水平滚动条。
@end defopt

@node 窗口分隔线
@section Window Dividers
@cindex window dividers
@cindex right dividers
@cindex bottom dividers

窗口分隔线是在一个窗框的窗口之间画出的条状物。右边的分界线是在一个窗口和任
何相邻的右边窗口之间绘制的，它的宽度（厚度）由窗框参数
@code{right-divider-width}指定。它的宽度（厚度）由窗框参数
@code{right-divider-width}指定。底部分隔线是在一个窗口和相邻窗口的底部或
回音区之间绘制的。它的宽度由窗框参数@code{bottom-divider-width}指定。无论
是哪种情况，指定宽度为零都意味着不绘制这种分隔线。
@xref{Layout Parameters}.

从技术上讲，右边的分隔线属于它左边的窗口，这意味着它的宽度占该窗口的总宽度
。底部的分隔线属于它上面的窗口，这意味着它的宽度占该窗口的总高度。
@xref{窗口大小}。当一个窗口同时拥有右边和底部分隔线时，以底部分隔线为
准。这意味着，底部分隔线的宽度要画在窗口的整个总宽度上，而右侧分隔线的终点
在底部分隔线的上方。

分隔线可以用鼠标拖动，因此可以用鼠标调整相邻窗口的大小。当没有滚动条或模式
线存在时，它们还可以在视觉上将相邻窗口分开。以下三个字形允许自定义分隔线的
外观:

@table @code
@item window-divider
当分界线宽度小于3个像素时，它与这个字形的前景绘制为实心。对于较大的分界线，
这个字形只用于内部，不包括第一个和最后一个像素。

@item window-divider-first-pixel
这是用于绘制至少三个像素宽的分隔线的第一个像素的字形。如果要获得实体外观，
请将其设置为与@code{window-divider}字形相同的值。

@item window-divider-last-pixel
这是用于绘制至少三个像素宽的分隔线的最后一个像素的字形，如果要获得实体的外
观，请将其设置为与@code{window-divider}字形相同的值。
@end table

您可以通过以下两个函数获得特定窗口的分隔线大小。

@defun window-right-divider-width &optional window
返回@var{window}右侧分隔线的宽度（厚度），单位为像素。@var{window}必须是
一个实时窗口，默认为所选窗口。对于最右边的窗口，返回值总是0。
@end defun

@defun window-bottom-divider-width &optional window
返回@var{window}底部分隔线的宽度（厚度），单位为像素。@var{window}必须是
一个实时窗口，默认为所选窗口。对于minibuffer窗口或无minibuffer窗框的最底层
窗口，返回值为0。
@end defun


@node 显示属性
@section The @code{display} Property
@cindex display specification
@kindex display @r{(text property)}

  @code{display}文本属性（或叠加属性）用于在文本中插入图像，并控制文本显示
方式的其他方面。@code{display}属性的值应该是一个显示规范，或一个包含多个显
示规范的列表或向量。同一@code{display}属性值中的显示规范通常与它们所覆盖的
文本平行应用。

如果多个来源（叠加和/或文本属性）为@code{display}属性指定了值，则按照
@code{get-char-property}的规则，只有其中一个值生效。
@xref{Examining Properties}.

@cindex display property, unsafe evaluation
@cindex security, and display specifications
  一些显示规范允许包含Lisp表单，这些表单在显示时被评估。这在某些情况下可能
是不安全的，例如，当显示规范是由一些外部程序/代理生成时。在一个以特殊符号
@code{disable-eval}开头的列表中包装一个显示规范，比如在
@w{@code{('disable-eval @var{spec})}}，将禁止使用@var{spec}中任何的
Lisp，同时仍然支持所有其他的显示属性功能。

  本节其余部分将介绍几种显示标准及其含义。

@menu
* 替换规范::     显示取代文字的规范。
* 指定空白::     显示指定宽度的空白。
* 像素规格::     以像素为单位指定空间的宽度或高度。
* 其他显示规格:: 显示图像；调整文字的高度、间距等属性。
* 显示边距::     在正文的一侧显示文字或图像。
@end menu

@node 替换规范
@subsection Display Specs That Replace The Text
@cindex replacing display specs

  有些显示规范指定了要显示的东西，而不是具有该属性的文本。这些被称为
@dfn{replacing}显示规范。Emacs不允许用户交互式地将点移动到以这种方式替换的
缓冲区文本中间。

  如果显示规格列表中包含一个以上的替换显示规格，则第一个规格优先于其他规格
。更换的显示规范使大多数其他显示规格变得无关紧要，因为这些规格不适用于更换
的显示规范。

  对于替换显示规范，@dfn{the text that has the property}是指所有具有相同
Lisp对象作为其@code{display}属性的连续字符；这些字符将作为一个单元被替换。
如果两个字符有不同的Lisp对象作为它们的@code{display}属性（比如不@code{eq}
的对象），它们将被分开处理。

这里有一个例子可以说明这一点。字符串作为替换显示规范，它用指定的字符串（
@pxref{Other Display Specs}）替换具有该属性的文本。考虑以下功能:

@smallexample
(defun foo ()
  (dotimes (i 5)
    (let ((string (concat "A"))
          (start (+ i i (point-min))))
      (put-text-property start (1+ start) 'display string)
      (put-text-property start (+ 2 start) 'display string))))
@end smallexample

@noindent
这个函数给缓冲区中的前十个字符各分配了一个@code{display}属性，这个属性是一
个字符串@code{"A"}，但是它们并没有都得到相同的字符串对象。前两个字符得到了
相同的字符串对象，所以它们被替换为一个@samp{A}；事实上，display属性是在对
@code{put-text-property}的两个单独调用中分配的，这一点并不重要。同样地，
接下来的两个字符会得到第二个字符串（@code{concat}创建了一个新的字符串对象
），所以它们会被一个@samp{A}所取代；以此类推。这样，这十个字符就出现了五个
A。

@node 指定空白
@subsection Specified Spaces
@cindex spaces, specified height or width
@cindex variable-width spaces

  要显示指定宽度和/或高度的空格，请使用 @code{(space . @var{props})}形式
的显示规范，其中@var{props}是一个属性列表（一个交替的属性和值的列表）。您
可以将此属性放在一个或多个连续的字符上；指定高度和宽度的空白将代替
@emph{all}这些字符显示。这些是您可以在@var{props}中使用的属性，用于指定空
白的大小:

@table @code
@item :width @var{width}
如果@var{width}是一个数字，它指定空间宽度应该是@var{width}乘以正常字符宽
度。@var{width}也可以是@dfn{pixel width}规范 (
@pxref{像素规格})。

@item :relative-width @var{factor}
指定应从具有相同@code{display}属性的连续字符组中的第一个字符开始计算拉伸宽
度。空格宽度是该字符的像素宽度，再乘以@var{factor}。(在文本模式的终端上，
字符的"像素宽度"通常为1，但对于TAB和双倍宽度的中日韩字符来说，可能会更多。
)

@item :align-to @var{hpos}
指定空间的宽度应该足够达到@var{hpos}。如果@var{hpos}是一个数字，则以正常
字符宽度为单位。@var{hpos}也可以是@dfn{pixel width}规范(
@pxref{像素规格})。
@end table

  你应该使用上述属性中的一个且仅有一个。你也可以用这些属性指定空间的高度:

@table @code
@item :height @var{height}
指定空格的高度。
如果@var{height}是一个数字，它指定空间高度应该是@var{height}乘以正常字符
高度。@var{height}也可以是@dfn{pixel height}规范(
@pxref{像素规格})。

@item :relative-height @var{factor}
指定空间的高度，将具有此显示规格的文字的普通高度乘以@var{factor}。

@item :ascent @var{ascent}
如果@var{ascent}的值是一个不大于100的非负数，那么它指定@var{ascent}的高度
占空间高度的百分比应被视为空间的上升--也就是基线以上的部分。也可以用
@dfn{pixel ascent}规范(@pxref{像素规格})以像素为单位指定上升
高度。
@end table

  不要同时使用@code{:height}和@code{:relative-height}。

  非图形终端支持@code{:width}和@code{:align-to}属性，但本节中的其他空间属
性不支持。

  请注意，在重新排列双向文本的显示顺序时，空格属性被视为段落分隔符。详情请
参考@xref{双向显示}。

@node 像素规格
@subsection Pixel Specification for Spaces
@cindex spaces, pixel specification

  @code{:width}、@code{:align-to}、@code{:height}和@code{:ascent}属性的
值可以是一种特殊的表达式，在重新显示时进行评估。评估的结果被用作像素的绝对
数。

  支持以下表达方式：

@smallexample
@group
  @var{expr} ::= @var{num} | (@var{num}) | @var{unit} | @var{elem} | @var{pos} | @var{image} | @var{xwidget} | @var{form}
  @var{num}  ::= @var{integer} | @var{float} | @var{symbol}
  @var{unit} ::= in | mm | cm | width | height
@end group
@group
  @var{elem} ::= left-fringe | right-fringe | left-margin | right-margin
        |  scroll-bar | text
  @var{pos}  ::= left | center | right
  @var{form} ::= (@var{num} . @var{expr}) | (@var{op} @var{expr} ...)
  @var{op}   ::= + | -
@end group
@end smallexample

 表单@var{num}指定默认窗框字体高度或宽度的一个比例。表单
@code{(@var{num})}指定了一个绝对的像素数。如果@var{num}是一个符号，
@var{symbol}，则使用它的缓冲区本地变量绑定；这个绑定可以是一个数字，也可以
是上面所示形式的cons单元格（包括另一个cons单元格，其@code{car}是一个有缓冲
区本地绑定的符号）。

  @code{in}、@code{mm}和@code{cm}单位分别指定每英寸、毫米和厘米的像素数。
@code{width}和@code{height}单位对应于当前面的默认宽度和高度。图像规范的表
单@w{@code{(image . @var{props})}}。(@pxref{Image Descriptors})对应于指
定图像的宽度或高度。类似地，表单@w{@code{(xwidget . @var{props})}}的
小部件规范代表指定的小部件的宽度或高度。@xref{Xwidgets}.

  元素@code{left-fringe}、@code{right-fringe}、@code{left-margin}、
@code{right-margin}、@code{scroll-bar}和@code{text}指定窗口相应区域的宽
度。当窗口显示行号(@pxref{Size of Displayed Text})时，@code{text}区域的
宽度会因行号显示所占的屏幕空间而减少。

  @code{left}、@code{center}和@code{right}可以和@code{:align-to}一起使用
，以指定一个相对于文本区域的左边缘、中心或右边缘的位置。当窗口显示行号时，
@code{left}和@code{center}的位置会被偏移，以抵消行号显示所占用的屏幕空间
。

  上述任何一个窗口元素（除了@code{text}）也可以和@code{:align-to}一起使用
，以指定位置是相对于指定区域的左边缘。一旦相对位置的基本偏移量被设置了（通
过这些符号中的一个符号的第一次出现），这些符号的进一步出现将被解释为指定区
域的宽度。例如，要对齐到左边距的中心，请使用

@example
:align-to (+ left-margin (0.5 . left-margin))
@end example

  如果没有为对齐方式设置特定的基准偏移，那么它总是相对于文本区域的左边缘。
例如，页眉行中的@samp{:align-to 0}与文本区域中的第一列文本对齐。当窗口显
示行号时，文本被认为是从用于显示行号的空格开始的。

  形式为@code{(@var{num} . @var{expr})}的值代表@var{num}和@var{expr}值的
乘积。例如，@code{(2 . in)}表示宽度为2英寸，而@code{(0.5 . @var{image})}
表示指定@var{image}宽度（或高度）的一半。应由其图像规格给出）。

  形式@code{(+ @var{expr} ...)}将表达式的值相加。形式
@code{(- @var{expr} ...)}是否定或减去表达式的值。

@node 其他显示规格
@subsection Other Display Specifications

  以下是您可以在@code{display}文本属性中使用的其他类型的显示规范。

@table @code
@item @var{string}
显示@var{string}代替具有此属性的文本。

不支持递归显示规范------@var{string}的@code{display}属性（如果有的话）不
被使用。

@item (image . @var{image-props})
这种显示规范是一种图像描述符（@pxref{Image Descriptors}）。当作为显示规范
使用时，意味着要显示图像而不是具有显示规范的文本。

@item (slice @var{x} @var{y} @var{width} @var{height})
此规范与@code{image}一起指定了@dfn{slice}。要显示的图像的部分区域。元素
@var{y}和@var{x}指定了图像中切片的左上角；@var{width}和@var{height}指定
了切片的宽度和高度。整数是指像素的数量。0.0--1.0范围内的浮点数代表整个图像
的宽度或高度的一部分。

@item ((margin nil) @var{string})
这种形式的显示规范意味着在与该文本相同的位置上显示@var{string}，而不是显示
具有显示规范的文本。它相当于只使用@var{string}，但它是作为边距显示的一种特
殊情况来完成的（@pxref{Display Margins}）。

@item (left-fringe @var{bitmap} @r{[}@var{face}@r{]})
@itemx (right-fringe @var{bitmap} @r{[}@var{face}@r{]})
在一行文本的任何字符上的显示规范会导致指定的@var{bitmap}被显示在该行的左或
右边缘，而不是显示规范的字符。可选的@var{face}指定了位图要使用的颜色。详情
请参考@xref{Fringe Bitmaps}。

@item (space-width @var{factor})
这个显示规范会影响拥有该规范的文本中的所有空格字符。它显示所有这些空格
@var{factor}的宽度是正常的两倍。元素@var{factor}应该是一个整数或浮点数。
除了空格以外的其他字符完全不受影响；特别地，这对制表符没有影响。

@item (height @var{height})
这个显示规范可以使文字变高或变矮。以下是@var{height}的可能性:

@table @asis
@item @code{(+ @var{n})}
@c FIXME: 为"步骤"增加一个索引？--xfq
这意味着要使用大@var{n}级的字体。一个@dfn{step}是由一组可用的字体来定义的
--具体来说，就是那些在除高度以外的所有属性上都与这个文本所指定的字体相匹配
的字体。每一个有合适字体的大小都算作另一个步。@var{n}应该是一个整数。

@item @code{(- @var{n})}
这意味着要使用@var{n}步小的字体。

@item a number, @var{factor}
一个数字，@var{factor}，意思是使用@var{factor}倍于默认字体的字体。

@item a symbol, @var{function}
符号是一个计算高度的函数。它以当前的高度作为参数被调用，并应返回新的高度来
使用。

@item anything else, @var{form}
如果@var{height}的值不符合前面的可能性，它就是一个表格。Emacs对其进行运行
，得到新的高度，符号@code{height}绑定到当前指定的字体高度。
@end table

@item (raise @var{factor})
这种显示规范可以提高或降低它所适用的文本，相对于行的基线。它主要是为了支持
下标和上标的显示。

@var{factor}必须是一个数字，它被解释为受影响文本高度的倍数。如果是正数，则
表示要显示凸起的字符。如果是负数，则表示要显示较低的字符。

请注意，如果文本还有一个@code{height}显示规范，而这个规范是在@code{raise}
之前指定的（即@:在@code{raise}的左边），那么后者将影响以像素为单位的升高或
降低的数量，因为那是基于被升高的文本的高度。因此，如果你想显示一个比正常文
本高度小的分标或上标，可以考虑在@code{height}之前指定@code{raise}。
@end table

@c 我们把所有的"@code{(when ...)}"放在一行，以鼓励makeinfo的句末启发到
@c DTRT。以前，点是在eol；现在信息文件最后在后面渲染了两个空格。
  你可以让任何显示规范成为有条件的。要做到这一点，可以将它打包在另一个列表
中，其形式为@code{(when @var{condition} . @var{spec})}。然后，只有当
@var{condition}运算为非@code{nil}值时，才会应用@var{spec}规范。在评估过程
中，@code{object}被绑定到具有@code{display}条件属性的字符串或缓冲区。
@code{position}和@code{buffer-position}分别绑定到@code{object}中的位置和
发现@code{display}属性的缓冲区位置。当@code{object}是一个字符串时，这两个
位置可以不同。

需要注意的是，@var{condition}只有在redisplay检查这个显示规范所在的文本时
才会被运算，所以这个功能最适合相对稳定的条件，如@:产生，对于每个特定的缓冲
区位置，每次运算的结果都是一样的。如果对于相同的文本位置，结果会发生变化，
例如，如果结果取决于点的位置，那么条件规范可能就不能如你所愿了，因为
redisplay只检查缓冲区文本中它有理由认为自上次显示周期以来发生了变化的部分
。

@node 显示边距
@subsection Displaying in the Margins
@cindex display margins
@cindex margins, display

  缓冲区的左边和右边可以有称为@dfn{display margins}的空白区域。普通的文本
永远不会出现在这些区域中，但是你可以使用@code{display}属性在显示边距中放置
一些东西。目前还没有办法让页边距中的文本或图像对鼠标敏感。

在空白处显示某些内容的方法是在一些文本的@code{display}属性中的空白显示规范
中指定它。这是一种替换显示规范，也就是说，你放在上面的文本不会被显示出来，
边距显示出现了，但那个文本没有出现。

边框显示规范看起来像@code{((margin right-margin) @var{spec})}或
@code{((margin left-margin) @var{spec})}。在这里，@var{spec}是另一种显示
规范，用于说明在边框中显示什么。一般来说，它是一个要显示的文本字符串，或者
是一个图像描述符。

如果要在空白处@emph{in association with}某些缓冲区文本中显示某些内容，而
不改变或阻止该文本的显示，可以在文本上设置一个@code{before-string}属性，
并将空白处显示规范放在before-string的内容上。

请注意，如果要显示在页边的字符串没有指定字形，那么它的字形将使用与显示在文
本区域的字符串相同的规则和优先级来确定 (@pxref{显示字形})。如果这
导致不理想的字形"泄漏"到页边距中，请确保字符串有一个明确的字形。

在显示边距能够显示任何东西之前，你必须给它们一个非零的宽度。通常的方法是设
置这些变量：

@defvar left-margin-width
这个变量指定左边距的宽度，以字符单元格（又名@:‘列’）为单位。在所有缓冲区中
，它都是缓冲区本地的。值为@code{nil}表示没有左边缘区域。
@end defvar

@defvar right-margin-width
这个变量指定右边距的宽度，以字符单元为单位。在所有缓冲区中，它都是缓冲区本
地的。值为@code{nil}表示没有右边缘区域。
@end defvar

  设置这些变量不会立即影响窗口。当窗口中显示新的缓冲区时，这些变量会被检查
。因此，您可以通过调用@code{set-window-buffer}使更改生效。不要使用这些变
量来尝试确定当前的左或右边距的宽度，而是使用函数@code{set-window-buffer}
。相反，请使用函数 @code{window-margins}。

  你也可以立即设置边距宽度。

@defun set-window-margins window left &optional right
此函数用于指定窗口@var{window}的边距宽度，以字符单元为单位。参数
@var{left}控制左边的边距，@var{right}控制右边的边距（默认为@code{0}）。

如果@var{window}的大小不足以容纳所需宽度的边距，那么@var{window}的边距将
保持不变。

这里指定的值可以在以后通过调用@code{set-window-buffer}来覆盖。(
@pxref{Buffers and Windows})在@var{window}上使用它的@var{keep-margins}
参数@code{nil}或省略。
@end defun

@defun window-margins &optional window
这个函数以@w{@code{(@var{left} . @var{right})}}的形式返回@var{window}的
左右边距的宽度。如果两个边距中的一个不存在，那么它的宽度将以@code{nil}的形
式返回；如果两个边距都不存在，函数将返回@code{(nil)}。如果@var{window}为
@code{nil}，则使用选定的窗口。
@end defun

@node 图像
@section Images
@cindex images in buffers

  要在Emacs缓冲区中显示图像，必须先创建一个图像描述符，然后将其作为显示文
本的@code{display}属性中的显示指定符（@pxref{Display Property}）。

Emacs在图形终端上运行时，通常能够显示图像。在文本终端上、在某些缺乏支持的
图形终端上，或者Emacs在编译时不支持图像时，不能显示图像。您可以使用函数
@code{display-images-p}来判断原则上是否可以显示图像（
@pxref{Display Feature Testing}）。

@menu
* 图像格式::           支持的图像格式。
* 图像描述符::         如何在@code{:display}中指定一个图像。
* XBM图像::            XBM格式的特殊功能。
* XPM图像::            XPM格式的特殊功能。
* ImageMagick图像::   针对XBM格式的特殊功能。通过ImageMagick提供的特殊
功能。
* SVG图像::           创建和操作SVG图像。
* 其他图像类型::       支持各种其他格式的图像。
* 定义图像::          方便地定义图像，以便以后使用。
* 显示图像::          定义图像后，可方便地显示图像。
* 多帧图像::          方便定义图像后的显示方式。有些图像包含一个以上的画面
。
* 图像缓存::          图像显示的内部机制。
@end menu

@node 图像格式
@subsection Image Formats
@cindex image formats
@cindex image types

  Emacs可以显示许多不同的图像格式。其中一些图像格式只有在安装了特定的支持
库时才会被支持。在某些平台上，Emacs可以按需加载支持库；如果是这样，可以使
用变量@code{dynamic-library-alist}来修改这些动态库的已知名称集。
@xref{Dynamic Libraries}。

  支持的图像格式（以及所需的支持库）包括PBM和XBM（不依赖于支持库，并且始终
可用）、XPM(@code{libXpm})、GIF(@code{libgif}或@code{libungif})、JPEG(
@code{libjpeg})、TIFF(@code{libtiff})、PNG(@code{libpng})和SVG(
@code{librsvg})。

每一种图像格式都有一个@dfn{image type symbol}。上述格式的符号分别是：
@code{pbm}、@code{xbm}、@code{xpm}、@code{gif}、@code{jpeg}、
@code{tiff}、@code{png}和@code{svg}。

此外，如果你在构建Emacs时支持ImageMagick(@code{libMagickWand})，Emacs可
以显示任何ImageMagick可以显示的图像格式。@xref{ImageMagick Images}。所有
通过ImageMagick显示的图像都有类型符号@code{imagemagick}。

@defvar image-types
这个变量包含当前配置中可能支持的图像格式的类型符号列表。

“潜在的”意味着Emacs知道这些图像类型，但不一定能使用它们（例如，它们可能依
赖于不可用的动态库）。要知道哪些图像类型是真正可用的，请使用
@code{imagtype-available-p}。
@end defvar

@defun image-type-available-p
如果可以加载和显示@var{type}类型的图像，则该函数返回非@code{nil}。
@var{type}必须是一个图像类型符号。

对于支持库是静态链接的图像类型，这个函数总是返回@code{t}。对于支持库是动态
加载的图像类型，如果支持库可以加载，则返回@code{t}，否则返回@code{nil}。
@end defun

@node 图像描述符
@subsection Image Descriptors
@cindex image descriptor

  @dfn{image descriptor}是一个列表，它指定了图像的基础数据，以及如何显示
它。它通常被用作@code{display}覆盖或文本属性的值（
@pxref{Other Display Specs}）；但@xref{Showing Images}，用于方便助手函数
将图像插入缓冲区。

  每个图像描述符的形式为@code{(image .@var{props})}，其中@var{props}是关
键字符号和值交替的属性列表，至少包括指定图像类型的一对
@code{:type @var{type}}。

  以下是对所有图像类型都有意义的属性列表（也有一些属性仅对某些图像类型有意
义，如以下小节所述）:

@table @code
@item :type @var{type}
图像类型。
@ifnottex
@xref{Image Formats}.
@end ifnottex
每个图像描述符都必须包含这个属性。

@item :file @var{file}
这表示要从文件@var{file}中加载图像。如果@var{file}不是一个绝对的文件名，
那么它展开相对于@code{data-directory}的@file{images}子目录，如果失败，相
对于@code{x-bitmap-file-path}(@pxref{Face Attributes})列出的目录。

@item :data @var{data}
这指定了原始图像数据。每个图像描述符必须有@code{:data}或@code{:file}，但
不能同时使用。

对于大多数图像类型，@code{:data}属性的值应该是一个包含图像数据的字符串。有
些图像类型不支持@code{:data}；对于其他一些图像类型，仅使用@code{:data}是
不够的，所以您需要在使用@code{:data}的同时使用其他图像属性。详情请参见下面
的小节。

@item :margin @var{margin}
指定在图像周围增加多少像素作为额外的边距。值@var{margin}必须是一个非负数，
或者是一对@code{(@var{x} . @var{y})}这样的数字。如果是一对，则@var{x}指定
水平方向增加多少像素，@var{y}指定垂直方向增加多少像素。如果没有指定
@code{:margin}，则默认为0。

@item :ascent @var{ascent}
指定图像的上升高度，也就是基线以上的部分。值@var{ascent}必须是0到100范围内
的数字，或者符号@code{center}。

如果@var{ascent}是一个数字，那么图像高度的百分比就会被用于其上升。

如果@var{ascent}是@code{center}，则图像围绕中心线垂直居中，该中心线将是在
图像位置绘制的文本的垂直中心线，其方式由应用于图像的文本属性和覆盖指定。

如果这个属性被忽略了，默认是50。

@item :relief @var{relief}
这将在图像周围添加一个阴影矩形。值@var{relief}指定阴影线的宽度，单位为像素
。如果@var{relief}为负值，则绘制的阴影会使图像显示为被按下的按钮，否则显示
为未按下的按钮。

@item :width @var{width}, :height @var{height}
@code{:width}和@code{:height}关键字用于缩放图像。如果只指定了其中一个关键
字，则会计算另一个关键字以保留长宽比。如果同时指定了这两个关键字，则可能不
会保留长宽比。

@item :max-width @var{max-width}, :max-height @var{max-height}
@code{:max-width}和@code{:max-height}关键字用于在图像的大小超过这些值时进
行缩放。如果设置了@code{:width}，它将优先于@code{max-width}，如果设置了
@code{:height}，它将优先于@code{max-height}，但您也可以根据自己的意愿混合
使用这些关键字。

如果同时指定了@code{:max-width}和@code{:height}，但没有指定@code{:width}
，那么为了保持长宽比，宽度可能需要超过@code{:max-width}。如果发生这种情况
，缩放将使用一个较小的高度值，以便在不超过@code{:max-width}的情况下保留长
宽比。同样地，当@code{:max-height}和@code{:width}都被指定，但
@code{:height} 没有被指定时，也会出现这种情况。例如，如果您有一个200x100
的图像，并指定@code{:width}应该是400，而@code{:max-height}应该是150，那
么您最终会得到一个300x150的图像。保留长宽比，但不超过"最大"设置。这种参数
组合是一种有用的方式，可以说"尽可能大地显示这张图片，但不能超过可用的显示区
域"。

@item :scale @var{scale}
这应该是一个数字，大于1的值表示增加大小，小于1的值表示减少大小，将宽度和高
度相乘。例如，0.25的值将使图像的大小为原来的四分之一。如果缩放使图像大于
@code{:max-width}或@code{:max-height}所指定的尺寸，则产生的尺寸不会超过这
两个值。如果同时指定了@code{:scale}和@code{:height}/@code{:width}，则高
度/宽度将根据指定的缩放系数进行调整。

@item :rotation @var{angle}
指定旋转角度，单位为度。只支持90度的倍数，除非图像类型是@code{imagemagick}
。正值为顺时针旋转，负值为逆时针旋转。旋转是在缩放和裁剪之后进行的。

@item :index @var{frame}
@xref{Multi-Frame Images}.

@item :conversion @var{algorithm}
此项指定了在图像显示之前应该应用的转换算法；值@var{algorithm}指定了哪种算
法。

@table @code
@item laplace
@itemx emboss
指定拉普拉斯边缘检测算法，该算法可以模糊掉小的颜色差异，同时突出较大的差异
。人们有时认为这对显示禁用按钮的图像很有用。

@item (edge-detection :matrix @var{matrix} :color-adjust @var{adjust})
@cindex edge detection, images
指定一个通用的边缘检测算法。@var{matrix}必须是一个九元素的列表或一个九元素
的数字向量。变换后的图像中@math{x/y}位置上的像素是根据该位置周围的原始像素
计算出来的，@var{matrix}指定了每个像素的边缘检测算法。@var{matrix}为
@math{x/y}附近的每一个像素指定了一个因子，该像素将对变换后的像素产生影响；
@math{0}元素指定了@math{x-1/y-1}处像素的因子，@math{1}元素指定了
@math{x/y-1}处像素的因子，等等，如下所示:
@iftex
@tex
$$\pmatrix{x-1/y-1 & x/y-1  & x+1/y-1 \cr
   x-1/y  &   x/y &    x+1/y \cr
   x-1/y+1&   x/y+1 &  x+1/y+1 \cr}$$
@end tex
@end iftex
@ifnottex
@display
  (x-1/y-1  x/y-1  x+1/y-1
   x-1/y    x/y    x+1/y
   x-1/y+1  x/y+1  x+1/y+1)
@end display
@end ifnottex

将周围像素的RGB值相加，乘以指定的系数，再将该和除以系数的绝对值之和，计算出
结果像素的颜色强度。

拉普拉斯边缘检测目前使用的矩阵为
@iftex
@tex
$$\pmatrix{1 & 0 & 0 \cr
   0&  0 &  0 \cr
   0 & 0 & -1 \cr}$$
@end tex
@end iftex
@ifnottex
@display
  (1  0  0
   0  0  0
   0  0 -1)
@end display
@end ifnottex

浮雕边缘检测使用的是一个矩阵，其内容为
@iftex
@tex
$$\pmatrix{ 2 & -1 &  0 \cr
   -1 &  0 &  1 \cr
    0  & 1 & -2 \cr}$$
@end tex
@end iftex
@ifnottex
@display
  ( 2 -1  0
   -1  0  1
    0  1 -2)
@end display
@end ifnottex

@item disabled
指定转换图像，使其看起来被禁用。
@end table

@item :mask @var{mask}
如果@var{mask}是@code{heuristic}或@code{(heuristic @var{bg})}，为图像
建立一个剪裁蒙版，使图像后面的帧背景可见。如果没有指定@var{bg}，或者
@var{bg}是@code{t}，则通过观察图像的四个角来确定图像的背景色，假设从角上最
常出现的颜色就是图像的背景色。否则，@var{bg}必须是一个列表
@code{(@var{red} @var{green} @var{blue})}，指定图像背景的颜色。

如果@var{mask}是@code{nil}，那么如果图像中有蒙版，则从图像中移除蒙版。某
些格式的图片中包含有蒙版，可以通过指定@code{:mask nil}来移除。

@item :pointer @var{shape}
这指定了鼠标指针在此图像上时的指针形状。@xref{Pointer Shape}，查看可用的
指针形状。

@item :map @var{map}
@cindex image maps
这将@dfn{hot spots}的图像映射与此图像关联起来。

图像映射是一个alist，其中每个元素的格式为
@code{(@var{area} @var{id} @var{plist})}。一个@var{area}被指定为一个矩形
、一个圆形或一个多边形。

矩形是一个cons @code{(rect .((@var{x0} . @var{y0}) .(@var{x1} . @var{y1}))}，它指定了矩形区域左上角和右下角的像素坐标。

圆是一个cons @code{(circle .((@var{x0} . @var{y0}) .((@var{r}))}指定了
圆的中心和半径；@var{r}可以是一个浮点数或整数。

多边形是一个cons
@code{(poly . [@var{x0} @var{y0} @var{x1} @var{y1} ...]}，其中向量中的
每一对都描述了多边形中的一个角。

当鼠标指针位于图像的热点区域时，会查询该热点的@var{plist}，如果包含
@code{help-echo}属性，则定义该热点的工具提示，如果包含@code{pointer}属性
，则定义鼠标光标在热点上时的形状。@xref{Pointer Shape}，用于表示可用的指针
形状。

当鼠标指针在热点上点击鼠标时，将热点的@var{id}与鼠标事件结合起来组成一个事
件，例如，如果热点的@var{id}是@code{area4}，则@code{[area4 mouse-1]}。
@end table

@defun image-mask-p spec &optional frame
如果图像@var{spec}有蒙版位图，则该函数返回@code{t}。@var{frame}是显示图像
的窗框。@code{nil}或省略表示使用选定的窗框（@pxref{Input Focus}）。
@end defun

@defun image-transforms-p &optional frame
如果@var{frame}支持图像的缩放和旋转，则该函数返回非@code{nil}。如果
@var{frame}支持图像的缩放和旋转，则返回非@code{nil}。@code{nil}或省略表示
使用选定的窗框（@pxref{Input Focus}）。返回的列表中包含了表示支持哪些图像
变换操作的符号:

@table @code
@item scale
图片缩放由@var{frame}通过@code{:scale}, @code{:width}, @code{:height},
@code{:max-width}和@code{:max-height}属性支持。
@item rotate90
如果旋转角度是90度的整数倍，则@var{frame}支持图像旋转。
@end table

如果不支持图像转换，@code{:rotation}、@code{:crop}、@code{:width}、
@code{:height}、@code{:scale}、@code{:max-width}和@code{:max-height}
将只能通过ImageMagick使用（如果可用的话） (@pxref{ImageMagick Images})。
@end defun
@node XBM图像
@subsection XBM Images
@cindex XBM

  要使用XBM格式，请指定@code{xbm}作为图像类型。这种图像格式不需要外部库，
所以总是支持这种类型的图像。

  @code{xbm}图像类型支持的其他图像属性有：

@table @code
@item :foreground @var{foreground}
值@var{foreground}应该是指定图像前景色的字符串，或者@code{nil}表示默认颜
色。这个颜色用于XBM中每一个像素为1的地方，默认为帧的前景色。

@item :background @var{background}
值@var{background}应该是一个指定图像背景颜色的字符串，或者@code{nil}表示
默认颜色。这个颜色用于XBM中每个像素为0的地方，默认为帧的背景色。
@end table

  如果您使用Emacs中的数据而不是外部文件来指定XBM图像，请使用以下三个属性:

@table @code
@item :data @var{data}
值@var{data}，指定了图像的内容。有三种格式可以用于@var{data}：

@itemize @bullet
@item
由字符串或布尔向量组成的向量，每个向量指定一行图像。请指定@code{:height}
和@code{:width}。

@item
一个包含与XBM文件相同字节序列的字符串。在这种情况下，您不能指定
@code{:height}和@code{:width}，因为省略他们就表示数据具有XBM文件的格式。
文件内容指定了图像的高度和宽度。
@item
一个字符串或一个布尔向量，包含图像的位数(加上最后一些不使用的额外位数)。它应该至少包含@w{@code{@var{stride} * @var{height}}}位，其中@var{stride}
是大于或等于图像宽度的8的最小倍数。在这种情况下，您应该指定@code{:height}
、@code{:width}和@code{:stride}，这既是为了表明字符串只包含位而不是整个
XBM文件，也是为了指定图像的大小。
@end itemize

@item :width @var{width}
值@var{width}，指定图像的宽度，单位为像素。

@item :height @var{height}
值@var{height}，指定图像的高度，单位为像素。

@item :stride @var{stride}
每行存储的布尔向量条目数，大于或等于@var{width}的8的最小倍数。
@end table

@node XPM图像
@subsection XPM Images
@cindex XPM

  要使用XPM格式，请指定@code{xpm}作为图像类型。附加的图像属性
@code{:color-symbols}对@code{xpm}图像类型也有意义:

@table @code
@item :color-symbols @var{symbols}
值@var{symbols}应该是一个alist，其元素的形式为
@code{(@var{name} . @var{color})}。在每个元素中，@var{name}是一个颜色的
名称，因为它出现在图像文件中，而@var{color}则指定了用于显示该名称的实际颜
色。
@end table

@node ImageMagick图像
@subsection ImageMagick Images
@cindex ImageMagick images
@cindex images, support for more formats

  如果您的Emacs构建支持ImageMagick，您可以使用ImageMagick库来加载多种图像
格式（@pxref{File Conveniences,,,emacs,The GNU Emacs Manual}）。通过
ImageMagick加载的图像的图像类型符号是@code{imagemagick}，与实际的图像格式
无关。

要检查ImageMagick是否支持，请使用以下方法:

@lisp
(image-type-available-p 'imagemagick)
@end lisp

@defun imagemagick-types
该函数返回当前ImageMagick安装支持的图像文件扩展名列表。每个列表元素都是一
个符号，代表ImageMagick内部的图像类型名称，例如@code{BMP}代表@file{.bmp}
图像。
@end defun

@defopt imagemagick-enabled-types
这个变量的值是一个ImageMagick图像类型的列表，Emacs可以尝试使用ImageMagick
来渲染。每个列表元素应该是@code{imagemagick-types}返回的列表中的一个符号
，或者一个等价的字符串。或者，@code{t}的值可以使ImageMagick支持所有可能的
图像类型。无论这个变量的值是多少，@code{imagemagick-types-inhibit}(见下文
)优先。
@end defopt

@defopt imagemagick-types-inhibit
不管@code{imagemagick-enabled-types}的值是多少，这个变量的值列出了永远不
应该使用ImageMagick渲染的ImageMagick图像类型。值为@code{t}时，会完全禁用
ImageMagick。
@end defopt

@defvar image-format-suffixes
这个变量是一个将图像类型映射到文件名扩展名的列表。Emacs结合@code{:format}
图像属性(见下文)使用这个变量，以提示ImageMagick库了解图像的类型。每个元素
都有@code{(@var{type} @var{extension})}的形式，其中@var{type}是一个指定
图像内容类型的符号，@var{extension}是一个指定相关文件名扩展名的字符串。
@end defvar

  ImageMagick加载的图像支持以下附加的图像描述符属性：

@table @code
@item :background @var{background}
如果@var{background}不是@code{nil}，则应该是一个指定颜色的字符串，如果图
像支持透明，则用它作为图像的背景色。如果值是@code{nil}，则默认为窗框的背景
色。

@item :format @var{type}
值@var{type}应该是一个符号，指定图像数据的类型，如
@code{image-format-suffixes}中所示。当图像没有相关的文件名时，这个值可以
用来给ImageMagick提供一个提示，帮助它检测图像的类型。

@item :crop @var{geometry}
@var{geometry}的值应该是一个
@code{(@var{width} @var{height} @var{x} @var{y})}形式的列表。
@var{width}和@var{height}指定了裁剪后图片的宽度和高度。如果@var{x}是一个
正数，则指定裁剪后的区域与原图左边的偏移量，如果是负数，则指定与右边的偏移
量。如果@var{y}是正数，则表示从原始图像的顶部开始偏移，如果是负数，则表示
从底部开始偏移。如果@var{x}或@var{y}是@code{nil}或未指定，则裁剪区域将以
原始图像为中心。

如果裁剪区域在图像的边缘之外或与图像的边缘重叠，那么它将被缩小以排除图像之
外的任何区域。这意味着不可能使用@code{:crop}通过输入较大的@var{width}或
@var{height}值来增加图像的大小。

裁剪是在缩放之后但在旋转之前进行的。
@end table

@node SVG图像
@subsection SVG Images
@cindex SVG images

SVG（Scalable Vector Graphics）是一种用于指定图像的XML格式。如果您的Emacs
构建有SVG支持，您可以使用@file{svg.el}库中的以下函数创建和操作这些图像。

@defun svg-create width height &rest args
创建一个新的、空的SVG图像，并指定其尺寸。@var{args}是一个参数列表，你可以
指定以下参数:

@table @code
@item :stroke-width
创建的任何线条的默认宽度（像素）。

@item :stroke
创建的任何线条上的默认填充颜色。
@end table

@cindex SVG object
这个函数返回一个@dfn{SVG object}，这是一个指定SVG图像的Lisp数据结构，下面
的所有函数都在这个结构上工作。在下面的函数中，参数@var{svg}指定了这样一个
SVG对象。
@end defun

@defun svg-gradient svg id type stops
在@var{svg}中创建一个渐变，标识符为@var{id}。@var{type}是指定渐变类型，可
以是@code{linear}或@code{radial}。@var{stops}是一个百分比/颜色对的列表，
可以是@code{linear}或@code{radial}。

下面将创建一个线性梯度，从开始的红色，到25%的绿色，再到最后的蓝色:

@lisp
(svg-gradient svg "gradient1" 'linear
              '((0 . "red") (25 . "green") (100 . "blue")))
@end lisp

创建的梯度（并插入到SVG对象中）以后可以被所有创建形状的函数使用。
@end defun

下面的所有函数都采用了一个可选的关键字参数列表，用于改变各种属性的默认值。
有效的属性包括：

@table @code
@item :stroke-width
绘制的线条宽度（像素），以及实线形状周围的轮廓。

@item :stroke-color
绘制的线条的颜色，以及实线形状周围的轮廓。

@item :fill-color
用于实线形状的颜色。

@item :id
形状的标识。

@item :gradient
如果给定，这应该是先前定义的梯度对象的标识符。

@item :clip-path
夹子路径的标识符。
@end table

@defun svg-rectangle svg x y width height &rest args
在@var{svg}中添加一个左上角位于@var{x}/@var{y}位置，大小为@var{width}/
@var{height}的矩形。

@lisp
(svg-rectangle svg 100 100 500 500 :gradient "gradient1")
@end lisp
@end defun

@defun svg-circle svg x y radius &rest args
在@var{svg}中添加一个圆，圆心在@var{x}/@var{y}，半径为@var{radius}。
@end defun

@defun svg-ellipse svg x y x-radius y-radius &rest args
在@var{svg}中添加一个中心位于@var{x}/@var{y}的椭圆，其水平半径为
@var{x-radius}，垂直半径为@var{y-radius}。
@end defun

@defun svg-line svg x1 y1 x2 y2 &rest args
在@var{svg}中添加从@var{x1}/@var{y1}开始并延伸到@var{x2}/@var{y2}的一行
。
@end defun

@defun svg-polyline svg points &rest args
在@var{svg}中添加一条多段线 (又名@: ``polyline'')，它穿过@var{points}，
这是一个X/Y位置对的列表。

@lisp
(svg-polyline svg '((200 . 100) (500 . 450) (80 . 100))
              :stroke-color "green")
@end lisp
@end defun

@defun svg-polygon svg points &rest args
在@var{svg}中添加一个多边形，其中@var{points}是描述多边形外周长的X/Y对的
列表。

@lisp
(svg-polygon svg '((100 . 100) (200 . 150) (150 . 90))
             :stroke-color "blue" :fill-color "red")
@end lisp
@end defun

@defun svg-path svg commands &rest args
根据@var{commands}将形状的轮廓添加到@var{svg}中，参见
@ref{SVG Path Commands}。

默认情况下，坐标是绝对坐标。要使用相对于最后位置的坐标，或者--最初--相对于原点的坐标，请将属性@var{:relative}设置为@code{t}。这个属性可以为函数指定
，也可以为单个命令指定。如果为函数指定了这个属性，那么所有命令都默认使用相
对坐标。要让个别命令使用绝对坐标，请将@var{:relative}属性设置为@code{nil}
。

@lisp
(svg-path svg
	  '((moveto ((100 . 100)))
	    (lineto ((200 . 0) (0 . 200) (-200 . 0)))
	    (lineto ((100 . 100)) :relative nil))
	  :stroke-color "blue"
	  :fill-color "lightblue"
	  :relative t)
@end lisp
@end defun

@defun svg-text svg text &rest args
将指定的@var{text}添加到@var{svg}中。

@lisp
(svg-text
 svg "This is a text"
 :font-size "40"
 :font-weight "bold"
 :stroke "black"
 :fill "white"
 :font-family "impact"
 :letter-spacing "4pt"
 :x 300
 :y 400
 :stroke-width 1)
@end lisp
@end defun

@defun svg-embed svg image image-type datap &rest args
在@var{svg}中添加一个嵌入式(栅格)图像。如果@var{datap}是@code{nil}，则
@var{image}应该是一个文件名，否则应该是一个包含原始字节的图像数据的字符串
。@var{image-type}应该是一个@acronym{MIME}图像类型，例如
@code{"image/jpeg"}。

@lisp
(svg-embed svg "~/rms.jpg" "image/jpeg" nil
           :width "100px" :height "100px"
           :x "50px" :y "75px")
@end lisp
@end defun

@defun svg-clip-path svg &rest args
为@var{svg}添加一个剪切路径。如果通过@var{:clip-path}属性应用于一个形状，
那么位于剪切路径之外的形状部分将不会被绘制。

@lisp
(let ((clip-path (svg-clip-path svg :id "foo")))
  (svg-circle clip-path 200 200 175))
(svg-rectangle svg 50 50 300 300
               :fill-color "red"
               :clip-path "url(#foo)")
@end lisp
@end defun

@defun svg-node svg tag &rest args
将自定义节点@var{tag}添加到@var{svg}。

@lisp
(svg-node svg
          'rect
          :width 300 :height 200 :x 50 :y 100 :fill-color "green")
@end lisp
@end defun

@defun svg-remove svg id
从@code{svg}中删除带有标识符@code{id}的元素。
@end defun

@defun svg-image svg
最后，@code{svg-image}接收一个SVG对象作为参数，并返回一个适合在
@code{insert-image}等函数中使用的图像对象。
@end defun

这里有一个完整的例子，可以创建并插入一个带有圆形的图像:

@lisp
(let ((svg (svg-create 400 400 :stroke-width 10)))
  (svg-gradient svg "gradient1" 'linear '((0 . "red") (100 . "blue")))
  (svg-circle svg 200 200 100 :gradient "gradient1"
                  :stroke-color "green")
  (insert-image (svg-image svg)))
@end lisp


@subsubheading SVG Path Commands

@cindex svg path commands
@anchor{SVG Path Commands}
@dfn{SVG路径}允许通过组合线条创建复杂的图像。曲线、弧线和其他基本形状。下
面描述的函数允许从Lisp程序中调用SVG路径命令。

@deffn Command moveto points
将笔移动到@var{points}中的第一个点。其他的点用线连接。@var{points}是一个X
/Y坐标对的列表。随后的@command{moveto}命令代表一个新的@dfn{subpath}的开始
。

@lisp
(svg-path svg '((moveto ((200 . 100) (100 . 200) (0 . 100))))
          :fill "white" :stroke "black")
@end lisp
@end deffn

@deffn Command closepath
将当前子路径连接回初始点，结束当前子路径。沿着连接点画一条线。

@lisp
(svg-path svg '((moveto ((200 . 100) (100 . 200) (0 . 100)))
                (closepath)
                (moveto ((75 . 125) (100 . 150) (125 . 125)))
                (closepath))
          :fill "red" :stroke "black")
@end lisp
@end deffn

@deffn Command lineto points
从当前点到@var{points}中的第一个元素（X/Y位置对的列表）画一条直线。如果指
定了一个以上的点，则画一条多段线。
@lisp
(svg-path svg '((moveto ((200 . 100)))
                (lineto ((100 . 200) (0 . 100))))
          :fill "yellow" :stroke "red")
@end lisp
@end deffn

@deffn Command horizontal-lineto x-coordinates
从当前点到@var{x-coordinates}中的第一个元素画一条水平线。可以指定多个坐标
，尽管通常这样做没有意义。

@lisp
(svg-path svg '((moveto ((100 . 200)))
                (horizontal-lineto (300)))
          :stroke "green")
@end lisp
@end deffn

@deffn Command vertical-lineto y-coordinates
画出垂直线。

@lisp
(svg-path svg '((moveto ((200 . 100)))
                (vertical-lineto (300)))
          :stroke "green")
@end lisp
@end deffn

@deffn Command curveto coordinate-sets
使用@var{coordinate-sets}中的第一个元素，从当前点开始画一条立方贝塞尔曲线。如果
有多个坐标集，请画出一个多边形贝塞尔曲线。每个坐标集都是一个形式为
@code{(@var{x1} @var{y1} @var{x2} @var{y2} @var{x} @var{y})}
的列表，其中的@w{(@var{x}, @var{y})}是曲线的端点。@w{(@var{x1}, @var{y1})}和
@w{(@var{x2}, @var{y2})}分别是起点和终点的控制点。

@lisp
(svg-path svg '((moveto ((100 . 100)))
                (curveto ((200 100 100 200 200 200)
                          (300 200 0 100 100 100))))
          :fill "transparent" :stroke "red")
@end lisp
@end deffn

@deffn Command smooth-curveto coordinate-sets
使用@var{coordinate-sets}中的第一个元素，从当前点开始画一条立方贝塞尔曲线。如果
有多个坐标集，请画出一个多边形贝塞尔曲线。每个坐标集都是一个形式为
@code{(@var{x2} @var{y2} @var{x} @var{y})}的列表，其中
@w{(@var{x}, @var{y})}是曲线的端点，@w{(@var{x2}, @var{y2})}是对应的控制点。
第一个控制点是前一个命令的第二个控制点相对于当前点的反射，如果该命令是
@command{curveto}或@command{smooth-curveto}。否则，第一个控制点与当前点重合。

@lisp
(svg-path svg '((moveto ((100 . 100)))
                (curveto ((200 100 100 200 200 200)))
                (smooth-curveto ((0 100 100 100))))
          :fill "transparent" :stroke "blue")
@end lisp
@end deffn

@deffn Command quadratic-bezier-curveto coordinate-sets
使用@var{coordinate-sets}中的第一个元素，从当前点开始画一条二次方程贝塞尔曲线。
如果有多个坐标集，则画一条多边形贝塞尔曲线。每个坐标集都是
@code{(@var{x1} @var{y1} @var{x} @var{y})}形式的列表，其中
@w{(@var{x}, @var{y})}是曲线的端点，@w{(@var{x1}, @var{y1})}是控制点。

@lisp
(svg-path svg '((moveto ((200 . 100)))
                (quadratic-bezier-curveto ((300 100 300 200)))
                (quadratic-bezier-curveto ((300 300 200 300)))
                (quadratic-bezier-curveto ((100 300 100 200)))
                (quadratic-bezier-curveto ((100 100 200 100))))
          :fill "transparent" :stroke "pink")
@end lisp
@end deffn

@deffn Command smooth-quadratic-bezier-curveto coordinate-sets
使用@var{coordinate-sets}中的第一个元素，从当前点开始画一条二次方程贝塞尔曲线。
如果有多个坐标集，请画出一个多边形贝塞尔曲线。每个坐标集都是
@code{(@var{x} @var{y})}形式的列表，其中@w{(@var{x}, @var{y})}是曲线的端点。
控制点是前一个命令的控制点相对于当前点的反射，如果那个命令是
@command{quadratic-bezier-curveto}或
@command{smooth-quadratic-bezier-curveto}。否则控制点与当前点重合。

@lisp
(svg-path svg '((moveto ((200 . 100)))
                (quadratic-bezier-curveto ((300 100 300 200)))
                (smooth-quadratic-bezier-curveto ((200 300)))
                (smooth-quadratic-bezier-curveto ((100 200)))
                (smooth-quadratic-bezier-curveto ((200 100))))
          :fill "transparent" :stroke "lightblue")
@end lisp
@end deffn

@deffn Command elliptical-arc coordinate-sets
使用@var{coordinate-sets}中的第一个元素，从当前点开始画一个椭圆弧。如果有多个坐
标集，则绘制一系列的椭圆弧。每个坐标集都是
@code{(@var{rx} @var{ry} @var{x} @var{y})} 形式的列表，其中的
@w{(@var{x}, @var{y})}是椭圆的端点，而@w{(@var{rx}, @var{ry})}是其半径。
以下属性可以附加到列表中:

@table @code
@item :x-axis-rotation
椭圆的X轴相对于当前坐标系的X轴旋转的角度，以度为单位。

@item :large-arc
如果设置为@code{t}，则绘制大于或等于180度的弧线扫描。否则，画一个小于或等于180度的
弧线扫描。

@item :sweep
如果设置为@code{t}，则以@dfn{positive angle direction}画弧，否则以
@dfn{negative angle direction}画弧。
@end table

@lisp
(svg-path svg '((moveto ((200 . 250)))
                (elliptical-arc ((75 75 200 350))))
          :fill "transparent" :stroke "red")
(svg-path svg '((moveto ((200 . 250)))
                (elliptical-arc ((75 75 200 350 :large-arc t))))
          :fill "transparent" :stroke "green")
(svg-path svg '((moveto ((200 . 250)))
                (elliptical-arc ((75 75 200 350 :sweep t))))
          :fill "transparent" :stroke "blue")
(svg-path svg '((moveto ((200 . 250)))
                (elliptical-arc ((75 75 200 350 :large-arc t
                                     :sweep t))))
          :fill "transparent" :stroke "gray")
(svg-path svg '((moveto ((160 . 100)))
                (elliptical-arc ((40 100 80 0)))
                (elliptical-arc ((40 100 -40 -70
                                     :x-axis-rotation -120)))
                (elliptical-arc ((40 100 -40 70
                                     :x-axis-rotation -240))))
          :stroke "pink" :fill "lightblue"
          :relative t)
@end lisp
@end deffn


@node 其他图像类型
@subsection Other Image Types
@cindex PBM

  对于PBM图像，请指定图像类型@code{pbm}。支持彩色、灰度和单色图像。对于单色PBM图
像，支持两个额外的图像属性。

@table @code
@item :foreground @var{foreground}
值@var{foreground}应该是一个指定图像前景色的字符串，或者@code{nil}表示默认颜色
。PBM中每一个像素的颜色都是1，默认为窗框的前景色。

@item :background @var{background}
值@var{background}应该是一个字符串，指定图像的背景色，或者@code{nil}为默认颜色
。这个颜色用于PBM中每个像素为0的地方，默认为窗框的背景色。
@end table

@noindent
Emacs能够支持的其余图像类型有：

@table @asis
@item GIF
图片类型@code{gif}。
支持@code{:index}属性。@xref{Multi-Frame Images}.

@item JPEG
图像类型@code{jpeg}。

@item PNG
图片类型@code{png}。

@item TIFF
图片类型@code{tiff}。
支持@code{:index}属性。@xref{Multi-Frame Images}.
@end table

@node 定义图像
@subsection Defining Images
@cindex define image

  函数@code{creat-image}、@code{defimage}和@code{find-image}提供了创建图像
描述符的便捷方法。

@defun create-image file-or-data &optional type data-p &rest props
这个函数创建并返回一个使用@var{file-or-data}中数据的图像描述符。
@var{file-or-data}可以是一个文件名，也可以是一个包含图像数据的字符串；
@var{data-p}对于前一种情况应该是@code{nil}，对于后一种情况应该是非@code{nil}。

可选参数@var{type}是一个指定图像类型的符号。如果省略了@var{type}或者@code{nil}
，则@code{creat-image}会尝试从文件的前几个字节或文件名中确定图像类型。

其余的参数 @var{props} 用于指定附加的图像属性--例如:

@c ':heuristic-mask'没有被记录下来？
@example
(create-image "foo.xpm" 'xpm nil :heuristic-mask t)
@end example

如果不支持这种类型的图像，函数返回@code{nil}，否则返回一个图像描述符。
@end defun

@defmac defimage symbol specs &optional doc
这个宏定义了@var{symbol}作为图像的名称，参数@var{specs}是一个列表，用于指定如何
显示图像。第三个参数@var{doc}是一个可选的文档字符串。

@var{specs}中的每个参数都是属性列表的形式，每个参数至少要指定@code{:type}属性和
@code{:file}或@code{:data}属性。@code{:type}的值应该是一个指定图像类型的符号，
@code{:file}的值是要从哪个文件加载图像，@code{:data}的值是一个包含实际图像数据的
字符串。下面是一个例子:

@example
(defimage test-image
  ((:type xpm :file "~/test1.xpm")
   (:type xbm :file "~/test1.xbm")))
@end example

@code{defimage}逐个测试每个参数是否可用--也就是说，如果类型是被支持的，并且文件存
在的话。第一个可用的参数被用来制作一个图像描述符，存储在@var{symbol}中。

如果所有的选择都不行，那么@var{symbol}就被定义为@code{nil}。
@end defmac

@defun image-property image property
返回@var{image}中@var{property}的值。属性可以通过使用@code{setf}来设置。如果
将属性设置为@code{nil}，则会从图片中删除该属性。
@end defun

@defun find-image specs
这个函数提供了一个方便的方法来寻找满足图像规格@var{specs}列表中的一个图像。

@var{specs}中的每个规范都是一个属性列表，其内容取决于图像类型。所有的规范必须至少
包含@code{:type @var{type}}和@w{@code{:file @var{file}}或
@w{@code{:data @var{data}}这两个属性，其中@var{type}是指定图像类型的符号，例
如@code{xbm}，@var{file}是要从图像中加载的文件，@var{data}是包含实际图像数据的
字符串。列表中第一个支持@var{type}的规范，并且@var{file}存在，就会被用来构造要返
回的图像规范。如果不满足任何规范，则返回@code{nil}。

图片在@code{image-load-path}中寻找。
@end defun

@defopt image-load-path
这个变量的值是搜索图像文件的位置列表。如果一个元素是字符串或变量符号，其值是字符串，
则该字符串被认为是要搜索的目录名称。如果元素是一个变量符号，其值是一个列表，则表示要
搜索的目录列表。

默认是在@code{data-directory}指定的目录的@file{images}子目录中搜索，然后在
@code{data-directory}指定的目录中搜索，最后在@code{load-path}的目录中搜索。子
目录不会自动包含在搜索中，所以如果你把一个图片文件放在子目录中，你必须明确提供子目录
。例如，要在@code{data-directory}中查找图片@file{images/foo/bar.xpm}，您应
该指定图片如下:

@example
(defimage foo-image '((:type xpm :file "foo/bar.xpm")))
@end example
@end defopt

@defun image-load-path-for-library library image &optional path no-error
这个函数返回一个适合Lisp包@var{library}使用的图片搜索路径。

该函数首先使用@code{image-load-path}搜索@var{image}，不包括
@file{@code{data-directory}/images}，然后在@code{load-path}中搜索，其次是
适合@var{library}的路径，其中包括@file{.../.../etc/images}和
@file{.../etc/images}相对于库文件本身，最后在
@file{@code{data-directory}/images}。

然后，这个函数返回一个目录列表，其中首先包含找到@var{image}的目录，然后是
@code{load-path}的值。如果给定了@var{path}，则使用它代替@code{load-path}。

如果@var{no-error}是非@code{nil}，并且找不到合适的路径，不要发出错误信号。取而代
之的是像之前一样返回一个目录列表，只是@code{nil}代替了image目录。

下面是一个使用@code{image-load-path-for-library}的例子:

@example
(defvar image-load-path) ; shush compiler
(let* ((load-path (image-load-path-for-library
                    "mh-e" "mh-logo.xpm"))
       (image-load-path (cons (car load-path)
                              image-load-path)))
  (mh-tool-bar-folder-buttons-init))
@end example
@end defun

@vindex image-scaling-factor
图片在创建时，会根据@code{image-scaling-factor}变量自动缩放。这个值可以是一个浮
点数（大于1的数字表示增大尺寸，小于1的数字表示缩小尺寸），也可以是符号@code{auto}
，它将根据字体像素大小计算出一个缩放系数。

@node 显示图像
@subsection Showing Images
@cindex show image

  您可以通过自己设置@code{display}属性来使用图像描述符，但使用本节中的函数更容易。

@defun insert-image image &optional string area slice
这个函数在当前缓冲区的点插入@var{image}。值@var{image}应该是一个图像描述符，它可
以是@code{create-image}返回的值，也可以是@code{defimage}定义的一个符号的值。参
数@var{string}指定了要放在缓冲区中的文本，用于保存图像。如果参数@var{string}被省
略或@code{nil}，则@code{insert-image}默认使用@code{" "}。

参数@var{area}指定是否将图片放在页边距中。如果是@code{left-margin}，则图像显示
在左边的空白处；@code{right-margin}指定的是右边的空白处。如果@var{area}为
@code{nil}或被省略，则图像将显示在缓冲区内的文字点上。

参数@var{slice}指定了要插入的图片的一个片断，如果@var{slice}是@code{nil}或省略
，则插入整个图片。如果@var{slice}是@code{nil}或者被省略，则插入整个图像，否则，
@var{slice}是一个列表@code{(@var{x} @var{y} @var{width} @var{height})}，
它指定了@var{x}和@var{y}的位置，以及@var{width}和@var{height}要插入的图像区域
。整数值的单位是像素。0.0--1.0范围内的浮点数代表整个图像的宽度或高度的一部分。

在内部，这个函数在缓冲区中插入@var{string}，并给它一个@code{display}属性，指定
@var{image}。@xref{Display Property}。
@end defun

@cindex slice, image
@cindex image slice
@defun insert-sliced-image image &optional string area rows cols
这个函数在当前缓冲区中插入@var{image}点，就像@code{insert-image}一样，但是将图
像分割成@var{rows}x@var{cols}大小相等的片断。

Emacs将每个片断作为单独的图像显示，并允许更直观地向上/向下滚动，而不是在分页显示（大
）图像的缓冲区时，向上/向下跳转整个图像。
@end defun

@defun put-image image pos &optional string area
此函数将图像@var{image}放在当前缓冲区的@var{pos}前面。参数@var{pos}应该是一个整
数或一个标记，它指定了图片应该出现在缓冲区的位置。参数@var{string}指定了图片的文本
，作为默认值的替代。

参数@var{image}必须是一个图像描述符，可能是由@code{create-image}返回或由
@code{defimage}存储的。

参数@var{area}指定是否将图片放在页边距中。如果是@code{left-margin}，则图像显示
在左边的空白处；@code{right-margin}指定的是右边的空白处。如果@var{area}为
@code{nil}或被省略，则图像将显示在缓冲区内的文字点上。

在内部，这个函数创建了一个叠加，并给它一个包含文本的@code{before-string}属性，该
属性有一个@code{display}属性，其值是图像。(呼！)
@end defun

@defun remove-images start end &optional buffer
该函数用于删除@var{buffer}中位于@var{start}和@var{end}之间的图片。如果省略了
@var{buffer}或者@code{nil}，则从当前的缓冲区中移除图片。

这将只删除被放入@var{buffer}的图片，而不删除通过@code{insert-image}或其他方式
插入的图片。
@end defun

@defun image-size spec &optional pixels frame
@cindex size of image
该函数以形式为一对@w{@code{(@var{width} . @var{height})}}返回图像的大小。
@var{spec}是一个图像规范。@var{pixels}非@code{nil}表示返回以像素为单位的大小，
否则返回以@var{frame}(@pxref{Frame Font})的默认字符大小为单位的大小。
@var{frame}是显示图像的窗框。@code{nil}或省略表示使用选定的窗框（
@pxref{Input Focus}）。
@end defun

@defvar max-image-size
这个变量用于定义Emacs将加载的图像的最大尺寸，Emacs将拒绝加载（和显示）任何大于这个
限制的图像。Emacs将拒绝加载（和显示）任何大于此限制的图像。

如果值是整数，则直接指定最大图像的高度和宽度，以像素为单位。如果是浮点数，则指定最大
图像高度和宽度与窗框高度和宽度的比例。如果该值为非数值，则对图像的大小没有明确的限制
。

这个变量的目的是为了防止不合理的大图片被意外地加载到Emacs中。它只在第一次加载图像时
生效。一旦图像被放置在图像缓存中，即使@code{max-image-size}的值随后被改变，它也可
以一直被显示(@pxref{Image Cache})。
@end defvar

用上述插入功能插入的图像也会得到一个安装在文本属性(或覆盖)中的本地键图，该键图包括了
显示的图像。这个键图定义了以下命令：

@table @kbd
@item +
增加图片大小(@code{image-increase-size})。前缀值为@samp{4}表示增加40%的图片大
小。默认值是20%。

@item -
减少图片大小(@code{image-increase-size})。前缀值为@samp{4}表示减少40%的图片大
小。默认值是20%。

@item r
将图像顺时针旋转90度(@code{image-rotate})。前缀表示逆时针旋转90度。

@item o
将图像保存到文件中(@code{image-save})。
@end table

@node 多帧图像
@subsection Multi-Frame Images
@cindex multi-frame images

@cindex animation
@cindex image animation
@cindex image frames
有些图像文件可以包含一个以上的图像。我们说图像中存在多个"帧"。目前，Emacs支持GIF、
TIFF和某些ImageMagick格式（如DJVM）的多帧。

帧可以用来表示多个页面（例如，这通常是多帧TIFF文件的情况），或者用来创建动画（通常是
多帧GIF文件的情况）。

多帧图像有一个属性@code{:index}，它的值是一个整数（从0开始计算），指定显示的是哪一
帧。

@defun image-multi-frame-p image
如果@var{image}包含多个帧，则此函数返回非@code{nil}。实际的返回值是一个cons
@code{(@var{nimages} . @var{delay})}，其中@var{nimages}是帧数，
@var{delay}是帧与帧之间的延迟，以秒为单位，如果图片没有指定延迟，则返回@code{nil}
。如果图片是为了制作动画，通常会指定一个帧延迟，而如果图片是为了作为多页处理，则不会
指定延迟。
@end defun

@defun image-current-frame image
此函数返回@var{image}当前帧数的索引，从0开始计算。
@end defun

@defun image-show-frame image n &optional nocheck
此函数将@var{image}转换到帧号@var{n}。除非@var{nocheck}是非@code{nil}，否则
它会用有效范围外的帧号来替换有效范围内的帧号。如果@var{image}不包含指定数量的帧，
则图像显示为空心框。
@end defun

@defun image-animate image &optional index limit
此函数将对@var{image}进行动画处理。参数@var{index}是可选的整数，用于指定从哪一帧
开始播放动画（默认为0）。可选参数@var{limit}用于控制动画的长度。如果省略或
@code{nil}，则图像只做一次动画；如果@code{t}，则永远循环；如果是数字，则动画在这
么多秒后停止。
@end defun

@vindex image-minimum-frame-delay
@vindex image-default-frame-delay
@noindent 动画是通过定时器来操作的。请注意，Emacs强加了一个最小帧延迟0.01(
@code{image-minimum-frame-delay})秒。如果图像本身没有指定延迟，Emacs使用
@code{image-default-frame-delay}。

@defun image-animate-timer image
此函数返回负责播放@var{image}动画的计时器（如果有的话）。
@end defun


@node 图像缓存
@subsection Image Cache
@cindex image cache

  Emacs缓存图像，以便它能更有效地再次显示它们。当Emacs显示图像时，它会在图像缓存中
搜索与所需规范相匹配的现有图像规范@code{equal}。如果找到了匹配的规范，则从缓存中显
示图像。否则，Emacs将正常加载图像。

@defun image-flush spec &optional frame
此函数从@var{frame}的图像缓存中删除规格为@var{spec}的图像。使用@code{equal}比
较图像的规格。如果@var{frame}是@code{nil}，则默认为选择的帧。如果@var{frame}是
@code{t}，则会在所有现有的帧上刷新图像。

在Emacs当前的实现中，每个图形终端都拥有一个图像缓存，这个图像缓存由该终端上的所有窗
框共享 (@pxref{Multiple Terminals})。因此，在一个窗框中刷新一个图像，也会在同一
终端上的所有其他窗框中刷新它。
@end defun

  @code{image-flush}的一个用途是告诉Emacs图像文件的变化。如果一个图像规范包含一
个@code{:file}属性，当图像第一次显示时，图像会根据文件的内容进行缓存。即使文件随后
发生变化，Emacs也会继续显示旧版本的图像。调用@code{image-flush}会将图像从缓存中
清除，迫使Emacs在下次需要显示该图像时重新读取文件。

  @code{image-flush}的另一个用途是用于内存保护。如果你的Lisp程序在比
@code{image-cache-eviction-delay}短得多的时间内创建了大量的临时图像，那么就可
以使用@code{image-flush}来保存内存。(见下文)，你可以选择自己刷新未使用的图像，而
不是等待Emacs自动刷新。

@defun clear-image-cache &optional filter
此函数清除图像缓存，并删除所有存储在缓存中的图像。如果@var{filter}被省略或者
@code{nil}被删除，则清除所选窗框的缓存。如果@var{filter}是一个窗框，则清除该窗框
的缓存。如果@var{filter}是@code{t}，则清除所有图像的缓存。否则，@var{filter}将
被视为一个文件名，并且所有与该文件名相关联的图像将从所有图像缓存中移除。
@end defun

如果图像缓存中的图像在指定的时间内没有显示，Emacs就会将其从缓存中删除并释放相关的内
存。

@defvar image-cache-eviction-delay
这个变量指定了图像在缓存中不被显示的秒数，当图像在这个时间段不被显示时，Emacs会从图
像缓存中删除它。当图像在这个时间段内不显示时，Emacs会将其从图像缓存中删除。

在某些情况下，如果缓存中的图片数量增长过大，实际的驱逐延迟可能会比这个时间短。

如果值是@code{nil}，Emacs不会从缓存中删除图像，除非你明确地清除它。这个模式对调试
很有用。
@end defvar

@node Xwidgets
@section Embedded Native Widgets
@cindex xwidget
@cindex embedded widgets
@cindex webkit browser widget

  当Emacs使用必要的支持库构建并在图形终端上运行时，Emacs能够在Emacs缓冲区中显示原
生widget，如GTK+ WebKit widgets。要测试Emacs是否支持显示嵌入式widget，请检查
@code{xwidget-internal}功能是否可用（@pxref{Named Features}）。

  要在缓冲区中显示嵌入式小组件，您必须首先创建一个xwidget对象，然后将该对象用作
@code{display}文本或覆盖属性(@pxref{Display Property})中的显示指定器。

@defun make-xwidget type title width height arguments &optional buffer
该函数创建并返回一个xwidget对象，如果省略@var{buffer}或@code{nil}，则默认为当前
缓冲区。如果省略了@var{buffer}或者@code{nil}，则默认为当前的缓冲区。如果
@var{buffer}命名了一个不存在的缓冲区，那么就会被创建。@var{type}表示xwidget组件
的类型，可以是以下类型之一:

@table @code
@item webkit
WebKit组件。
@end table

参数@var{width}和@var{height}以像素为单位指定小组件的大小，@var{title}是一个字
符串，指定其标题。
@end defun

@defun xwidgetp object
如果@var{object}是一个xwidget，则该函数返回@code{t}，否则返回@code{nil}。
@end defun

@defun xwidget-plist xwidget
此函数返回@var{xwidget}的属性列表。
@end defun

@defun set-xwidget-plist xwidget plist
此函数将@var{xwidget}的属性列表替换为@var{plist}给出的新属性列表。
@end defun

@defun xwidget-buffer xwidget
此函数返回@var{xwidget}的缓冲区。
@end defun

@defun get-buffer-xwidgets buffer
该函数返回与@var{buffer}相关联的xwidget对象列表，可以指定为一个缓冲区对象或一个现
有缓冲区的名称，也可以指定为一个字符串。如果@var{buffer}中没有xwidget对象，则返回
@code{nil}。
@end defun

@defun xwidget-webkit-goto-uri xwidget uri
此函数在给定的@var{xwidget}中浏览指定的@var{uri}。@var{uri}是一个字符串，指定
了一个文件或URL的名称。@c FIXME: 在这个上下文中，URI还可以指定什么？
@end defun

@defun xwidget-webkit-execute-script xwidget script
该函数使@var{xwidget}指定的浏览器小部件执行指定的JavaScript @code{script}。
@end defun

@defun xwidget-webkit-execute-script-rv xwidget script &optional default
这个函数像@code{xwidget-webkit-execute-script}一样执行指定的@var{script}，
但它也以字符串形式返回脚本的返回值。如果@var{script}没有返回值，这个函数将返回
@var{default}，如果省略了@var{default}，则返回@code{nil}。
@end defun

@defun xwidget-webkit-get-title xwidget
此函数以字符串形式返回@var{xwidget}的标题。
@end defun

@defun xwidget-resize xwidget width height
该函数将指定的@var{xwidget}调整为@var{width}x@var{height}像素大小。
@end defun

@defun xwidget-size-request xwidget
此函数以@code{(@var{width} @var{height})}的形式返回@var{xwidget}所需的尺寸。
尺寸以像素为单位。
@end defun

@defun xwidget-info xwidget
这个函数以@code{[@var{type} @var{title} @var{width} @var{height}]}的形式返
回@var{xwidget}的属性。当创建xwidget时，这些属性通常由@code{make-xwidget}决定
。
@end defun

@defun set-xwidget-query-on-exit-flag xwidget flag
这个函数允许你安排Emacs在退出之前或在杀死与@var{xwidget}相关联的缓冲区之前询问用
户确认。如果@var{flag}是非@code{nil}，Emacs会询问用户，否则不会。
@end defun

@defun xwidget-query-on-exit-flag xwidget
此函数返回@var{xwidget}s query-on-exit标志的当前设置，可以是@code{t}或
@code{nil}。
@end defun

@node 按钮
@section Buttons
@cindex buttons in buffers
@cindex clickable buttons in buffers

  Button包定义了用于插入和操作@dfn{buttons}的函数，它可以通过鼠标或键盘命令激活。
这些按钮通常用于各种超链接。

  一个按钮本质上是一组文本或覆盖属性，附着在缓冲区中的一段文本上，这些属性称为
@dfn{button properties}。这些属性中的一个，即@dfn{action property}，指定了一
个函数，当用户使用键盘或鼠标调用该按钮。动作函数可以检查按钮并根据需要使用它的其他属性。

  在某些方面，Button包重复了Widget包的功能。
@xref{Top, , Introduction, widget, The Emacs Widget Library}.Button包的
优势在于它的速度更快，体积更小，编程更简单。从用户的角度来看，两个包产生的界面非常相似。

@menu
* 按钮属性::       具有特殊含义的按钮属性。
* 按钮类型::       定义按钮类的通用属性。
* 制作按钮::       为Emacs缓冲区添加按钮。
* 操作按钮::       获取和设置按钮的属性。
* 按钮缓冲区命令::  缓冲区内的命令和绑定。
@end menu

@node 按钮属性
@subsection Button Properties
@cindex button properties

  每个按钮都有一个相关的属性列表，定义了它的外观和行为，其他的任意属性可以用于应用程
序的特定目的。以下属性对Button包有特殊意义:

@table @code
@item action
@kindex action @r{(button property)}
当用户调用按钮时要调用的函数，该函数传递了一个参数@var{button}。默认情况下，该函数
是@code{ignore}，它什么都不做。

@item mouse-action
@kindex mouse-action @r{(button property)}
这与@code{action}类似，如果存在，将代替@code{action}用于鼠标点击产生的按钮调用
（而不是用户点击@key{RET}）。如果不存在，则使用@code{action}来代替鼠标点击。

@item face
@kindex face @r{(button property)}
这是一个Emacs字形，控制该类型按钮的显示方式，默认情况下是@code{button}字形。

@item mouse-face
@kindex mouse-face @r{(button property)}
这是一个额外的字形，用于控制鼠标移动时的外观（与通常的按钮字形合并）；默认情况下，这
是Emacs @code{highlight}字形。

@item keymap
@kindex keymap @r{(button property)}
按钮的键位图，定义在按钮区域内活动的绑定。默认情况下，这就是通常的按钮区域键位图，存
储在变量@code{button-map}中，它定义了@key{RET}和@key{mouse-2}来调用按钮。

@item type
@kindex type @r{(button property)}
按钮类型。@xref{按钮类型}.

@item help-echo
@kindex help-echo @r{(button property)}
Emacs工具提示帮助系统显示的字符串；默认是
@code{"mouse-2, RET: Push this button"}。或者，一个返回的函数，或者一个评估为
要显示的字符串的形式，或者@code{nil}。详情请参见@ref{Text help-echo}。

函数调用时有三个参数：@var{window}、@var{object}和@var{pos}。第二个参数
@var{object}是拥有该属性的覆盖层（对于覆盖层按钮），或者是包含按钮的缓冲区（对于文
本属性按钮）。其他参数的含义与特殊文本属性 @code{help-echo} 相同。

@item follow-link
@kindex follow-link @r{(button property)}
@code{follow-link}属性，定义了@key{mouse-1}点击这个按钮的行为，
@xref{Clickable Text}。

@item button
@kindex button @r{(button property)}
所有按钮都有一个非@code{nil}的@code{button}属性，它可以用来查找包含按钮的文本区
域（这就是标准按钮函数的作用）。
@end table

  还有其他的属性被定义为按钮中的文本区域，但这些属性对于典型的用途来说一般不感兴趣。

@node 按钮类型
@subsection Button Types
@cindex button types

  每个按钮都有一个@dfn{button type}，它定义了按钮属性的默认值。按钮类型被安排在一
个层次结构中，专门的类型从更多的通用类型中继承，因此很容易为特定任务定义特殊用途的按
钮类型。

@defun define-button-type name &rest properties
定义一个名为@var{name}的按钮类型（一个符号）。其余的参数构成了一个
@var{property value}对的序列，指定了此类型按钮的默认属性值(在创建按钮时，可以通过
使用@code{:type}关键字参数，给它一个@code{type}属性来设置按钮的类型)。

此外，关键字参数@code{:supertype}可以用来指定一个按钮类型，而@var{name}可以从这
个类型继承它的默认属性值。请注意，这种继承只发生在@var{name}被定义的时候；随后对超
类型的更改不会反映在其子类型中。
@end defun

  使用@code{define-button-type}来定义按钮的默认属性并不是必须的--没有任何指定类
型的按钮使用内置的按钮类型@code{button}--但是我们鼓励这样做，因为这样做通常会使
生成的代码更加清晰和高效。

@node 制作按钮
@subsection Making Buttons
@cindex making buttons

  按钮与文本区域相关联，使用覆盖或文本属性来保存按钮的特定信息，所有这些信息都是由按
钮的类型（默认为内置的按钮类型@code{button}）初始化的。像所有Emacs文本一样，按钮
的外观由@code{face}属性控制；默认情况下（通过从@code{button}按钮类型继承的
@code{face}属性），这是一个简单的下划线，就像一个典型的网页链接。

  为了方便起见，有两种按钮创建函数，一种是将按钮属性添加到缓冲区的现有区域中，称为
@code{make-...button}，另一种是同时插入按钮文本，称为@code{insert-...button}
。

  按钮创建函数都使用@code{&rest}参数@var{properties}，它应该是一个
@var{property value}对的序列，指定要添加到按钮的属性；参见
@ref{按钮属性}。此外，关键字参数@code{:type}可以用来指定一个按钮类型
，用来继承其他属性；参见@ref{按钮类型}。任何在创建过程中没有明确指定的属性将
从按钮的类型中继承（如果类型定义了这样的属性）。

以下函数使用覆盖层（@pxref{Overlays}）添加按钮，以保持按钮属性：

@defun make-button beg end &rest properties
在当前的缓冲区中，从@var{beg}到@var{end}制作一个按钮，并将其返回。
@end defun

@defun insert-button label &rest properties
在点上插入一个带有@var{label}标签的按钮，并返回。
@end defun

  下面的函数类似，但使用文本属性（@pxref{Text Properties}）来存放按钮属性。这样
的按钮不会向缓冲区添加标记，所以如果按钮数量极多，缓冲区中的编辑速度也不会变慢。但是，如果文本上有一个现有的面文本属性（例如，由字体锁定模式分配的面），按钮面可能不可见。这两个函数都会返回新按钮的起始位置。

@defun make-text-button beg end &rest properties
使用文本属性，在当前缓冲区中制作一个从@var{beg}到@var{end}的按钮。
@end defun

@defun insert-text-button label &rest properties
该函数使用文本属性在点上插入一个带有@var{label}标签的按钮。
@end defun

@node 操作按钮
@subsection Manipulating Buttons
@cindex manipulating buttons

这些是用于获取和设置按钮属性的函数。通常这些函数被按钮的调用函数用来决定做什么。

当指定了@var{button}参数时，它指的是一个指向特定按钮的对象，可以是覆盖（对于覆盖按
钮），也可以是缓冲区位置或标记（对于文本属性按钮）。当按钮被调用时，这样的对象会作为
第一个参数传递给按钮的调用函数。

@defun button-start button
返回@var{button}的起始位置。
@end defun

@defun button-end button
返回@var{button}结束的位置。
@end defun

@defun button-get button prop
获取名为@var{button}的按钮的属性，名为@var{prop}。
@end defun

@defun button-put button prop val
将@var{button}的@var{prop}属性设置为@var{val}。
@end defun

@defun button-activate button &optional use-mouse-action
调用@var{button}的@code{action}属性（即调用该属性值的函数，将单个参数
@var{button}传递给它）。如果@var{use-mouse-action}是非@code{nil}，则尝试调用
按钮的@code{mouse-action}属性，而不是@code{action}；如果按钮没有
@code{mouse-action}属性，则正常使用@code{action}。如果@var{button}中存在
@code{button-data}属性，则使用该属性作为@code{action}函数的参数，而不是
@var{button}。
@end defun

@defun button-label button
返回 @var{button} 的文本标签。
@end defun

@defun button-type button
返回 @var{button} 的按钮类型。
@end defun

@defun button-has-type-p button type
如果@var{button}的按钮类型为@var{type}或@var{type}的子类型之一，则返回
@code{t}。
@end defun

@defun button-at pos
返回当前缓冲区中@var{pos}位置的按钮，或者@code{nil}。如果@var{pos}处的按钮是文
本属性按钮，则返回值是指向@var{pos}的标记。
@end defun

@defun button-type-put type prop val
将按钮类型@var{type}的@var{prop}属性设置为@var{val}。
@end defun

@defun button-type-get type prop
获取名为@var{type}的@var{prop}按钮类型的属性。
@end defun

@defun button-type-subtype-p type supertype
如果按钮类型@var{type}是@var{supertype}的子类型，则返回@code{t}。
@end defun

@node 按钮缓冲区命令
@subsection Button Buffer Commands
@cindex button buffer commands

这些命令和功能用于定位和操作Emacs缓冲区中的按钮。

@code{push-button}是用户实际按下按钮时使用的命令，默认在按钮本身中与@key{RET}
和@key{mouse-2}绑定，使用按钮覆盖层或文本属性中的本地keymap。在按钮本身之外有用的
命令，如@code{forward-button}和@code{backward-button}，在存储在
@code{button-buffer-map}中的keymap中是额外可用的；使用按钮的模式可能希望使用
@code{button-buffer-map}作为其keymap的父keymap。

如果按钮有一个非@code{nil}的@code{follow-link}属性，并且设置了
@code{mouse-1-click-follows-link}，快速的@key{mouse-1}点击也会激活
@code{push-button}命令。@xref{Clickable Text}。

@deffn Command push-button &optional pos use-mouse-action
在@var{pos}的位置执行按钮指定的动作，@var{pos}可以是缓冲区位置，也可以是鼠标事件
。@var{pos}可以是一个缓冲区位置，也可以是一个鼠标事件。如果
@var{use-mouse-action}是非@code{nil}，或者@var{pos}是一个鼠标事件(
@pxref{Mouse Events})，则尝试调用按钮的@code{mouse-action}属性，而不是
@code{action}；如果按钮没有@code{mouse-action}属性，则正常使用@code{action}
。@var{pos}默认为point，除非当@code{push-button}作为鼠标事件的结果被交互式地调
用，在这种情况下，会使用鼠标事件的位置。如果@var{pos}处没有按钮，则什么都不做，返回
@code{nil}，否则返回@code{t}。
@end deffn

@deffn Command forward-button n &optional wrap display-message no-error
移动到之后的第@var{n}个按钮，如果@var{n}为负值，则移动到之前的第@var{n}个按钮。
如果@var{n}为零，则移动到点上任一按钮的起始。如果@var{wrap}是非@code{nil}，则从
缓冲区的某一端开始移动。如果@var{display-message}是非@code{nil}，则显示按钮的
帮助-回音字符串。任何带有非@code{nil}的@code{skip}属性的按钮被跳过。返回找到的按
钮，如果找不到按钮，则发出错误信号。如果@var{no-error}在非@code{nil}的情况下，返
回nil而不是错误信号。
@end deffn

@deffn Command backward-button n &optional wrap display-message
移动到之前的第@var{n}个按钮，如果@var{n}为负值，则移动到之后的第@var{n}个按钮。
如果@var{n}为零，则移动到点上任一按钮的起始。如果@var{wrap}是非@code{nil}，则从
缓冲区的某一端开始移动。如果@var{display-message}是非@code{nil}，则显示按钮的
帮助-回音字符串。任何带有非@code{nil}的@code{skip}属性的按钮被跳过。返回找到的按
钮，如果找不到按钮，则发出错误信号。如果@var{no-error}在非@code{nil}的情况下，返
回nil而不是错误信号。
@end deffn

@defun next-button pos &optional count-current
@defunx previous-button pos &optional count-current
在当前缓冲区中@var{pos}的位置之后(对于@code{next-button})或之前(对于
@code{previous-button})返回下一个按钮。如果@var{count-current}是非
@code{nil}，则对搜索中@var{pos}处的任何按钮进行计数，而不是从下一个按钮开始。
@end defun

@node 抽象显示
@section Abstract Display
@cindex ewoc
@cindex display, abstract
@cindex display, arbitrary objects
@cindex model/view/controller
@cindex view part, model/view/controller

  Ewoc包构建了代表Lisp对象结构的缓冲文本，并根据该结构的变化更新文本。这就像"模型
--视图--控制器"设计模式中的"视图"组件。Ewoc的意思是"Emacs's Widget for Object Collections'"。

  一个@dfn{ewoc}是一个组织构造缓冲文本所需信息的结构，它表示某些Lisp数据。ewoc的
缓冲文本有三部分，依次为：首先是固定的@dfn{header}文本；接下来是一系列数据元素（你
指定的Lisp对象）的文字描述；最后是固定的@dfn{footer}文本。具体来说，一个ewoc包含
了以下信息:

@itemize @bullet
@item
其文本生成的缓冲区。

@item
文本在缓冲区的起始位置。

@item
页眉和页脚字符串。

@item
@cindex node, ewoc
@c 或"@cindex节点，抽象显示"？
一个由@dfn{nodes}组成的双向链表，每个节点包含：

@itemize
@item
一个@dfn{data element}，一个单一的Lisp对象。

@item
链接到链中的前后节点。
@end itemize

@item
一个@dfn{pretty-printer}函数，负责将数据元素值的文本表示插入到当前缓冲区中。
@end itemize

  通常情况下，您使用@code{ewoc-create}定义一个ewoc，然后将生成的ewoc结构传递给
Ewoc包中的其他函数，以便在其中构建节点，并将其显示在缓冲区中。一旦在缓冲区中显示出来
，其他函数就会确定缓冲区位置和节点之间的对应关系，将点从一个节点的文本表示移动到另一
个节点，等等。@xref{抽象显示功能}.

@cindex encapsulation, ewoc
@c 或"@cindex封装，抽象显示"？
  节点@dfn{encapsulates}是一个数据元素，就像变量保持一个值一样。通常情况下，封装
是作为向ewoc添加节点的一部分。您可以检索数据元素的值，并在其位置上放置一个新的值，就
像这样:

@lisp
(ewoc-data @var{node})
@result{} value

(ewoc-set-data @var{node} @var{new-value})
@result{} @var{new-value}
@end lisp

@noindent
您也可以使用一个Lisp对象（列表或向量）作为数据元素的值，该对象是实值的容器，或者是
其他结构的索引。这个例子（@pxref{抽象显示实例}）使用了后一种方法。

当数据发生变化时，你会想要更新缓冲区中的文本。您可以通过调用@code{ewoc-refresh}
更新所有的节点，或者使用@code{ewoc-invalidate}更新特定的节点，或者使用
@code{ewoc-map}更新所有满足前提条件的节点。另外，您也可以使用
@code{ewoc-delete}或@code{ewoc-filter}删除无效的节点，并在其位置上添加新的节
点。从ewoc中删除一个节点，也会从缓冲区中删除相关的文本描述。

@menu
* 抽象显示功能:: Ewoc包中的功能。
* 抽象显示实例:: Ewoc的使用实例。
@end menu

@node 抽象显示功能
@subsection Abstract Display Functions

  在本小节中，@var{ewoc}和@var{node}代表上面描述的结构（
@pxref{抽象显示}），而@var{data}则代表作为数据元素的任意Lisp对象。

@defun ewoc-create pretty-printer &optional header footer nosep
这将构建并返回一个新的ewoc，没有节点（因此也没有数据元素）。@var{pretty-printer}
应该是一个函数，它只接受一个参数，即您打算在这个ewoc中使用的那种数据元素，并使用
@code{insert}在点上插入它的文本描述(而不是@code{insert-before-markers}，因为
那会干扰Ewoc包的内部机制)。

通常情况下，在页眉、页脚和每个节点的文字描述之后，都会自动插入一个新行，如果
@var{nosep}是非@code{nil}，则不会插入新行。如果@var{nosep}是非@code{nil}，则
不会插入新行。这对于在一行上显示整个ewoc可能很有用，例如，或者通过安排
@var{pretty-printer}对这些节点不做任何操作来使节点不可见。

ewoc会在创建时的缓冲区中维护它的文本，所以在调用@code{ewoc-create}之前，先切换到
预定的缓冲区。
@end defun

@defun ewoc-buffer ewoc
返回@var{ewoc}保存文本的缓冲区。
@end defun

@defun ewoc-get-hf ewoc
返回由@var{ewoc}的页眉和页脚组成的@code{(@var{header} . @var{footer})}单元
。
@end defun

@defun ewoc-set-hf ewoc header footer
这将@var{ewoc}的页眉和页脚分别设置为@var{header}和@var{footer}字符串。
@end defun

@defun ewoc-enter-first ewoc data
@defunx ewoc-enter-last ewoc data
这些新增了一个封装@var{data}的节点，分别将其放在@var{ewoc}节点链的开头或结尾。
@end defun

@defun ewoc-enter-before ewoc node data
@defunx ewoc-enter-after ewoc node data
这些新增的节点封装了@var{data}，分别在@var{node}之前或之后添加到@var{ewoc}。
@end defun

@defun ewoc-prev ewoc node
@defunx ewoc-next ewoc node
这两个函数分别返回@var{node}在@var{ewoc}中的上一个节点和下一个节点。
@end defun

@defun ewoc-nth ewoc n
这将返回在@var{ewoc}中零基索引@var{n}处找到的节点。如果@var{n}为负值，则表示从末
尾开始计算。如果@var{n}超出了范围，那么@code{ewoc-nth}将返回@code{nil}。
@end defun

@defun ewoc-data node
这将提取@var{node}封装的数据并返回。
@end defun

@defun ewoc-set-data node data
这将@var{node}封装的数据设置为@var{data}。
@end defun

@defun ewoc-locate ewoc &optional pos guess
这个函数确定@var{ewoc}中包含点(或如果指定了@var{pos})的节点，并返回该节点。如果
@var{ewoc}没有节点，则返回@code{nil}。如果@var{pos}在第一个节点之前，则返回第一
个节点；如果@var{pos}在最后一个节点之后，则返回最后一个节点。可选的第三个参数
@var{guess}应该是一个可能在@var{pos}附近的节点；这不会改变结果，但会使函数运行得
更快。
@end defun

@defun ewoc-location node
返回@var{node}的起始位置。
@end defun

@defun ewoc-goto-prev ewoc arg
@defunx ewoc-goto-next ewoc arg
这些移动点分别到@var{arg}中的上一个或下一个@var{ewoc}节点。如果
@code{ewoc-goto-prev}已经在第一个节点，或者@var{ewoc}为空，则不会移动，而
@code{ewoc-goto-next}则会移动到最后一个节点，返回@code{nil}。除了这种特殊情况，
这些函数都会返回移动到的节点。
@end defun

@defun ewoc-goto-node ewoc node
这个点会移动到@var{ewoc}内@var{node}的起点。
@end defun

@defun ewoc-refresh ewoc
这个函数重新生成@var{ewoc}的文本。它的工作原理是删除页眉和页脚之间的文本，比如所有
数据元素的表示，然后依次对每个节点逐个调用pretty-printer函数。
@end defun

@defun ewoc-invalidate ewoc &rest nodes
这和@code{ewoc-refresh}类似，只是只有@var{ewoc}中的@var{nodes}被更新，而不是
整个集合。
@end defun

@defun ewoc-delete ewoc &rest nodes
这将从@var{nodes}中删除@var{ewoc}中的每个节点。
@end defun

@defun ewoc-filter ewoc predicate &rest args
这将为@var{ewoc}中的每个数据元素调用@var{predicate}，并删除@var{predicate}返
回@code{nil}的节点。任何@var{args}都会传递给@var{predicate}。
@end defun

@defun ewoc-collect ewoc predicate &rest args
这个函数为@var{ewoc}中的每个数据元素调用@var{predicate}，并返回一个包含
@var{predicate}返回非@code{nil}的元素的列表。列表中的元素与缓冲区中的元素排序相
同。任何@var{args}都会传递给@var{predicate}。
@end defun

@defun ewoc-map map-function ewoc &rest args
这将为@var{ewoc}中的每个数据元素调用@var{map-function}，并更新那些
@var{map-function}返回非@code{nil}的节点。任何@var{args}都会传递给
@var{map-function}。
@end defun

@node 抽象显示实例
@subsection Abstract Display Example

  这里是一个简单的例子，使用ewoc包的函数实现了@dfn{color components}的显示，在
缓冲区中的一个区域，以各种方式表示三个整数的向量（本身代表一个24位的RGB值）。

@example
(setq colorcomp-ewoc nil
      colorcomp-data nil
      colorcomp-mode-map nil
      colorcomp-labels ["Red" "Green" "Blue"])

(defun colorcomp-pp (data)
  (if data
      (let ((comp (aref colorcomp-data data)))
        (insert (aref colorcomp-labels data) "\t: #x"
                (format "%02X" comp) " "
                (make-string (ash comp -2) ?#) "\n"))
    (let ((cstr (format "#%02X%02X%02X"
                        (aref colorcomp-data 0)
                        (aref colorcomp-data 1)
                        (aref colorcomp-data 2)))
          (samp " (sample text) "))
      (insert "Color\t: "
              (propertize samp 'face
                          `(foreground-color . ,cstr))
              (propertize samp 'face
                          `(background-color . ,cstr))
              "\n"))))

(defun colorcomp (color)
  "Allow fiddling with COLOR in a new buffer.
The buffer is in Color Components mode."
  (interactive "sColor (name or #RGB or #RRGGBB): ")
  (when (string= "" color)
    (setq color "green"))
  (unless (color-values color)
    (error "No such color: %S" color))
  (switch-to-buffer
   (generate-new-buffer (format "originally: %s" color)))
  (kill-all-local-variables)
  (setq major-mode 'colorcomp-mode
        mode-name "Color Components")
  (use-local-map colorcomp-mode-map)
  (erase-buffer)
  (buffer-disable-undo)
  (let ((data (apply 'vector (mapcar (lambda (n) (ash n -8))
                                     (color-values color))))
        (ewoc (ewoc-create 'colorcomp-pp
                           "\nColor Components\n\n"
                           (substitute-command-keys
                            "\n\\@{colorcomp-mode-map@}"))))
    (set (make-local-variable 'colorcomp-data) data)
    (set (make-local-variable 'colorcomp-ewoc) ewoc)
    (ewoc-enter-last ewoc 0)
    (ewoc-enter-last ewoc 1)
    (ewoc-enter-last ewoc 2)
    (ewoc-enter-last ewoc nil)))
@end example

@cindex controller part, model/view/controller
  这个例子可以通过定义修改@code{colorcomp-data}和完成选择过程的命令，以及方便地
将其连接在一起的键图，扩展为一个颜色选择部件（换句话说，就是"模型--视图--控制器"设计
范式中的"控制器"部分）。

@smallexample
(defun colorcomp-mod (index limit delta)
  (let ((cur (aref colorcomp-data index)))
    (unless (= limit cur)
      (aset colorcomp-data index (+ cur delta)))
    (ewoc-invalidate
     colorcomp-ewoc
     (ewoc-nth colorcomp-ewoc index)
     (ewoc-nth colorcomp-ewoc -1))))

(defun colorcomp-R-more () (interactive) (colorcomp-mod 0 255 1))
(defun colorcomp-G-more () (interactive) (colorcomp-mod 1 255 1))
(defun colorcomp-B-more () (interactive) (colorcomp-mod 2 255 1))
(defun colorcomp-R-less () (interactive) (colorcomp-mod 0 0 -1))
(defun colorcomp-G-less () (interactive) (colorcomp-mod 1 0 -1))
(defun colorcomp-B-less () (interactive) (colorcomp-mod 2 0 -1))

(defun colorcomp-copy-as-kill-and-exit ()
  "Copy the color components into the kill ring and kill the buffer.
The string is formatted #RRGGBB (hash followed by six hex digits)."
  (interactive)
  (kill-new (format "#%02X%02X%02X"
                    (aref colorcomp-data 0)
                    (aref colorcomp-data 1)
                    (aref colorcomp-data 2)))
  (kill-buffer nil))

(setq colorcomp-mode-map
      (let ((m (make-sparse-keymap)))
        (suppress-keymap m)
        (define-key m "i" 'colorcomp-R-less)
        (define-key m "o" 'colorcomp-R-more)
        (define-key m "k" 'colorcomp-G-less)
        (define-key m "l" 'colorcomp-G-more)
        (define-key m "," 'colorcomp-B-less)
        (define-key m "." 'colorcomp-B-more)
        (define-key m " " 'colorcomp-copy-as-kill-and-exit)
        m))
@end smallexample

需要注意的是，我们从不修改每个节点中的数据，当ewoc被创建为@code{nil}或索引到向量
@code{colorcomp-data}，即实际的颜色组件时，这些数据是固定的。

@node 闪烁
@section Blinking Parentheses
@cindex parenthesis matching
@cindex blinking parentheses
@cindex balancing parentheses

  本节介绍了Emacs在用户插入闭合括号时显示匹配的开放括号的机制。

@defvar blink-paren-function
这个变量的值应该是一个函数(没有参数)，每当插入一个带有小括号的字符时就会被调用。
@code{blink-paren-function}的值可能是@code{nil}，在这种情况下，什么都不做。
@end defvar

@defopt blink-matching-paren
如果这个变量是@code{nil}，那么@code{blink-matching-open}就没有任何作用。
@end defopt

@defopt blink-matching-paren-distance
这个变量指定了在放弃之前扫描匹配括号的最大距离。
@end defopt

@defopt blink-matching-delay
这个变量指定了保持指示匹配小括号的秒数。一秒钟的几分之一通常会得到很好的结果，但默认
值是1，这对所有系统都适用。
@end defopt

@deffn Command blink-matching-open
这个函数是@code{blink-paren-function}的默认值。它假设点在一个带有近括号语法的字
符后面，并将相应的效果瞬间应用于匹配的开头字符。如果该字符还没有出现在屏幕上，它就会
在回声区显示该字符的上下文。为了避免长时间的延迟，该函数的搜索距离不会超过
@code{blink-matching-paren-distance}字符。

下面是一个显式调用这个函数的例子。

@smallexample
@group
(defun interactive-blink-matching-open ()
  "Indicate momentarily the start of parenthesized sexp before point."
  (interactive)
@end group
@group
  (let ((blink-matching-paren-distance
         (buffer-size))
        (blink-matching-paren t))
    (blink-matching-open)))
@end group
@end smallexample
@end deffn

@node 字符显示
@section Character Display

  本节介绍Emacs如何实际显示字符。通常情况下，一个字符的显示方式是@dfn{glyph}。在
屏幕上占据一个字符位置的图形符号），其外观与字符本身相对应。例如，字符@samp{a}（字
符代码97）显示为@samp{a}。但是，有些字符的显示方式比较特殊，例如，formfeed字符（
字符代码12）通常显示为两个字形的序列，@samp{^L}，而换行字符（字符代码10）则开始一个新的屏幕行。

  您可以通过定义一个新的字符，来修改每个字符的显示方式。@dfn{display table}，它将
每个字符代码映射到一个字形序列中。@xref{Display Tables}。

@menu
* 通常的显示::   显示字符的通常惯例。
* 显示表::      显示表由什么组成。
* 活动的显示表:: Emacs如何选择要使用的显示表。
* 字元::        如何定义字元，以及字元的含义。
* 无字形字符::   如何绘制无字形字符。
@end menu

@node 通常的显示
@subsection Usual Display Conventions

  以下是显示每个字符代码的约定（在没有显示表的情况下，可以覆盖这些
@iftex
约定）。
@end iftex
@ifnottex
约定; @pxref{Display Tables}）。
@end ifnottex

@cindex printable ASCII characters
@itemize @bullet
@item
@dfn{printable @acronym{ASCII} characters}，字符代码32到126（由数字、英文字
母和符号组成，如@samp{#})按字面意思显示。

@item
标签字符(字符代码9)显示为空白，一直延伸到下一个标签停止列。
@xref{Text Display,,,emacs, The GNU Emacs Manual}.变量@code{tab-width}控
制每个制表符停止的空格数（见下文）。

@item
换行符（字符代码10）有一个特殊的效果：它结束前一行，开始新的一行。

@cindex ASCII control characters
@item
不可打印的@dfn{@acronym{ASCII} control characters}--字符代码0到31，以及
@key{DEL}字符（字符代码127）--根据变量@code{ctl-arrow}以两种方式之一显示。如果
该变量为非@code{nil}(默认)，这些字符以两个字形的序列显示，其中第一个字形是
@samp{^}。(显示表可以指定一个字形来代替@samp{^})；例如，@key{DEL}字符显示为
@samp{^?}.

如果@code{ctl-arrow}是@code{nil}，这些字符将以八进制转义符的形式显示（见下文）。

这条规则也适用于回车（字符代码13），如果该字符出现在缓冲区中。但回车通常不会出现在缓
冲区文本中，它们会作为行末转换的一部分被消除（@pxref{Coding System Basics}）。

@cindex octal escapes
@item
@dfn{Raw bytes}为非@acronym{ASCII}字符，代码为128至255(
@pxref{Text Representations})。这些字符以@dfn{octal escapes}的形式显示：由
四个字形组成的序列，其中第一个字形是@samp{/}的@acronym{ASCII}代码，其他字形是代
表八进制字符代码的数字字符。显示表可以指定一个字形来代替@samp{/}。

@item
如果终端支持的话，每个代码大于255的非@acronym{ASCII}字符都会按字面显示。如果终端
不支持，则称该字符为@dfn{glyphless}，通常使用占位字形显示。例如，如果一个图形终端
没有字符的字体，Emacs通常会显示一个包含十六进制字符代码的框。
@xref{Glyphless Chars}。
@end itemize

  即使在有显示表的情况下，上述显示约定也适用于任何在活动显示表中的条目为@code{nil}
的字符。因此，当您设置一个显示表时，您只需要指定您想要特殊行为的字符。

  以下变量会影响某些字符在屏幕上的显示方式。因为它们改变了字符所占的列数，所以也影响
了缩进函数。它们也会影响模式行的显示方式；如果您想使用新的值强制重新显示模式行，请调
用函数@code{force-mode-line-update}(@pxref{Mode Line Format})。

@defopt ctl-arrow
@cindex control characters in display
这个缓冲区局部变量控制控制字符的显示方式。如果它是非@code{nil}，则控制字符会被显示
为后面的小括号。@samp{^A}。如果是@code{nil}，则显示为八进制转义符：一个反斜杠，后
面跟着三个八进制数字，如@samp{^A}。
@end defopt

@defopt tab-width
这个缓冲区局部变量的值是Emacs缓冲区中显示制表字符时使用的制表符间距。请注意，这个特
性完全独立于@code{tab-to-tab-stop}命令所使用的用户可设置的制表符间距。
@xref{Indent Tabs}.
@end defopt

@node 显示表
@subsection Display Tables

@cindex display table
  显示表是一个特殊用途的字符表(@pxref{Char-Tables})，其子类型为
@code{display-table}，用于覆盖通常的字符显示约定。这一节描述了如何制作、检查和为
一个显示表对象分配元素。

@defun make-display-table
这将创建并返回一个显示表。表格中的所有元素都是@code{nil}。
@end defun

  显示表的普通元素以字符代码为索引；索引@var{c}处的元素说明如何显示字符代码@var{c}
。这个值应该是@code{nil}（表示按照通常的显示习惯来显示字符@var{c}；
@pxref{Usual Display}），或者是一个字形代码的向量（表示按照这些字形来显示字符
@var{c}；@pxref{字元}）。

  @strong{警告:}如果您使用显示表来改变换行字符的显示，整个缓冲区将被显示为一条长线
。

  显示表还有六个@dfn{extra slots}，它们有特殊的作用。下面是它们的含义表，任何槽中
的@code{nil}表示对该槽使用默认值，如下所述。

@table @asis
@item 0
截断屏幕行结束的字形（默认为@samp{$}）。@xref{字元}.在图形终端上，Emacs默认使
用边缘中的箭头来表示截断，因此显示表没有任何效果，除非你禁用边缘(
@pxref{Fringes,,Window Fringes,emacs,the GNU Emacs Manual})。

@item 1
续行结束的字形(默认为@samp{/\})。在图形终端上，Emacs默认使用边缘的弯曲箭头来表示
续行，所以除非禁用边缘，否则显示表没有任何影响。

@item 2
用于表示八进制字符代码的字符的字形（默认为@samp{\}）。

@item 3
表示控制字符的字形（默认为@samp{^}）。

@item 4
用于指示不可见线的存在的字形向量(默认为@samp{...})。
@xref{Selective Display}.

@item 5
用于绘制并排窗口之间边框的字形（默认为@samp{|}）。@xref{Splitting Windows}。目
前只有在文本终端上才有效果；在图形终端上，如果支持垂直滚动条并在使用，则用滚动条将两
个窗口分开，如果没有垂直滚动条，也没有分隔线（@pxref{Window Dividers}），Emacs
就用细线来表示边界。
@end table

  例如，下面是如何构造一个显示表，模仿将@code{ctl-arrow}设置为非@code{nil}值的
效果（@pxref{字元}，为 @code{make-glyph-code} 函数）:

@example
(setq disptab (make-display-table))
(dotimes (i 32)
  (or (= i ?\t)
      (= i ?\n)
      (aset disptab i
            (vector (make-glyph-code ?^ 'escape-glyph)
                    (make-glyph-code (+ i 64) 'escape-glyph)))))
(aset disptab 127
      (vector (make-glyph-code ?^ 'escape-glyph)
              (make-glyph-code ?? 'escape-glyph)))))
@end example

@defun display-table-slot display-table slot
此函数返回@var{display-table}的额外槽位@var{slot}的值。参数@var{slot}可以是一
个从0到5（含）的数字，或者一个槽名（符号）。有效的符号有@code{truncation}、
@code{wrap}、@code{escape}、@code{control}、@code{selective-display}和
@code{vertical-border}。
@end defun

@defun set-display-table-slot display-table slot value
此函数将@var{value}存储在@var{display-table}的额外槽位@var{slot}中。参数
@var{slot}可以是一个从0到5的数字，也可以是一个槽名（符号）。有效的符号有
@code{truncation}、@code{wrap}、@code{escape}、@code{control}、
@code{selective-display}和@code{vertical-border}。
@end defun

@defun describe-display-table display-table
该函数在帮助缓冲区中显示对显示表@var{display-table}的描述。
@end defun

@deffn Command describe-current-display-table
该命令在帮助缓冲区中显示当前显示表的描述。
@end deffn

@node 活动的显示表
@subsection Active Display Table
@cindex active display table

  每个窗口可以指定一个显示表，每个缓冲区也可以。窗口的显示表（如果有的话）优先于缓冲
区的显示表。如果两者都不存在，Emacs会尝试使用标准的显示表；如果是@code{nil}，
Emacs会使用通常的字符显示约定（@pxref{Usual Display}）。

  请注意，显示表会影响模式行的显示方式，所以如果您想使用新的显示表强制重新显示模式行
，请调用@code{force-mode-line-update}。(@pxref{Mode Line Format})。

@defun window-display-table &optional window
此函数返回@var{window}的显示表，如果没有，则返回@code{nil}。默认情况下，
@var{window}的显示表是选定的窗口。
@end defun

@defun set-window-display-table window table
此函数将@var{window}的显示表设置为@var{table}。参数@var{table}应该是一个显示表
或@code{nil}。
@end defun

@defvar buffer-display-table
这个变量在所有的缓冲区中都是自动的缓冲区本地变量，它的值指定了缓冲区的显示表，如果是
@code{nil}，则没有缓冲区显示表。如果是@code{nil}，则没有缓冲区的显示表。
@end defvar

@defvar standard-display-table
这个变量的值是标准显示表，当Emacs在窗口中显示缓冲区时，既没有定义窗口显示表，也没有
定义缓冲区显示表，或者当Emacs向标准输出或错误流输出文本时，都会使用这个变量。虽然它
的默认值通常是@code{nil}，但在交互式会话中，如果终端不能显示曲线引号，它的默认值会
将曲线引号映射为ASCII近似值。@xref{Text Quoting Style}。
@end defvar

@file{disp-table}库定义了几个用于改变标准显示表的函数。

@node 字元
@subsection Glyphs
@cindex glyph

@cindex glyph code
  一个@dfn{glyph}是一个图形符号，它占据了屏幕上一个字符的位置。每个字形在Lisp中都
以@dfn{glyph code}的形式来表示，它指定了一个字符以及显示它的可选字形(
@pxref{Faces})。字形代码的主要用途是作为显示表的条目（@pxref{Display Tables}）
。以下函数用于操作字形代码:

@defun make-glyph-code char &optional face
这个函数返回一个代表char@var{char}的字形代码和@var{face}的字形。如果@var{face}
被省略或者@code{nil}，则字形代码使用默认的字形，在这种情况下，字形代码是一个整数。
如果@var{face}是非@code{nil}，则字形代码不一定是一个整数对象。
@end defun

@defun glyph-char glyph
此函数返回字形代码@var{glyph}的字符。
@end defun

@defun glyph-face glyph
此函数返回字形代码@var{glyph}的字形，如果@var{glyph}使用默认字形，则返回
@code{nil}。
@end defun

@ifnottex
  您可以设置@dfn{glyph table}来改变文字终端上字形代码的实际显示方式。这个功能是
半废弃的，请使用@code{glyphless-char-display}来代替 (
@pxref{Glyphless Chars})。

@defvar glyph-table
这个变量的值，如果是非@code{nil}，则是当前的字形表。它只在字符终端上生效；在图形显
示上，所有的字形都按字面显示。字形表应该是一个向量，它的第@var{g}个元素指定了如何显
示字形代码@var{g}，其中@var{g}是字面未指定的字形的字形代码。每个元素都应该是以下内
容之一:

@table @asis
@item @code{nil}
按字面意思显示这个字形。

@item a string
通过向终端发送指定的字符串来显示这个字形。

@item a glyph code
显示指定的字形代码。
@end table

任何大于或等于字形表长度的整数字形代码都会按字面显示。
@end defvar
@end ifnottex

@node 无字形字符
@subsection Glyphless Character Display
@cindex glyphless characters

  @dfn{无字形字符}是指以特殊方式显示的字符，例如，以包含十六进制代码的方框形式显示
，而不是按字面显示。这些字符包括被明确定义为无字形的字符，以及没有可用字体的字符（在
图形显示器上）和终端编码系统无法编码的字符（在文本终端上）。

@defvar glyphless-char-display
这个变量的值是一个字符表，它定义了无字形字符和它们的显示方式。每个条目必须是以下显示方法之一:

@table @asis
@item @code{nil}
以通常的方式显示字符。

@item @code{zero-width}
不要显示字符。

@item @code{thin-space}
显示一个细小的空间，在图形显示器上显示1像素宽，或在文本终端上显示1字符宽。

@item @code{empty-box}
显示一个空盒子。

@item @code{hex-code}
显示一个包含该字符的Unicode码点的方框，用十六进制表示。

@item an @acronym{ASCII} string
显示一个包含该字符串的框。该字符串最多包含6个@acronym{ASCII}字符。

@item a cons cell @code{(@var{graphical} . @var{text})}
在图形显示器上使用@var{graphical}显示，在文本终端上使用@var{text}显示。
@var{graphical}和@var{text}都必须是上述的显示方法之一。
@end table

@noindent
@code{thin-space},@code{empty-box},@code{hex-code}和@acronym{ASCII}字符
串的显示方法是用@code{glyphless-char}z字形。在文本终端上，方框用方括号模拟，
@samp{[]}。

字符表有一个额外的槽，它决定了如何显示任何无法用任何可用字体显示的字符，或者终端的编
码系统无法编码的字符。它的值应该是上述显示方法中的一种，除了@code{zero-width}或
cons单元格。

如果一个字符在活动的显示表中有一个非@code{nil}条目，显示表就会生效；在这种情况下，
Emacs根本不参考@code{glyphless-char-display}。
@end defvar

@defopt glyphless-char-display-control
这个用户选项提供了一种方便的方式来设置类似字符组的@code{glyphless-char-display}
。不要直接从Lisp代码中设置它的值；该值仅通过自定义的@code{:set}函数(
@pxref{Variable Definitions})生效，该函数更新
@code{glyphless-char-display}。

它的值应该是元素@code{(@var{group} . @var{method})}的一个列表，其中
@var{group}是指定一组字符的符号，@var{method}是指定如何显示它们的符号。

@var{group}应该是以下之一:

@table @code
@item c0-control
@acronym{ASCII}控制字符@code{U+0000}至@code{U+001F}，不包括换行符和制表符（
通常显示为转义序列，如@samp{^A}；@pxref{Text Display,,How Text Is Displayed,emacs,The GNU Emacs Manual}）。

@item c1-control
非@acronym{ASCII}，非打印字符@code{U+0080}至@code{U+009F}（通常显示为八进制
转义序列，如@samp{\230}。）

@item format-control
Unicode通用类别[Cf]的字符，如U+200E@sc{从左到右的标记}，但不包括有图形图像的字符
，如U+00AD@sc{软连字符}。

@item no-font
没有合适的字体或终端编码系统无法编码的字符。
@end table

@c FIXME：这也可以是"缩写"，但目前还没有完全实现；它只适用于格式控制组，并且只有当
@c 缩写词在'char-acronym-table'中时才有效。
@var{method}符号应该是@code{zero-width}、@code{thin-space}、
@code{empty-box}或@code{hex-code}中的一个。这些符号的含义与上述
@code{glyphless-char-display}相同。
@end defopt

@node 哔哔声
@section Beeping
@cindex bell

  本节介绍了如何让Emacs响铃（或闪烁屏幕）来吸引用户的注意力。对于这样做的频率要保守
，频繁的铃声会让人烦躁。同时要注意，当发出错误信号时，不要只用哔哔声更合适（
@pxref{Errors}）。

@defun ding &optional do-not-terminate
@cindex keyboard macro termination
这个函数会发出哔哔声，或者闪烁屏幕 (参见下面的@code{visible-bell})。除非
@var{do-not-terminate}是非@code{nil}，否则它也会终止当前正在执行的任何键盘宏。
@end defun

@defun beep &optional do-not-terminate
这是@code{ding}的同义词。
@end defun

@defopt visible-bell
这个变量决定Emacs是否应该闪烁屏幕来表示铃声。非@code{nil}表示是，@code{nil}表示
不是。这个变量对图形显示和文本终端有效，只要终端的Termcap条目定义了可见铃声的功能(
@samp{vb})。
@end defopt

@defopt ring-bell-function
如果这个是非@code{nil}，它指定Emacs应该如何敲钟。它的值应该是一个没有参数的函数。
如果这个变量是非@code{nil}，则它优先于@code{visible-bell}变量。
@end defopt

@node 窗口系统
@section Window Systems

  Emacs可以和几种窗口系统一起工作，最著名的是X窗口系统。Emacs和X都使用"窗口"一词，
但使用方式不同。就X而言，一个Emacs框架就是一个单一的窗口；X根本不知道Emacs的各个窗
口。

@defvar window-system
这个终端本地变量告诉Lisp程序Emacs使用什么窗口系统来显示框架。可能的值有

@table @code
@item x
@cindex X Window System
Emacs是用X来显示框架的。
@item w32
Emacs使用原生的MS-Windows GUI来显示框架。
@item ns
Emacs使用Nextstep接口（在GNUstep和macOS上使用）来显示框架。
@item pc
Emacs是用MS-DOS直接写屏显示框架。
@item nil
Emacs是在基于字符的终端上显示框架。
@end table
@end defvar

@defvar initial-window-system
这个变量保存了@code{window-system}的值，用于Emacs在启动时创建的第一个框架。(当
Emacs以守护进程的形式被调用时，它不会创建任何初始框架，所以
@code{initial-window-system}是@code{nil}，除非在MS-Windows上，它仍然是
@code{w32}。
@xref{Initial Options, daemon,,emacs, The GNU Emacs Manual}.)
@end defvar

@defun window-system &optional frame
这个函数返回一个符号，这个符号的名字告诉了我们使用什么窗口系统来显示@var{frame}(默
认为当前选定的框架)。它所返回的可能的符号列表与上面为变量@code{window-system}所
记录的相同。
@end defun

  如果您想写出在文本终端和图形显示上不同的代码，请不要使用@emph{not}来作为谓词或布
尔标志变量使用@code{window-system}。这是因为@code{window-system}并不是Emacs
在给定显示类型上的能力的良好指标。相反，使用在@ref{Display Feature Testing}中描
述的@code{display-graphic-p}或任何其他@code{display-*-p}谓词。

@node 工具提示
@section Tooltips
@cindex tooltips
@dfn{Tooltips}是特殊的窗框(@pxref{Frames})，是用来进行显示与鼠标指针当前位置相
关的有用提示（又名@: ``tips'）。Emacs使用工具提示来显示关于文本的活动部分（
@pxref{Special Properties}）和各种UI元素的帮助字符串，例如菜单项（
@pxref{Extended Menu Items}）工具条按钮（@pxref{Tool Bar}）。

@defun tooltip-mode
工具提示模式是一种能够显示工具提示的次要模式。关闭该模式会使工具提示显示在回声区域。
在文本模式（又名@:``TTY''）窗框上，工具提示总是显示在回声区域。
@end defun

@vindex x-gtk-use-system-tooltips
当Emacs在构建过程中支持GTK+时，默认情况下会使用GTK+函数来显示工具提示，然后通过
GTK+设置来控制工具提示的外观。GTK+工具提示可以通过将变量
@code{x-gtk-use-system-tooltips}的值改为@code{nil}来禁用。本小节的其余部分将
介绍如何控制非GTK+的工具提示，这些工具提示是由Emacs自己提供的。

@cindex tooltip frames
工具提示显示在特殊的窗框中，称为工具提示窗框，它有自己的窗框参数（
@pxref{Frame Parameters}）。与其他窗框不同，工具提示窗框的默认参数存储在一个特殊
的变量中。

@defopt tooltip-frame-parameters
这个可定制的选项保留了用于显示工具提示的默认窗框参数，任何字体和颜色参数都会被忽略，
取而代之的是@code{tooltip}字形的相应属性。如果包含@code{left}或@code{top}参数
，它们将被用作工具提示应该显示的绝对窗框相关坐标。(工具提示的鼠标相对位置可以使用
@ref{Tooltips,,,emacs, The GNU Emacs Manual}中描述的变量来定制。)注意
@code{left}和@code{top}参数，如果存在的话，会覆盖鼠标相对位置的值。
@end defopt

@vindex tooltip@r{ face}
@code{tooltip}字形决定了工具提示中文字的外观。一般来说，它应该使用一种可变间距的字
体，其大小最好小于默认的窗框字体。

@findex tooltip-help-tips
@defvar tooltip-functions
这个异常的钩子是Emacs需要显示工具提示时要调用的函数列表。每个函数的调用都有一个参数
@var{event}，它是最后一次鼠标移动事件的副本。如果这个列表中的某个函数真的显示了工
具提示，它应该返回非@code{nil}，然后其余的函数就不会被调用。这个变量的默认值是单个
函数@code{tooltip-help-tips}。
@end defvar

如果您编写了自己的函数，并将其放在@code{tooltip-functions}列表中，您可能需要知道
触发工具提示显示的鼠标事件的缓冲区。下面的函数提供了这些信息。

@defun tooltip-event-buffer event
这个函数返回发生@var{event}的缓冲区。使用@code{tooltip-functions}函数的参数调
用该函数，以获得触发工具提示的缓冲区。请注意，事件可能不是发生在缓冲区上（例如，发生
在工具栏上），在这种情况下，本函数将返回@code{nil}。
@end defun

工具提示显示的其他方面是由几个可定制的设置控制的，参见
@ref{Tooltips,,,emacs, The GNU Emacs Manual}。

@node 双向显示
@section Bidirectional Display
@cindex bidirectional display
@cindex right-to-left text

  Emacs可以显示以阿拉伯文、波斯文和希伯来文等文字书写的文本，这些文字的水平显示顺序
自然是从右到左。此外，嵌入右向左文本中的拉丁字母和数字的片段从左向右显示，而嵌入左向
右文本中的右向左脚本的片段（例如，程序源文件中注释或字符串中的阿拉伯语或希伯来语文本
）则适当地从右向左显示。我们把这种从左到右和从右到左的混合文本称为
@dfn{bidirectional text}。本节介绍编辑和显示双向文本的设施和选项。

@cindex logical order
@cindex reading order
@cindex visual order
@cindex unicode bidirectional algorithm
@cindex UBA
@cindex bidirectional reordering
@cindex reordering, of bidirectional text
  文本存储在Emacs缓冲区中，字符串存储在@dfn{logical}中（或者是@dfn{reading}）
顺序，即人类阅读的顺序。每个字符。在从右到左和双向文本中，字符在屏幕上的显示顺序（称
为@dfn{visual order}）与逻辑顺序不同，字符的屏幕位置不会随着字符串或缓冲区位置的
增加而单调增加。在执行这个@dfn{bidirectional reordering}时，Emacs遵循Unicode
双向算法（又名@:@acronym{UBA}），该算法在Unicode标准的附件#9中有所描述（
@url{http://www.unicode.org/reports/tr9/}）。Emacs提供了一个@acronym{UBA}
的"完全双向"类实现，符合Unicode标准v9.0的要求。但请注意，当文本方向与基本段落方向
相反时，Emacs显示续行的方式与UBA不同，UBA要求在重新排序显示文本之前进行包行。

@defvar bidi-display-reordering
如果这个缓冲区本地变量的值是非@code{nil}(默认)，Emacs为显示执行双向重排序。重排序
会影响缓冲区的文本，以及来自缓冲区中文本和覆盖属性的显示字符串和覆盖字符串（
@pxref{Overlay Properties}，以及@pxref{Display Property}）。如果值是
@code{nil}，Emacs 不会在缓冲区中执行双向重排序。

@code{bidi-display-reordering}的默认值控制了不是由缓冲区直接提供的字符串的重新
排序，包括模式行(@pxref{Mode Line Format})和标题行(@pxref{Header Lines})中
显示的文本。
@end defvar

@cindex unibyte buffers, and bidi reordering
  Emacs从不对unibyte缓冲区的文本进行排序，即使
@code{bidi-display-reordering}在缓冲区中是非@code{nil}。这是因为unibyte缓冲
区包含原始字节，而不是字符，因此缺乏重排序所需的方向性属性。因此，要测试缓冲区中的文
本是否会被重新排序显示，仅测试@code{bidi-display-reordering}的值是不够的。正确
的测试方法是这样的:

@example
 (if (and enable-multibyte-characters
          bidi-display-reordering)
     ;; Buffer is being reordered for display
   )
@end example

  然而，如果单字节显示和覆盖字符串的父缓冲区被重新排序的话，它们@emph{会}被重新排序
。这是因为plain-@sc{ascii}字符串被Emacs作为单字节字符串存储。如果一个单字节的显
示或覆盖字符串包含非@sc{ascii}字符，这些字符被假定为从左到右的方向。

@cindex display properties, and bidi reordering of text
  由@code{display}文本属性、由@code{display}属性（其值为字符串）覆盖的文本，以
及由任何其他替换缓冲区文本的属性覆盖的文本，在为显示重新排序时，都会被视为一个单一单
元。也就是说，这些属性所覆盖的整个文本块都会一起重新排序。而且，这种文本块中的字符的
双向属性被忽略，Emacs会将它们重新排序，就像用单个字符@code{U+FFFC}替换一样，也就
是所谓的@dfn{对象替换字符}。这意味着将一个显示属性放置在一部分文本上，可能会改变周
围文本重新排序的显示方式。为了防止这种意想不到的效果，请始终将此类属性放置在其方向性
与周围文本相同的文本上。

@cindex base direction of a paragraph
  每一段双向文字都有一个@dfn{base direction}，可以从右到左，也可以从左到右。从左
到右的段落从窗口的左边缘开始显示，当文本到达右边缘时，会被截断或继续显示。从右到左的
段落从右边缘开始显示，并在左边缘继续或截断。

@cindex paragraph-start, and bidirectional display
@cindex paragraph-separate, and bidirectional display
段落到底从哪里开始，从哪里结束，为了Emacs@acronym{UBA}的实现，是由以下两个缓冲区
局部变量决定的（请注意，@code{paragraph-start}和@code{paragraph-separate}对
此没有影响）。默认情况下，这两个变量都是@code{nil}，段落的边界是空行，也就是完全由
0个或更多空格字符和换行组成的行。

@defvar bidi-paragraph-start-re
如果非@code{nil}，这个变量的值应该是一个正则表达式，它匹配的是两段的起始行或分隔行
。正则表达式总是在换行之后匹配，所以最好将其固定下来，比如以@code{"^"}开头。
@end defvar

@defvar bidi-paragraph-separate-re
如果非@code{nil}，这个变量的值应该是一个正则表达式，匹配两段之间的分界线。正则表达
式总是在换行之后匹配，所以最好将其固定，比如以@code{"^"}开头。
@end defvar

  如果您修改了这两个变量中的任何一个，通常您应该同时修改这两个变量，以确保它们对段落
的描述一致。例如，如果要让每一行都开始一个新的段落，以便进行双向排序，可以将这两个变
量都设置为@code{"^"}。

  默认情况下，Emacs通过查看段落开头的文本来确定每个段落的基本方向。确定基本方向的精
确方法由@acronym{UBA}指定，简而言之，段落中具有明确方向性的第一个字符决定了段落的
基本方向。然而，有时缓冲区可能需要为它的段落强行规定某个基本方向。例如，包含程序源代
码的缓冲区应该强制所有段落从左到右显示。你可以使用下面的变量来实现这一点:

@defopt bidi-paragraph-direction
如果这个缓冲区局部变量的值是符号@code{right-to-left}或@code{left-to-right}，
那么缓冲区中的所有段落都被假定为具有该指定方向。其他任何值都等同于@code{nil}。(默
认)，即根据每段内容确定其基本方向。

@cindex @code{prog-mode}, and @code{bidi-paragraph-direction}
程序源代码的模式应该将此设置为@code{left-to-right}。Prog模式默认这样做，所以从
Prog模式派生出来的模式不需要显式地设置这一点(@pxref{Basic Major Modes})。
@end defopt

@defun current-bidi-paragraph-direction &optional buffer
此函数返回命名为@var{buffer}的点的段落方向。返回值是一个符号，可以是
@code{left-to-right}或@code{right-to-left}，如果省略@var{buffer}或
@code{nil}，则默认为当前缓冲区。如果变量@code{bidi-paragraph-direction}的缓
冲区本地值是非@code{nil}，则返回的值将与该值相同；否则，返回的值反映Emacs动态确定
的段落方向。对于@code{bidi-display-reordering}值为@code{nil}的缓冲区以及单字
节缓冲区，这个函数总是返回@code{left-to-right}。
@end defun

@cindex visual-order cursor motion
  有时需要严格按照视觉顺序移动点，要么向左，要么向右移动其当前屏幕位置。Emacs提供了
一个原生函数来实现这一点:

@defun move-point-visually direction
此函数将当前选中的窗口中的点移动到屏幕上紧靠点的右边或左边的缓冲区位置。如果
@var{direction}为正值，则点将向右移动一个屏幕位置，否则将向左移动一个屏幕位置。请
注意，根据周围的双向上下文，这可能会使点移动许多缓冲区位置。如果在一个屏幕行结束时调
用，函数会将point移动到下一个或上一个屏幕行的最右边或最左边的屏幕位置，视
@var{direction}的值而定。

该函数使用新的缓冲区位置作为其返回值。
@end defun

@cindex layout on display, and bidirectional text
@cindex jumbled display of bidirectional text
@cindex concatenating bidirectional strings
  当两个具有双向内容的字符串在缓冲区中并列，或以其他方式程序化地连成一串文本时，双向
重排序会产生令人惊讶和不愉快的效果。一个典型的问题案例是当一个缓冲区由由空格或标点符
号分隔的文本字段序列组成时，就像缓冲区菜单模式或Rmail摘要模式一样。由于用作分隔符的
标点符号具有@dfn{weak directionality}，它们会采取周围文本的方向性。因此，一个数
字字段如果跟在一个具有双向内容的字段后面，可能会显示在前一个字段的@emph{向左}，从而打乱了预期的布局。有几种方法可以避免这个问题:

@itemize @minus
@item
添加特殊字符U+200E@sc{从左到右的标记}，或@acronym{LRM}，到每个字段的末尾，可能有
双向的内容，或者把它放在下面字段的开头。下面介绍的函数
@code{bidi-string-mark-left-to-right}，可以很方便地实现这个目的。在从右向左的
段落中，可以使用U+200F@sc{从右向左标记}，或者@acronym{RLM}代替）。这是UBA推荐的
解决方案之一。

@item
在字段分隔符中加入tab字符。在双向重新排序中，制表符起到@dfn{segment separator}的
作用，使两边的文字分别重新排序。

@cindex @code{space} display spec, and bidirectional text
@item
用@code{display}属性分隔字段，或用@code{(space . PROPS)}形式的属性值叠加。(
@pxref{Specified Space})。Emacs将这个显示规范视为
@dfn{paragraph separator}，并分别对两边的文本进行重新排序。
@end itemize

@defun bidi-string-mark-left-to-right string
这个函数返回它的参数@var{string}，可能会修改，使结果可以安全地与另一个字符串连接，
或者与缓冲区中的另一个字符串并列，而不会破坏这个字符串和下一个字符串的相对布局。如果
该函数返回的字符串是作为从左到右的段落的一部分显示，那么它将始终显示在其后面的文本的
左边。该函数通过检查其参数中的字符来工作，如果其中任何一个字符可能会导致显示顺序的改
变，该函数就会将@acronym{LRM}字符追加到字符串中。通过给@code{t}的
@code{invisible}文本属性，被追加的@acronym{LRM}字符将变得不可见。(
@pxref{Invisible Text})。
@end defun

重排序算法使用字符的双向属性存储为其@code{bidi-class}属性（
@pxref{Character Properties}）。Lisp程序可以通过调用
@code{put-char-code-property}函数来改变这些属性。然而，要做到这一点，就需要彻底
了解@acronym{UBA}，因此不建议使用。任何改变字符的双向属性具有全局效应：它们影响所
有Emacs窗框和窗口。

同样，@code{mirroring}属性用于在重新排序的文本中显示相应的镜像字符。Lisp程序可以
通过改变这个属性来影响镜像显示。同样，任何这样的改变都会影响Emacs的所有显示。

@cindex overriding bidirectional properties
@cindex directional overrides
@cindex LRO
@cindex RLO
通过在文本中插入特殊的方向控制字符，LEFT-TO-RIGHT OVERRIDE (@acronym{LRO})
和 RIGHT-TO-LEFT OVERRIDE (@acronym{RLO})，可以覆盖字符的双向属性。在
@acronym{RLO}和下面的换行符或POP DIRECTIONAL FORMATTING(@acronym{PDF})控制
字符之间的任何字符（以先到者为准），将被当作从右到左的强字符来显示，即@: 它们将在显
示时被反转。同样地，在@acronym{LRO}和@acronym{PDF}或新行之间的任何字符都会被显示
为从从左到右的强字符，即使是从右到左的强势字符，也@emph{不}会反。

@cindex phishing using directional overrides
@cindex malicious use of directional overrides
当你想让一些文本不受重新排序算法的影响，而直接控制显示顺序时，这些覆盖是很有用的。但
它们也可以用于恶意目的，也就是所谓的@dfn{phishing}。具体来说，网页上的一个URL或电
子邮件中的一个链接可以被操纵，使其视觉外观无法识别，或与一些流行的良性位置相似，而真
实的位置，被浏览器按照逻辑顺序解释，却大相径庭。

Emacs提供了一个基元，应用程序可以使用它来检测双向属性被覆盖的文本实例，从而使从左到
右的字符显示为从右到左的字符，或者反之亦然。

@defun bidi-find-overridden-directionality from to &optional object
该函数在@var{object}（含）和@var{to}（不含）之间查找指定的@var{object}的文本，
并返回第一个找到从左到右的强字符的位置，该字符的方向属性被强制显示为从右到左，或者对
于从右到左的强字符被强制显示为从左到右。如果它在文本的指定区域内没有找到这样的字符，
则返回@code{nil}。

可选参数@var{object}指定要搜索的文本，默认为当前的缓冲区，如果@var{object}是非
@code{nil}，则可以是其他缓冲区，也可以是字符串或窗口。如果是字符串，函数搜索该字符
串。如果是窗口，函数搜索该窗口中显示的缓冲区。如果你想检查的文本缓冲区显示在某个窗口
中，我们建议通过该窗口来指定，而不是将缓冲区传递给函数。这是因为告诉函数有关窗口的信
息，可以让函数正确地考虑特定窗口的覆盖，如果缓冲区中的某些文本被覆盖，则可能会改变函
数的结果。
@end defun

@cindex copying bidirectional text, preserve visual order
@cindex visual order, preserve when copying bidirectional text
  当包含从右到左和从左到右混合字符和双向控制的文本被复制到不同的位置时，它可能会改变
其视觉外观，也可能会影响目的地周围文本的视觉外观。这是因为由@acronym{UBA}指定的对
双向文本进行重新排序与上下文非常规有关，无论是对复制的文本和包围它的复制目标处的文本
。

@defun buffer-substring-with-bidi-context start end &optional no-properties
这个函数的工作原理类似于@code{buffer-substring}。(@pxref{Buffer Contents})
，但它会在复制的文本中预先添加并附加必要的双向方向控制字符，以便在另一处插入时保持文
本的视觉外观。可选参数@var{no-properties}，如果是非@code{nil}，则表示从复制的文
本中删除文本属性。
@end defun
