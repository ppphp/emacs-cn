@c -*-coding: utf-8-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990--1994, 2001--2020 Free Software Foundation, Inc.
@c See the file elisp.texi for copying conditions.

@node 介绍
@chapter Introduction

  大多数GNU Emacs文本编辑器是用名为Emacs Lisp的编程语言编写的。你可以用
Emacs Lisp编写新的代码，并将其作为编辑器的扩展安装。然而，Emacs Lisp不仅仅
是一种扩展语言，它本身就是一种完整的计算机编程语言。你可以像使用其他编程语言一样使用它。

  因为Emacs Lisp是为在编辑器中使用而设计的，它具有扫描和解析文本的特殊功能
，以及处理文件、缓冲区、显示、子进程等的功能。 Emacs Lisp与编辑设施紧密结合
，因此，编辑命令是函数，也可以方便地从Lisp程序中调用，自定义的参数是普通的
Lisp变量。

  本手册试图成为Emacs Lisp的完整描述。 关于Emacs Lisp的初学者介绍，请参见
@cite{An Introduction to Emacs Lisp Programming}，作者Bob Chassell，也是
由自由软件基金会出版。这本手册的前提是对Emacs的编辑使用相当熟悉；关于这些基
本信息，请参见@cite{The GNU Emacs Manual}。

  一般来说，前面的章节描述了Emacs Lisp的功能，这些功能在许多编程语言中都有
对应的功能，而后面的章节则描述了Emacs Lisp特有的功能或与编辑有关的功能。

  这是
@cite{GNU Emacs Lisp Reference Manual}
@iftex
的版本@value{VERSION}
@end iftex
，对应Emacs版本@value{EMACSVER}.

@menu
* 注意事项::            缺陷和求助。
* Lisp的历史::         Emacs Lisp是Maclisp的后代。
* 惯例::               本手册的格式。
* 版本信息::           正在运行的Emacs版本是什么？
* 鸣谢::               本手册的作者、编辑和赞助商。
@end menu

@node 注意事项
@section Caveats
@cindex bugs in this manual

  这本手册经过了无数次的起草。它几乎是完整的，但并非完美无缺。有几个主题没有
涉及到，要么是因为我们认为它们是次要的（比如大多数的单独模式），要么是因为它
们还没有写出来。因为我们无法完全处理它们，所以故意漏掉了几个部分。

  这本手册所涵盖的内容应该是完全正确的，因此，它所说的任何内容--从具体的例子
和描述性的文字，到章节和部分的顺序，都可以接受批评。如果有什么地方让人困惑，
或者你发现你必须看资料或做实验才能学到手册中没有涉及的东西，那么也许手册应该
被修正。请告诉我们。

@iftex
  在您使用本手册的过程中，我们请您在页面上标明更正的内容，以便日后查找并寄给
我们。如果您想到了一个简单的、现实生活中的某一函数或一组函数的例子，请努力写
出来并寄给我们。请将任何意见酌情引用章名、节名和函数名，因为页码和章、节号会
发生变化，我们可能难以找到你所说的文字。 同时请注明你所批评的版本。
@end iftex
@ifnottex

在您使用本手册的过程中，我们请您在发现更正的地方尽快寄来。如果您想到了一个简
单的、现实生活中的函数或函数组的例子，请您努力写出来，并将其发送过来。如有注
释，请酌情引用节点名和函数或变量名。同时请注明你所批评的版本号。
@end ifnottex

@cindex bugs
@cindex suggestions
请使用@kbd{M-x report-emacs-bug}发送评论和纠正。

@node Lisp的历史
@section Lisp History
@cindex Lisp history

  Lisp（链表处理语言）最早是在20世纪50年代末在麻省理工学院开发的，用于人工
智能的研究。 Lisp语言的强大功能使它也非常适合用于其他用途，如编写编辑命令。

@cindex Maclisp
@cindex Common Lisp
  多年来已经建立了几十个Lisp实现，每个都有自己的特质。其中许多是受Maclisp的
启发，Maclisp是在20世纪60年代由MIT的MAC@ 项目编写的。最终，Maclisp的后裔的
实现者们走到了一起，开发了一个Lisp系统的标准，称为Common Lisp。与此同时，麻
省理工学院的Gerry Sussman和Guy Steele开发了一种简化但非常强大的Lisp方言，
称为Scheme。

  GNU Emacs Lisp在很大程度上受到Maclisp的启发，同时也受到Common Lisp的影响
。如果你了解Common Lisp，你会注意到许多相似之处。然而，为了减少GNU Emacs的
内存需求，许多通用Lisp的功能被省略或简化了。有时这些简化是如此的剧烈，以至于
Common Lisp用户可能会感到非常困惑。我们偶尔会指出GNU Emacs Lisp与Common
Lisp的不同之处。如果你不懂Common Lisp，不用担心，这本手册是包括自身的。

@pindex cl
  通过@file{cl-lib}库可以实现一定的Common Lisp模拟。
@xref{Top，，Overview，cl，Common Lisp Extensions}。

  Emacs Lisp完全没有受到Scheme的影响；但是GNU项目有一个Scheme的实现，叫做
Guile。 我们在所有需要扩展的GNU软件中都使用了它。

@node 惯例
@section Conventions

本节解释了本手册中使用的符号约定。您可能想跳过本节，以后再参考。

@menu
* 一些术语::       解释我们在本手册中使用的术语。
* nil和t::         符号@code{nil}和@code{t}的使用方法。
* 运行记号::       我们运行例子时使用的格式。
* 打印记号::       我们在例子打印文本时使用的格式。
* 错误信息::       我们用于错误示例的格式。
* 缓冲区文本记号:: 我们用于例子中缓冲区内容的格式。
* 描述的格式::     描述函数、变量等的符号。
@end menu

@node 一些术语
@subsection Some Terms

  在本手册中，"Lisp reader "和 "Lisp printer "指的是Lisp中那些将Lisp对象
的文本表示转换成实际Lisp对象的例程，反之亦然。更多细节请参见
@xref{Printed Representation}。你，也就是阅读这本手册的人，被认为是程序员
，被称为"你"。用户是指使用Lisp程序的人，程序包括你编写的程序。

@cindex typographic conventions
  Lisp代码的例子是这样格式的。@code{(list 1 2 3)}。表示元语法变量的名称，
或者是所描述的函数的参数，其格式如下：@var{first-number}。

@node nil和t
@subsection @code{nil} and @code{t}
@cindex truth value
@cindex boolean

@cindex @code{nil}
@cindex false
  在Emacs Lisp中，符号@code{nil}有三个独立的含义：它是一个名称为@samp{nil}
的符号；它是逻辑真值@var{false}；它是空列表---零元素的列表。当作为变量使用
时，@code{nil}的值总是@code{nil}。

  就Lisp读者而言，@samp{()}和@samp{nil}是相同的：它们代表同一个对象，即符
号@code{nil}。符号的不同写法完全是为人类读者准备的。当Lisp读者读取了
@samp{()}或@samp{nil}之后，就无法确定到底哪种表示方式是程序员写的。

  在本手册中，当我们希望强调它的意思是空列表时，我们就写@code{()}，当我们希
望强调它的意思是真值@var{false}时，我们就写@code{nil}。这在Lisp程序中也是
一个很好的约定。

@example
(cons 'foo ())                ; @r{Emphasize the empty list}
(setq foo-flag nil)           ; @r{Emphasize the truth value @var{false}}
@end example

@cindex @code{t}
@cindex true
  在预期有真值的上下文，任何非@code{nil}的值都被认为是@var{true}。然而，
@code{t}是表示真值@var{true}的首选方式。当您需要选择一个代表@var{true}的值
，并且没有其他选择基准时，请使用@code{t}。符号@code{t}的值总是@code{t}。

  在Emacs Lisp中，@code{nil}和@code{t}是特殊的符号，它们总是求值到自身。
这样你就不需要引用它们来作为程序中的常量使用。试图改变它们的值会导致
@code{setting-constant}错误。@xref{常态变量}。

@defun booleanp object
如果@var{object}是两个规范的布尔值：@code{t}或@code{nil}之一，则返回非
@code{nil}。
@end defun

@node 运行记号
@subsection Evaluation Notation
@cindex evaluation notation
@cindex documentation notation
@cindex notation

  一个可以评估的Lisp表达式被称为@dfn{form}。评估一个表单总是会产生一个结果
，这个结果是一个Lisp对象，在本手册的例子中，用@samp{@result{}}来表示。

@example
(car '(1 2))
     @result{} 1
@end example

@noindent
你可以将其理解为 ``@code{(car '(1 2))}估值为 1''。

  当一个表单是一个宏调用时，它就会扩展成一个新的表单供Lisp求值。我们用
@samp{@expansion{}}显示展开的结果。我们可能会显示，也可能不会显示展开后的
表单的计算结果。

@example
(third '(a b c))
     @expansion{} (car (cdr (cdr '(a b c))))
     @result{} c
@end example

  为了帮助描述一种形式，我们有时会展示另一种产生相同结果的形式。两种形式的确
切等价性用@samp{@equiv{}}表示。

@example
(make-sparse-keymap) @equiv{} (list 'keymap)
@end example

@node 打印记号
@subsection Printing Notation
@cindex printing notation


  本手册中的许多例子在被求值时都会打印文本。如果在Lisp交互缓冲区中执行示例
代码（例如缓冲区@file{*scratch*}），打印的文本会被插入缓冲区中。如果通过其
他方式执行示例（如求值函数@code{eval-region}），则打印的文本会显示在回声区
。

  本手册中的例子用@samp{@print{}}来表示打印的文本，而不管这些文本在哪里。
评估表单后返回的值用@samp{@result{}}单独成一行。

@example
@group
(progn (prin1 'foo) (princ "\n") (prin1 'bar))
     @print{} foo
     @print{} bar
     @result{} bar
@end group
@end example

@node 错误信息
@subsection Error Messages
@cindex error message notation

  一些例子会显示错误信号。这通常会在回声区显示一个错误信息，我们在
@samp{@error{}}开头的一行显示错误信息。请注意，@samp{@error{}}本身不会出现
在回声区。

@example
(+ 23 'x)
@error{} Wrong type argument: number-or-marker-p, x
@end example

@node 缓冲区文本记号
@subsection Buffer Text Notation
@cindex buffer text notation

  一些例子通过显示文本的前后版本来描述对缓冲区内容的修改。这些例子在两行包含
缓冲区名称的破折号之间显示了缓冲区的内容。此外，@samp{@point{}}表示点的位置
。(当然，点的符号并不是缓冲区中文本的一部分，它表示的是@emph{between}两个字
符之间的位置，也就是点当前所在的位置。)

@example
---------- Buffer: foo ----------
This is the @point{}contents of foo.
---------- Buffer: foo ----------

(insert "changed ")
     @result{} nil
---------- Buffer: foo ----------
This is the changed @point{}contents of foo.
---------- Buffer: foo ----------
@end example

@node 描述的格式
@subsection Format of Descriptions
@cindex description format

  在本手册中，函数、变量、宏、命令、用户选项和特殊形式都以统一的格式进行描述
。 描述的第一行包含项目的名称，然后是其参数（如果有）。
@ifnottex
类别---函数、变量或其他---出现在行首。
@end ifnottex
@iftex
类别------函数、变量或其他------被打印在右边的空白处。
@end iftex
后面几行是描述，有时还会举例说明。

@menu
* 一个样例函数的描述::  一个虚构的函数@code{foo}的描述。
* 一个样例变量的描述::  一个虚构的变量@code{electric-future-map}的描述。
@end menu

@node 一个样例函数的描述
@subsubsection A Sample Function Description
@cindex function descriptions
@cindex command descriptions
@cindex macro descriptions
@cindex special form descriptions

  在函数描述中，首先出现被描述的函数名。在同一行中，它的后面是一个参数名称的
列表。这些名称也用于描述的正文中，代表参数的值。

  在参数列表中出现关键字@code{&optional}表示可以省略后面的参数（省略的参数
默认为@code{nil}）。调用函数时不要写上@code{&optional}。

  关键字@code{&rest}后面必须有一个参数名）表示后面可以有任意数量的参数。跟
在@code{&rest}后面的单个参数名作为其值，接收所有传递给函数的剩余参数的列表
。调用函数时不要写上@code{&rest}。

  下面是一个虚构函数@code{foo}的描述：

@defun foo integer1 &optional integer2 &rest integers
函数@code{foo}从 @var{integer2}中减去@var{integer1}，然后将其余参数加到
结果中。如果没有提供@var{integer2}，那么默认使用数字19。

@example
(foo 1 5 3 9)
     @result{} 16
(foo 5)
     @result{} 14
@end example

@need 1500
更通用地

@example
(foo @var{w} @var{x} @var{y}@dots{})
@equiv{}
(+ (- @var{x} @var{w}) @var{y}@dots{})
@end example
@end defun

  按照惯例，任何名字中包含类型名称的参数（例如@var{integer},@var{integer1}
或@var{buffer}）都应该属于该类型。一个类型的复数(如@var{buffers})通常意味
着是该类型的对象列表。一个名为@var{object}的参数可以是任何类型。(关于Emacs
对象类型的列表，请参见@pxref{Lisp Data Types}。)具有任何其他类型名称的参数
(例如，@var{new-file})是某函数特定的；如果函数有文档字符串，参数的类型应该
在那里描述(@pxref{Documentation})。

  @xref{Lambda Expressions}，对@code{&optional}和@code{&rest}修改的参数有
更完整的描述。

  命令、宏和特殊表单的描述具有相同的格式，但@samp{Function}一词分别被
@samp{Command}、@samp{Macro}或@samp{Special Form}所取代。命令只是可以被交
互式调用的函数；宏处理其参数的方式与函数不同（参数不被求值），但表现方式是一
样的。

  宏和特殊表单的描述使用了一个更复杂的符号来指定可选的和重复的参数，因为它们
可以将参数列表以更复杂的方式分解为独立的参数。
@samp{@r{[}@var{optional-arg}@r{]}}表示@var{optional-arg}是可选的，
@samp{@var{repeated-args}@dots{}}代表零或多个参数。当多个参数被归入额外的
列表结构层次时，会使用括号。下面是一个例子：

@defspec count-loop (var [from to [inc]]) body@dots{}
这个虚构的特殊形式实现了一个循环，它执行@var{body}形式，然后在每次迭代时递
增变量@var{var}。在第一次迭代时，变量的值是@var{from}；在随后的迭代中，变量
的值会增加一（如果增加给定了的@var{inc}）。如果@var{var}等于@var{to}，循环
会在执行@var{body}之前退出。下面是一个例子：

@example
(count-loop (i 0 10)
  (prin1 i) (princ " ")
  (prin1 (aref vector i))
  (terpri))
@end example

如果省略@var{from}和@var{to}，则@var{var}在循环开始前被绑定到@code{nil}，如果@var{var}在迭代开始时是非@code{nil}，则循环退出。下面是一个例子：

@example
(count-loop (done)
  (if (pending)
      (fixit)
    (setq done t)))
@end example

在这种特殊表单中，参数@var{from}和@var{to}是可选的，但必须同时存在或不存在
。如果这两个参数存在，那么@var{inc}也可以被选择性地指定。这些参数与@var{var
}参数一起被归为一个列表，以区别于@var{body}，后者包含了表单中所有剩余的元素
。
@end defspec

@node 一个样例变量的描述
@subsubsection A Sample Variable Description
@cindex variable descriptions
@cindex option descriptions

  一个@dfn{variable}是一个可以被@dfn{bound}（或@dfn{set}）的名字，用来表
示一个对象。变量所绑定的对象被称为一个@dfn{value};我们也说该变量拥有该值。
虽然几乎所有的变量都可以由用户设置，但某些变量的存在是专门为了让用户可以改变
它们，这些变量就是称为@dfn{user options}。普通变量和用户选项是用类似于函数
的格式来描述，除了是没有参数的。

  下面是对虚构的@code{electric-future-map}的描述。

@defvar electric-future-map
这个变量的值是Electric Command Future模式使用的完整快捷键图。这个键图中的
函数允许你编辑你还没有想到要执行的命令。
@end defvar

  用户选项的描述有相同的格式，但是@samp{变量}被@samp{用户选项}所取代。

@node 版本信息
@section Version Information

  这些设施提供了关于Emacs正在使用的版本的信息。

@deffn Command emacs-version &optional here
这个函数返回一个描述正在运行的Emacs的版本的字符串。在错误报告中包含这个字符
串会很有帮助的。

@smallexample
@group
(emacs-version)
  @result{} "GNU Emacs 26.1 (build 1, x86_64-unknown-linux-gnu,
             GTK+ Version 3.16) of 2017-06-01"
@end group
@end smallexample

如果@var{here}是非@code{nil}，则在点之前的缓冲区中插入文本，并返回
@code{nil}。当交互式调用这个函数时，它在回声区打印同样的信息，但给出一个前
缀参数使得@var{here}是非@code{nil}。
@end deffn

@defvar emacs-build-time
这个变量的值表示构建Emacs的时间点。它使用@code{current-time}的样式(
@pxref{Time of Day})，如果这个信息无法获得，则为@code{nil}。

@example
@group
emacs-build-time
     @result{} (20614 63694 515336 438000)
@end group
@end example
@end defvar

@defvar emacs-version
这个变量的值是正在运行的Emacs的版本。它是一个字符串，如@code{"26.1"}。
有三个数字成分的值，如 @code{"26.0.91"}，表示一个未发布的测试版本。(在
Emacs 26.1 之前，这个字符串包含一个额外的最后一个整数成分，现在存储在
@code{emacs-build-number} 中，例如 @code{"25.1.1"})。
@end defvar

@defvar emacs-major-version
Emacs的主要版本号，为整数。 对于Emacs版本23.1，数值为23。
@end defvar

@defvar emacs-minor-version
Emacs的次要版本号，为整数。对于Emacs23.1版本，数值为1。
@end defvar

@defvar emacs-build-number
一个整数，每次Emacs在同一目录（没有清理）下构建时都会递增。这只在开发Emacs
时才有意义。
@end defvar

@defvar emacs-repository-version
一个给出构建Emacs的版本库版本的字符串。如果Emacs是在版本控制之外构建的，那
么这个值是@code{nil}。
@end defvar

@defvar emacs-repository-branch
给出构建Emacs的仓库分支的字符串。在大多数情况下，这个值是@code{"master"}。
如果Emacs是在版本控制之外构建的，那么这个值是@code{nil}。
@end defvar

@node 鸣谢
@section Acknowledgments

  这份手册原著为Robert Krawitz, Bil Lewis, Dan LaLiberte,
Richard@tie{}M. Stallman和Chris Welty，都是GNU手册组的志愿者，协力写了数年
而成。 Robert@tie{}J. Chassell在经过国防部高级研究计划局，由Warren@tie{}A.
Hunt, Jr.@: Computational Logic, Inc.安排的ARPA命令6082的帮助下，审视和编
辑手册。额外章节由Miles Bader, Lars Brinkhoff, Chong Yidong, Kenichi
Handa, Lute Kamstra, Juri Linkov, Glenn Morris, Thien-Thi Nguyen, Dan
Nicolaescu, Martin Rudalics, Kim F. Storm, Luc Teirlinck, and Eli
Zaretskii, 和其他人编写.

  纠正由Drew Adams, Juanma Barranquero, Karl Berry, Jim Blandy, Bard
Bloom, Stephane Boucher, David Boyes, Alan Carroll, Richard Davis,
Lawrence R. Dodd, Peter Doornbosch, David A. Duff, Chris Eich, Beverly
Erlebacher, David Eckelkamp, Ralf Fassel, Eirik Fuller, Stephen Gildea,
Bob Glickstein, Eric Hanchrow, Jesper Harder, George Hartzell, Nathan
Hess, Masayuki Ida, Dan Jacobson, Jak Kirman, Bob Knighten, Frederick
M. Korz, Joe Lammens, Glenn M. Lewis, K. Richard Magill, Brian Marick,
Roland McGrath, Stefan Monnier, Skip Montanaro, John Gardiner Myers,
Thomas A. Peterson, Francesco Potortì, Friedrich Pukelsheim, Arnold D.
Robbins, Raul Rockwell, Jason Rumney, Per Starbäck, Shinichirou Sugou,
Kimmo Suominen, Edward Tharp, Bill Trost, Rickard Westman, Jean White,
Eduard Wiebe, Matthew Wilding, Carl Witty, Dale Worley, Rusty Wright,
和David D. Zuhn提供。

  关于更完整的贡献者列表，请参见Emacs源码库中的相关变更日志条目。
