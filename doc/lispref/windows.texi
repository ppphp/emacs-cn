@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990--1995, 1998--1999, 2001--2020 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Windows
@chapter Windows

本章介绍与Emacs窗口相关的函数和变量。@xref{窗帧},用于了解如何为Emacs分配一个可用
的屏幕区域。@xref{显示}, 用于了解如何在窗口中显示文本。

@menu
* 基本窗口::         关于使用窗口的基本信息。
* 窗口和窗框::       将窗口与它们所处的窗框联系起来。
* 窗口大小::         访问窗口的大小。
* 调整窗口大小::      改变窗口的大小。
* 保留窗口大小::      保留窗口的大小。
* 分割窗口::         创建新窗口。
* 删除窗口::         从窗框中删除窗口。
* 重新组合窗口::      在分割和删除窗口时保留框架布局。
* 选择窗口::         被选中的窗口就是你编辑的窗口。
* 循环窗口排序::      在现有窗口中移动。
* 缓冲区和窗口::      每个窗口都会显示一个缓冲区的内容。
* 切换缓冲区::        切换缓冲区的高级功能。
* 显示缓冲区::        在合适的窗口中显示缓冲区。
* 窗口历史记录::      每个窗口都会记住显示在窗口中的缓冲区。
* 专用窗口::         如何避免在特定窗口中显示另一个缓冲区。
* 退出窗口::         如何恢复显示缓冲区前的状态。
* 侧边窗口::         在窗框侧面的特殊窗口。
* 原子窗口::        保留窗口布局的一部分。
* 窗口点::          每个窗口都有自己的点的位置。
* 窗口开始和结束::    缓冲区位置，表示窗口中哪些文字在屏幕上。
* 文本滚动::        在窗口中上下移动文字。
* 垂直滚动::         在窗口中上下移动文本。
* 水平滚动::        在窗口中横向移动内容。
* 坐标和窗口::       將座標轉換為視窗。
* 鼠标自动选择窗口:: 用鼠标自动选择窗口。
* 窗口配置::        保存和恢复屏幕状态。
* 窗口参数::        将附加信息与窗口关联。
* 窗口钩子::        钩子用于滚动、改变窗口大小、重新显示到某一点或改变窗口配置。
@end menu


@node 基本窗口
@section Basic Concepts of Emacs Windows
@cindex window

一个@dfn{window}是屏幕上用来显示缓冲区的区域（@pxref{缓冲区}）。在Emacs Lisp中
，窗口由一个特殊的Lisp对象类型来表示。

@cindex multiple windows
  窗口被分组为窗框（@pxref{Frames}）。每个窗框至少包含一个窗口；用户可以将其细分为
多个不重叠的窗口，以便同时查看多个缓冲区。Lisp程序可以将多个窗口用于各种用途。例如，
在Rmail中，你可以在一个窗口中查看消息标题的摘要，在另一个窗口中查看所选消息的内容。

@cindex terminal screen
@cindex screen of terminal
  Emacs使用的"窗口"一词与图形桌面环境和窗口系统（如X窗口系统）中的含义不同。当
Emacs在X上运行时，其每一个图形X窗口都是一个Emacs窗框（包含一个或多个Emacs窗口）。
当Emacs在文本终端上运行时，窗框会填满整个终端屏幕。

@cindex tiled windows
  与X窗口不同的是，Emacs窗口是@dfn{tiled}的，它们在窗框的区域内从不重叠。当一个窗
口被创建、调整大小或删除时，窗口空间的变化会从相邻的窗口中提取或给予相邻的窗口，因此窗框的总面积是不变的。

@defun windowp object
如果@var{object}是一个窗口（不管它是否显示缓冲区），这个函数返回@code{t}。否则，
返回@code{nil}。
@end defun

@cindex live windows
一个@dfn{live window}是指在一个窗框中实际显示一个缓冲区。

@defun window-live-p object
如果@var{object}是一个实时窗口，则该函数返回@code{t}，否则返回@code{nil}。实时
窗口是指显示一个缓冲区的窗口。
@end defun

@cindex internal windows
每个框架中的窗口都被组织成一个@dfn{window tree}。@xref{窗口和窗框}。每个窗口树的
叶子节点是实时窗口--实际显示缓冲区的窗口。窗口树的内部节点是
@dfn{internal windows}，它们不是实时的。

@cindex valid windows
  一个@dfn{valid window}是一个活的或内部的窗口。一个有效的窗口可以被
@dfn{deleted}，即从它的有效窗框中移除(@pxref{删除窗口})；那么它就不再有效了，但
代表它的Lisp对象可能仍然可以从其它Lisp对象中引用。被删除的窗口可以通过恢复已保存的
窗口配置来重新生效(@pxref{窗口配置})。

  您可以使用@code{window-valid-p}区分有效窗口和被删除的窗口。

@defun window-valid-p object
如果@var{object}是一个实时窗口，或者是窗口树中的一个内部窗口，则该函数返回
@code{t}。否则，它返回@code{nil}，包括@var{object}是一个被删除的窗口的情况。
@end defun

@cindex selected window
@cindex window selected within a frame
  在每个有效窗框中，在任何时候，正好有一个Emacs窗口被指定为
@dfn{selected within the frame}。插入或删除文本的键盘输入通常也会指向这个窗口
。所选窗口的缓冲区通常也是当前缓冲区，除非使用了@code{set-buffer}（
@pxref{当前缓冲区}）。对于非选择的窗框，如果该窗框被选中，那么选择窗框内被选中的窗
口就会成为被选中的窗口。@xref{选择窗口}。

@defun selected-window
该函数返回所选窗口（始终是一个实时窗口）。
@end defun

@anchor{窗口组}有时几个窗口一起，而且还可以在窗口组中进行操作，合作显示一个缓冲区，
例如，在Follow Mode(@pxref{Follow Mode,,, emacs})的管理下，这些窗口一起显示的
缓冲区比一个窗口单独显示的缓冲区更大。将这样的@dfn{window group}视为一个单一的实
体通常是很有用的。一些函数，如 @code{window-group-start} (
@pxref{窗口开始和结束})，允许您通过提供其中一个窗口作为参数来代替整个组。

@defun selected-window-group
@vindex selected-window-group-function
当选中的窗口是一组窗口的成员时，该函数返回一组窗口的列表，排序方式是列表中的第一个窗
口显示缓冲区的最早部分，以此类推。否则，该函数返回一个只包含所选窗口的列表。

当缓冲区局部变量@code{selected-window-group-function}被设置为函数时，被选中的
窗口被认为是一个组的一部分。在这种情况下，@code{selected-window-group}会在没有
参数的情况下调用它，并返回它的结果（应该是组中的窗口列表）。
@end defun

@node 窗口和窗框
@section Windows and Frames

每个窗口正好属于一个窗框（@pxref{Frames}）。

@defun window-frame &optional window
此函数返回@var{window}窗口所属的窗框。如果@var{window}是@code{nil}，则默认为选
定的窗口。
@end defun

@defun window-list &optional frame minibuffer window
此函数返回属于@var{frame}窗框的实时窗口列表。如果省略了@var{frame}或者是
@code{nil}，则默认为选定的窗框。

可选参数@var{minibuffer}指定是否在返回的列表中包含minibuffer窗口，如果
@var{minibuffer}是@code{t}，则包含minibuffer窗口。如果@var{minibuffer}为
@code{nil}或被省略，则只有在minibuffer窗口处于活动状态时才会被包含。如果
@var{minibuffer}既不是@code{nil}，也不是@code{t}，则永远不包含minibuffer窗口
。

可选参数@var{window}，如果非@code{nil}，则应该是指定窗框上的一个实时窗口；那么
@var{window}将是返回列表中的第一个元素。如果省略了@var{window}或者@code{nil}，
则在窗框中选择的窗口为第一个元素。
@end defun

@cindex window tree
@cindex root window
  同一窗框中的窗口被组织成一棵@dfn{window tree}，它的叶子节点是活窗口。窗口树的内
部节点不是活的，它们的存在是为了组织活窗口之间的关系。窗口树的根节点称为
@dfn{root window}。它可以是一个活窗口（如果框架只有一个窗口），也可以是一个内部窗
口。

  一个迷你缓冲区窗口(@pxref{Minibuffer Windows})如果不是单独存在于其窗框上，那
么它就没有父窗口，所以严格来说，它不是其窗框的窗口树的一部分。尽管如此，它还是窗框的
根窗口的兄弟姐妹窗口，因此可以通过@code{window-next-sibling}到达。另外，本节末
尾描述的函数@code{window-tree}在实际的窗口树旁边列出了minibuffer窗口。

@defun frame-root-window &optional frame-or-window
此函数返回@var{frame-or-window}的根窗口。参数@var{frame-or-window}应该是一个
窗口或窗框；如果省略或@code{nil}，则默认为选定的窗框。如果@var{frame-or-window}
是一个窗口，那么返回值就是该窗口的窗框的根窗口。
@end defun

@cindex parent window
@cindex child window
@cindex sibling window
当一个窗口被拆分时，会有两个活窗口，而之前只有一个。其中一个由与原窗口相同的Lisp窗口
对象表示，另一个由新创建的Lisp窗口对象表示。这两个活窗口都会成为窗口树的叶子节点，作
为单个内部窗口的@dfn{child windows}。如果有必要，Emacs会自动创建这个内部窗口，也
就是@dfn{parent window}，并将其分配到窗口树的适当位置。一组共享同一个父窗口的窗口
被称为@dfn{siblings}。

@cindex parent window
@defun window-parent &optional window
此函数返回@var{window}的父窗口。如果省略了@var{window}或者@code{nil}，则默认为
选定的窗口。如果@var{window}没有父窗口（即它是一个迷你缓冲窗口或其窗框的根窗口），
则返回值为@code{nil}。
@end defun

  每个内部窗口总是至少有两个子窗口。如果因为删除窗口而使这一数字下降到1，Emacs就会
自动删除内部窗口，其唯一剩下的子窗口就会在窗口树中占据一席之地。

  每个子窗口可以是一个活窗口，也可以是一个内部窗口（内部窗口又有自己的子窗口）。因此
，每个内部窗口都可以被认为占据了一定的长方形@dfn{screen area}--最终是由它后代的
活跃窗口所占区域的组合。

@cindex window combination
@cindex vertical combination
@cindex horizontal combination
对于每一个内部窗口，紧邻的子窗口的屏幕区域都是垂直或水平排列的（绝不是两者兼有）。如
果子窗口一个比一个高，则称其形成@dfn{vertical combination}；如果并排排列，则称
其形成@dfn{horizontal combination}。请看下面的例子:

@smallexample
@group
     ______________________________________
    | ______  ____________________________ |
    ||      || __________________________ ||
    ||      |||                          |||
    ||      |||                          |||
    ||      |||                          |||
    ||      |||____________W4____________|||
    ||      || __________________________ ||
    ||      |||                          |||
    ||      |||                          |||
    ||      |||____________W5____________|||
    ||__W2__||_____________W3_____________ |
    |__________________W1__________________|

@end group
@end smallexample

@noindent
这个窗框的根窗口是一个内部窗口，@var{W1}。它的子窗口形成一个水平组合，由实时窗口
@var{W2}和内部窗口@var{W3}组成。@var{W3}的子窗口形成一个垂直组合，由实时窗口
@var{W4}和@var{W5}组成。因此，这个窗口树中的活窗口是@var{W2}、@var{W4}和
@var{W5}。

以下函数可用于检索内部窗口的子窗口以及子窗口的兄弟姐妹。

@defun window-top-child &optional window
如果@var{window}是一个内部窗口，并且其子窗口形成了一个垂直组合，那么这个函数返回
@var{window}的最上面的子窗口。对于其他类型的窗口，返回值为@code{nil}。
@end defun

@defun window-left-child &optional window
如果 @var{window} 是一个内部窗口，其子窗口形成了一个水平组合，那么这个函数返回
@var{window}最左边的子窗口。对于其他类型的窗口，返回值为@code{nil}。
@end defun

@defun window-child window
此函数返回内部窗口@var{window}的第一个子窗口--垂直组合的最上面的子窗口，或者水平组
合的最左边的子窗口。如果@var{window}是一个实时窗口，则返回值为@code{nil}。
@end defun

@defun window-combined-p &optional window horizontal
如果且仅当@var{window}是垂直组合的一部分时，此函数返回一个非@code{nil}值。如果
@var{window}被省略或@code{nil}，则默认为所选的数值。

如果可选参数 @var{horizontal}是非@code{nil}，这意味着如果且仅当@var{window}
是水平组合的一部分时，才返回非@code{nil}。
@end defun

@defun window-next-sibling &optional window
此函数返回@var{window}窗口的下一个同级窗口。如果省略或@code{nil}，则
@var{window}默认为所选窗口。如果@var{window}是父窗口的最后一个子窗口，则返回值为
@code{nil}。
@end defun

@defun window-prev-sibling &optional window
此函数返回@var{window}窗口的前一个同级窗口。如果省略或@code{nil}，则
@var{window}默认为所选窗口。如果@var{window}是父窗口的第一个子窗口，则返回值为
@code{nil}。
@end defun

  函数@code{window-next-sibling}和@code{window-prev-sibling}不应与函数
@code{next-window}和@code{previous-window}混淆，后者分别返回窗口循环排序中的
下一个和上一个窗口(@pxref{Cyclic Window Ordering})。

  下面的函数可以用来定位窗口在其窗框内的位置。

@defun frame-first-window &optional frame-or-window
本函数返回位于@var{frame-or-window}指定的框架左上角的实时窗口。参数
@var{frame-or-window}必须表示一个窗口或一个实时窗框，默认为所选窗框。如果
@var{frame-or-window}指定了一个窗口，那么这个函数将返回该窗口窗框上的第一个窗口。
在假设我们的规范示例中的窗框被选中的情况下，@code{(frame-first-window)}返回
@var{W2}。
@end defun

@defun window-at-side-p &optional window side
如果@var{window}位于包含它的窗框的@var{side}处，此函数返回@code{t}。参数
@var{window}必须是一个有效的窗口，并且默认为选定的窗口。参数@var{side}可以是
@code{left}、@code{top}、@code{right}或@code{bottom}中的任何一个符号。默认
值@code{nil}的处理方式与@code{bottom}相同。

请注意，这个函数会忽略minibuffer窗口(@pxref{Minibuffer Windows})。因此，当
@var{side}等于@code{bottom}时，当minibuffer窗口出现在@var{window}的正下方时
，它也可能返回@code{t}。
@end defun

@cindex window in direction
@defun window-in-direction direction &optional window ignore sign wrap mini
此函数从@code{window-point}在@var{window}窗口中的位置，返回@var{direction}
方向上最近的实时窗口。参数@var{direction}必须是@code{above},@code{below},
@code{left}或@code{right}中的一个。参数@var{window}必须是一个实时窗口，默认为所选窗口。

本函数不返回@code{no-other-window}参数为非@code{nil}的窗口。(
@pxref{Window Parameters})。如果最近的窗口的@code{no-other-window}参数是非
@code{nil}，则此函数会尝试在指定方向上找到另一个@code{no-other-window}参数为
@code{nil}的窗口。如果可选参数@var{ignore}是非@code{nil}，那么即使
@code{no-other-window}参数是非@code{nil}，也可能返回一个窗口。

如果可选的参数@var{sign}是负数，则表示使用@var{window}的右侧或底部边缘作为参考位
置，而不是@code{window-point}。如果@var{sign}是正数，则表示使用@var{window}
的左边或顶部边缘作为参考位置。

如果可选的参数@var{wrap}是非@code{nil}，这意味着要将@var{direction}环绕在窗框
的边框上。例如，如果@var{window}在窗框的顶部，而@var{direction}是@code{above}
，那么这个函数通常会返回窗框的minibuffer窗口（如果它是活动的），否则返回窗框底部的
窗口。

如果可选参数@var{mini}为@code{nil}，这意味着返回当且仅当当前处于活动状态时的
minibuffer窗口。如果@var{mini}是非@code{nil}，那么即使minibuffer窗口不是活动
的，这个函数也会返回。但是，如果@var{wrap}是非@code{nil}，那么它的作用就如同
@var{mini}是@code{nil}一样。

如果没有找到合适的窗口，该函数返回@code{nil}。

不要用这个函数来检查@var{direction}中是否有@emph{no}窗口。调用上述的
@code{window-at-side-p}是一种更有效的方法。
@end defun

下面的功能可以检索一个框架的整个窗口树:

@defun window-tree &optional frame
此函数返回代表@var{frame}窗框的窗口树的列表，如果省略@var{frame}或@code{nil}，
则默认为选定的窗框。如果省略了@var{frame}或者@code{nil}，则默认为选中的窗框。

返回值是一个形式为@code{(@var{root} @var{mini})}的列表，其中@var{root}代表
窗框根窗口的窗口树，@var{mini}是窗框的minibuffer窗口。

如果根窗口是实时的，那么@var{root}就是那个窗口本身。否则，@var{root}是一个列表
@code{(@var{dir} @var{edges} @var{w1} @var{w2} ...)}，其中@var{dir}对于
水平组合来说是@code{nil}，对于垂直组合来说是@code{t}，@var{edges}给出了组合的大
和位置，其余元素是子窗口。每个子窗口也可以是一个窗口对象（对于实时窗口），或者是一个
与上述格式相同的列表（对于内部窗口）。@var{edges}元素是一个列表
@code{(@var{left} @var{top} @var{right} @var{bottom})}，类似于
@code{window-edges}所返回的值。(@pxref{Coordinates and Windows})。
@end defun


@node 窗口大小
@section Window Sizes
@cindex window size
@cindex size of window

  下面的示意图显示了一个实时窗口的结构:

@smallexample
@group
        ____________________________________________
       |______________ Header Line ______________|RD| ^
     ^ |LS|LM|LF|                       |RF|RM|RS|  | |
     | |  |  |  |                       |  |  |  |  | |
Window |  |  |  |       Text Area       |  |  |  |  | Window
Body | |  |  |  |     (Window Body)     |  |  |  |  | Total
Height |  |  |  |                       |  |  |  |  | Height
     | |  |  |  |<- Window Body Width ->|  |  |  |  | |
     v |__|__|__|_______________________|__|__|__|  | |
       |_________ Horizontal Scroll Bar _________|  | |
       |_______________ Mode Line _______________|__| |
       |_____________ Bottom Divider _______________| v
        <---------- Window Total Width ------------>

@end group
@end smallexample

@cindex window body
@cindex text area of a window
@cindex body of a window
  窗口的中心是@dfn{text area}，或者@dfn{body}，缓冲区的文本就显示在这里。文本区
域可以被一系列可选的区域包围。在左边和右边，从最内侧到最外侧，分别是左、右边缘，用LF和RF表示（@pxref{边缘}）；左、右边缘，在原理图中用LM和RM表示（@pxref{显示边距}）
。左或右垂直滚动条，任何时候只能有一个，用LS和RS表示(@pxref{滚动条})；以及右分隔符
，用RD表示(@pxref{窗口分隔符})。窗口顶部是标题行(@pxref{Header Lines})。窗口底
部是水平滚动条(@pxref{滚动条})；模式线(@pxref{模式行格式})；以及底部分隔线(
@pxref{窗口分隔线})。

Emacs提供了各种函数用于查找窗口的高度和宽度。这些函数中的许多函数的返回值可以以像素
为单位或以行和列为单位来指定。在图形显示上，后者实际上对应于由
@code{frame-char-height}和@code{frame-char-width}返回的由窗框默认字体指定的
默认字符的高度和宽度。(@pxref{Frame Font})。因此，如果一个窗口正在显示不同字体或
大小的文本，则该窗口报告的行高和列宽可能与该窗口内显示的实际文本行数或列数不同。

@cindex window height
@cindex height of a window
@cindex total height of a window
  窗口的@dfn{total height}是指窗口的主体、标题线、水平滚动条、模式线和底部分隔线
（如果有的话）组成的线数。

@defun window-total-height &optional window round
此函数返回@var{window}窗口的总高度，以行为单位。如果省略了@var{window}或者
@code{nil}，则默认为选中的窗口。如果@var{window}是一个内部窗口，则返回值是其子窗
口所占的总高度。

如果一个窗口的像素高度不是其窗框默认字符高度的整数倍，则该窗口所占用的行数将被内部舍
入。这样做的方式是，如果该窗口是一个父窗口，则其所有子窗口的内部总高度之和等于其父窗
口的总高度。这意味着，虽然两个窗口的像素高度相同，但它们的内部总高度可能相差一行。这
也意味着，如果窗口是垂直组合的，并且有下一个兄弟姐妹，那么该兄弟姐妹的最上面一行可以
计算为这个窗口的最上面一行和总高度之和(@pxref{坐标和窗口})

如果可选参数@var{round}是@code{ceiling}，则该函数返回比@var{window}的像素高度
除以其框架字符高度的最小整数；如果是@code{floor}，则返回比上述值小的最大整数；如果
是其他@var{round}，则返回@var{windows}的总高度的内部值。
@end defun

@cindex window width
@cindex width of a window
@cindex total width of a window
  窗口的@dfn{total width}是指窗口的主体、边框、边缘、滚动条和右侧分隔线（如果有的
话）组成的行数。

@defun window-total-width &optional window round
此函数返回@var{window}窗口的总宽度，以列为单位。如果省略了@var{window}或者
@code{nil}，则默认为所选窗口的宽度。如果@var{window}是内部窗口，则返回值是其子窗
口的总宽度。

如果一个窗口的像素宽度不是其窗框字符宽度的整数倍，则该窗口所占用的行数将在内部进行四
舍五入。这样做的方式是，如果该窗口是一个父窗口，其所有子窗口的内部总宽度之和等于其父
窗口的总宽度。这意味着虽然两个窗口的像素宽度相同，但其内部总宽度可能相差一列。这也意
味着，如果这个窗口是水平组合的，并且有下一个兄弟姐妹，那么这个兄弟姐妹最左边的一列可
以计算为这个窗口最左边的一列和总宽度之和（@pxref{坐标和窗口}）。可选参数
@var{round}的行为与@code{window-total-height}相同。
@end defun

@defun window-total-size &optional window horizontal round
此函数返回窗口@var{window}的总高度（以行为单位）或总宽度（以列为单位）。如果省略了
@var{horizontal}或@code{nil}，则相当于给@var{window}
调用@code{window-total-height}；否则相当于给@var{window}调用
@code{window-total-width}。可选参数@var{round}的作用与它在
@code{window-total-height}里的作用相同。
@end defun

以下两个函数可以用来返回窗口的总大小，单位是像素。

@cindex window pixel height
@cindex pixel height of a window
@cindex total pixel height of a window

@defun window-pixel-height &optional window
此函数返回窗口@var{window}的总高度，单位为像素。@var{window}必须是一个有效的窗口
，并且默认为选中的窗口。

返回值包括模式和标题行、水平滚动条和底部分隔线（如果有）。如果@var{window}是一个内
部窗口，那么它的像素高度就是它的子窗口所覆盖的屏幕区域的像素高度。
@end defun

@cindex window pixel width
@cindex pixel width of a window
@cindex total pixel width of a window

@defun window-pixel-width &optional window
此函数返回窗口@var{window}的宽度，单位为像素。@var{window}必须是一个有效的窗口，
默认为所选窗口。

返回值包括@var{window}的边缘和边框，以及属于@var{window}的任何垂直分隔线或滚动条
。如果@var{window}是一个内部窗口，那么它的像素宽度就是它的子窗口所覆盖的屏幕区域的
宽度。
@end defun

@cindex full-width window
@cindex full-height window
  以下函数可用于确定某个窗口是否有任何相邻的窗口。

@defun window-full-height-p &optional window
如果@var{window}的窗框中没有其他窗口在其上方或下方，则该函数返回非@code{nil}。更
准确的说，这意味着@var{window}的总高度等于该框架中根窗口的总高度。minibuffer窗口
在这方面不计入。如果省略了@var{window}或@code{nil}，则默认为选定的窗口。
@end defun

@defun window-full-width-p &optional window。
如果@var{window}在其框架中左边或右边没有其他窗口，即其总宽度等于该框架中根窗口的宽
度，则该函数返回非@code{nil}。如果省略了@var{window}或@code{nil}，则默认为选中
的窗口。
@end defun

@cindex window body height
@cindex body height of a window
窗口的@dfn{body height}是指其文本区域的高度，它不包括模式或标题行、水平滚动条或底
部分隔线。

@defun window-body-height &optional window pixelwise
此函数返回@var{window}窗口主体的高度，以行为单位。如果省略了@var{window}或者
@code{nil}，则默认为选定的窗口，否则必须是实时窗口。

如果可选参数@var{pixelwise}是非@code{nil}，则该函数返回以像素为单位的
@var{window}的主体高度。

如果@var{pixelwise}是@code{nil}，必要时，返回值会被四舍五入到最接近的整数。这意
味着，如果文本区域底部的某一行只是部分可见，则该行不会被计算在内。这也意味着窗口主体
的高度永远不能超过 @code{window-total-height} 返回的总高度。
@end defun

@cindex window body width
@cindex body width of a window
窗口的@dfn{body width}是指文本区域的宽度，不包括滚动条、边框、边距或右侧分隔线。
请注意，当去掉一个或两个边框时（将其宽度设置为零），显示引擎会保留两个字符单元，在
窗口的两侧各保留一个，用于显示延续和截断字样，这样就少了两列用于显示文本。(下面介绍
的函数@code{window-max-chars-per-line}就考虑到了这个特点。)

@defun window-body-width &optional window pixelwise
此函数返回@var{window}窗口主体的宽度，以列为单位。如果省略了@var{window}或者
@code{nil}，则默认为选定的窗口，否则必须是实时窗口。

如果可选参数@var{pixelwise}是非@code{nil}，则该函数以像素为单位返回
@var{window}的主体宽度。

如果@var{pixelwise}是@code{nil}，如果需要，返回值会被四舍五入到最接近的整数。这
意味着，如果文本区域右侧的一列仅部分可见，则该列不被计算在内。这也意味着窗口主体的宽
度永远不能超过 @code{window-total-width} 返回的总宽度。
@end defun

@cindex window body size
@cindex body size of a window
@defun window-body-size &optional window horizontal pixelwise
此函数返回@var{window}的主体高度或主体宽度。如果省略了@var{horizontal}或
@code{nil}，则相当于调用@code{window-body-height}来处理@var{window}；否则相
当于调用@code{window-body-width}。无论哪种情况，都会将可选的参数
@var{pixelwise} 传递给被调用的函数。
@end defun

为了与以前版本的Emacs兼容，@code{window-height}是@code{window-total-height}
的别名，@code{window-width}是@code{window-body-width}的别名。这些别名被认为
是过时的，将来会被删除。

窗口的模式和标题行的像素高度可以通过下面给出的函数来检索。它们的返回值通常是准确的，
除非该窗口以前没有显示过。在这种情况下，返回值是基于对窗口窗框所用字体的估计。

@defun window-mode-line-height &optional window
此函数返回@var{window}模式线的高度，单位为像素。@var{window}必须是一个实时窗口，
并且默认为选定的窗口。如果@var{window}没有模式线，则返回值为0。
@end defun

@defun window-header-line-height &optional window
此函数返回@var{window}标题行的高度，单位为像素。@var{window}必须是一个实时窗口，
并且默认为选定的窗口。如果@var{window}没有标题行，则返回值为0。
@end defun

用于检索窗口分隔线(@pxref{窗口分隔线})、边缘(@pxref{边缘})、滚动条(
@pxref{滚动条})和显示边距(@pxref{显示边距})的高度和/或宽度的函数在相应的章节中描
述。

如果你的Lisp程序需要进行布局决策，你会发现以下功能很有用:

@defun window-max-chars-per-line &optional window face
此函数返回在指定窗口中，在指定字形@var{face}中显示的字符数@var{window}。(它必须
是一个实时窗口)。如果@var{face}被重映射了(@pxref{字形重映射})，则返回重映射后的
字形的信息。如果省略或@code{nil}，@var{face}默认为默认的字形，@var{window}默认
为选定的窗口。

与@code{window-body-width}不同的是，这个函数考虑了@var{face}字体的实际大小，而
不是以@var{window}窗框的规范字符宽度(@pxref{Frame Font})为单位。如果
@var{window}缺少一个或两个边框，它也会考虑到延续字形所使用的空间。
@end defun

@cindex fixed-size window
@vindex window-min-height
@vindex window-min-width
  改变窗口大小（@pxref{调整窗口大小}）或分割窗口（@pxref{分割窗口}）的命令，都要
服从变量@code{window-min-height}和@code{window-min-width}，这两个变量指定了
允许的最小窗口高度和宽度。它们还服从变量@code{window-size-fixed}，用它可以使窗口
的大小@dfn{fixed} (@pxref{保留窗口大小})。

@defopt window-min-height
这个选项指定了任何窗口的最小总高度，以行为单位，它的值必须至少能容纳一个文本行、模式
和标题行、水平滚动条和底部分隔线（如果有）。
@end defopt

@defopt window-min-width
这个选项指定任何窗口的最小总宽度，以列为单位。它的值必须能容纳两列文本，以及边框、边
框、滚动条和右侧分隔线（如果有）。
@end defopt

下面的函数告诉我们，考虑到特定窗口的区域大小以及@code{window-min-height}、
@code{window-min-width}和@code{window-size-fixed}的值，该窗口可以变得多小。
(@pxref{保留窗口大小})。

@defun window-min-size &optional window horizontal ignore pixelwise
此函数返回@var{window}的最小尺寸。@var{window}必须是一个有效的窗口，默认为所选窗
口。参数@var{horizontal}是non-@code{nil}表示返回@var{window}的最小列数，否则
返回@var{window}的最小行数。

返回值确保@var{window}的所有组件保持完全可见，如果@var{window}的大小确实被设置为
它的话。对于@var{horizontal}是@code{nil}，它包括模式和标题行、水平滚动条和底部
分隔线（如果存在的话）。如果@var{horizontal}非@code{nil}，则包括边框和边缘、垂
直滚动条和右侧分隔线（如果存在）。

可选参数@var{ignore}，如果是非@code{nil}，则表示忽略固定大小的窗口、
@code{window-min-height}或@code{window-min-width}设置所带来的限制。如果
@var{ignore}等于@code{safe}，那么实时窗口可能会变得和
@code{window-safe-min-height}行和@code{window-safe-min-width}列一样小。如
果@var{ignore}是一个窗口，则只忽略该窗口的限制。其他任何非@code{nil}的值都意味着
忽略所有窗口的上述限制。

可选参数@var{pixelwise}非@code{nil}表示返回@var{window}的最小尺寸，单位为像素
。
@end defun


@node 调整窗口大小
@section Resizing Windows
@cindex window resizing
@cindex resize window
@cindex changing window size
@cindex window size, changing

  本节介绍了在不改变窗框大小的情况下调整窗口大小的功能。因为实时窗口不会重叠，所以这
些函数只对包含两个或更多窗口的窗框有意义：调整一个窗口的大小也会改变相邻窗口的大小。
如果一个窗框上只有一个窗口，那么除非调整窗框的大小，否则不能改变其大小（
@pxref{窗框大小}）。

  除非另有说明，这些函数也接受内部窗口作为参数。调整内部窗口的大小会导致其子窗口的大
小被调整以适应相同的空间。

@defun window-resizable window delta &optional horizontal ignore pixelwise
如果@var{delta}行可以垂直改变@var{window}的大小，则该函数返回@var{delta}。如果
可选的参数@var{horizontal}是非@code{nil}，那么如果@var{window}可以通过
@var{delta}列水平调整大小，它将返回@var{delta}。它实际上并没有改变窗口的大小，而
是返回@var{delta}。

如果@var{window}是@code{nil}，则默认为选定的窗口。

如果@var{delta}为正值，表示检查窗口是否可以放大该行或列的数量；如果@var{delta}为
负值，表示检查窗口是否可以缩小该行或列的数量。如果@var{delta}为非零，则返回值为0，
表示不能调整窗口大小。

通常情况下，变量 @code{window-min-height} 和 @code{window-min-width} 指定了允许的最小窗口尺寸(@pxref{窗口尺寸})。但是，如果可选参数@var{ignore}是非
@code{nil}，则该函数将忽略@code{window-min-height}和
@code{window-min-width}以及@code{window-size-fixed}。相反，它认为最小高度的
窗口是由页眉和模式线、水平滚动条和底部分隔线（如果有的话）以及一行高的文本区域组成；
最小宽度的窗口是由边缘、边框、滚动条和右侧分隔线（如果有的话）以及两列宽的文本区域组
成。

如果可选参数@var{pixelwise}是非@code{nil}，则@var{delta}解释为像素。
@end defun

@defun window-resize window delta &optional horizontal ignore pixelwise
此函数以@var{delta}为单位调整@var{window}的大小。如果@var{horizontal}是
@code{nil}，则按@var{delta}行改变高度；否则，按@var{delta}列改变宽度。正的
@var{delta}表示放大窗口，负的@var{delta}表示缩小窗口。

如果@var{window}是@code{nil}，则默认为选定的窗口。如果窗口不能按要求调整大小，则
会发出错误信号。

可选参数@var{ignore}与上面函数@code{window-resizable}的含义相同。

如果可选参数@var{pixelwise}是非@code{nil}，则@var{delta}将被解释为像素。

该函数改变哪些窗口边缘的选择取决于@code{window-combination-size}选项的值和涉及
的窗口的组合限制；在某些情况下，它可能会改变两个边缘。@xref{重新组合窗口}。如果只移
动窗口的底部或右侧边缘来调整大小，请使用函数@code{adjust-window-trailing-edge}
。
@end defun

@c 放大-窗口、放大-窗口-水平方向的命令shrink-window和
@c shrink-window-horizontally在Emacs手册。它们不适合从Lisp调用。

@defun adjust-window-trailing-edge window delta &optional horizontal pixelwise
此函数将@var{window}的底边移动@var{delta}行。如果可选参数@var{horizontal}是非
@code{nil}，则该函数会将右边缘移动@var{delta}列。如果@var{window}是非
@code{nil}，则默认为选中的窗口。

如果可选参数@var{pixelwise}是非@code{nil}，则@var{delta}解释为像素。

正值@var{delta}表示将边缘向下或向右移动；负值@var{delta}表示将边缘向上或向左移动
。如果边不能按照@var{delta}的指定移动，这个函数会尽可能地移动它，但不会发出错误信
号。

这个函数试图调整与被移动的边缘相邻的窗口的大小。如果由于某些原因无法做到这一点（例如
，如果相邻的窗口是固定大小的），它可能会调整其他窗口的大小。
@end defun

@cindex pixelwise, resizing windows
@defopt window-resize-pixelwise
如果这个选项的值是非@code{nil}，Emacs会以像素为单位调整窗口的大小。这目前影响到
@code{split-window}等函数。(@pxref{分割窗口})、@code{maximize-window}、
@code{minimize-window}、@code{fit-window-to-buffer}、
@code{fit-fram-to-buffer}和@code{shrink-window-if-larger-than-buffer}
以下全部列出)。

请注意，当一个框架的像素大小不是字符大小的倍数时，即使这个选项是@code{nil}，至少有
一个窗口可能会被调整像素大小。默认值是@code{nil}。
@end defopt

  以下命令以更具体的方式调整窗口大小。当交互式调用时，它们会对所选窗口产生作用。

@deffn Command fit-window-to-buffer &optional window max-height min-height max-width min-width preserve-size
这条命令可以调整@var{window}的高度或宽度，以适应其中的文字。如果能够调整
@var{window}的大小，则返回非@code{nil}，否则返回@code{nil}。如果省略了
@var{window}或@code{nil}，则默认为选定的窗口。否则，它应该是一个实时窗口。

如果@var{window}是垂直组合的一部分，这个函数会调整@var{window}的高度。新的高度是
根据缓冲区中可访问部分的实际高度计算出来的。可选参数@var{max-height}，如果是非
@code{nil}，则指定此函数可以给@var{window}的最大总高度。可选参数
@var{min-height}，如果是非@code{nil}，则指定该函数所能给出的最小总高度，它覆盖
了变量@code{window-min-height}。@var{max-height}和@var{min-height}都是以
行为单位来指定的，并且包括模式、标题行和底部分隔线（如果有的话）。

如果@var{window}是水平组合的一部分，并且
@code{fit-window-to-buffer-horizontally}(见下文)选项的值是非@code{nil}，那
么这个函数将调整@var{window}的宽度。新的@var{window}宽度是根据@var{window}当
前起始位置后的缓冲区行的最大长度计算的。可选参数@var{max-width}指定了一个最大的宽
度，默认为@var{window}的窗框宽度。可选参数@var{min-width}指定了最小宽度，默认值
为@code{window-min-width}。@var{max-width}和@var{min-width}都是以列为单位
指定的，并且包括边缘、边框和滚动条（如果有）。

可选参数@var{preserve-size}，如果非@code{nil}，则将安装一个参数，以便在未来的调
整大小操作中保留@var{window}的大小（@pxref{保留窗口大小}）。

如果选项@code{fit-frame-to-buffer}。(见下文)是非@code{nil}，这个函数将通过调
用@code{fit-frame-to-buffer}来调整@var{window}的窗框大小以适应其内容。(见下文
)。
@end deffn

@defopt fit-window-to-buffer-horizontally
如果这个值是非@code{nil}，那么@code{fit-window-to-buffer}可以水平调整窗口大小
。如果这个值是@code{nil}(默认值)，那么@code{fit-window-to-buffer}可以水平调整
窗口的大小。@code{fit-window-to-buffer}从来不会水平调整窗口大小，如果是
@code{only}，则只能水平调整窗口大小。如果这个值是@code{only}，那么它只能水平调整
窗口大小。其他任何值都意味着@code{fit-window-to-buffer}可以在两个维度上调整窗口
的大小。
@end defopt

@defopt fit-frame-to-buffer
如果这个选项是非@code{nil}，@code{fit-window-to-buffer}可以将一个窗框贴合到它
的缓冲区。如果且仅当它的根窗口是一个实时窗口，并且这个选项是非@code{nil}时，窗框才
会被拟合。如果这个选项是@code{horizontally}，那么窗框只能被水平地贴合。如果这个选
项是@code{vertical}，则窗框只在垂直方向适合。任何其他非@code{nil}的值都意味着窗
框可以在两个维度上调整大小。
@end defopt

如果您有一个只显示一个窗口的窗框，您可以使用@code{fit-frame-to-buffer}命令将该窗
框装入其缓冲区。

@deffn Command fit-frame-to-buffer &optional frame max-height min-height max-width min-width only
此命令调整@var{frame}的大小，以准确显示其缓冲区的内容。@var{frame}可以是任何一个
实时窗框，默认为选定的窗框。只有当@var{frame}的根窗口是实时的，才会进行调整。参数
@var{max-height},@var{min-height},@var{max-width}和@var{min-width}指定了
@var{frame}的根窗口的新总尺寸的界限。@var{min-height}和@var{min-width}分别默
认为@code{window-min-height}和@code{window-min-width}的值。

如果可选参数@var{only}是@code{vertical}，则该函数只能垂直调整窗框的大小。如果
@var{only}的参数是@code{horizontally}，那么这个函数只能水平调整画面的大小。
@end deffn

可以通过下面列出的两个选项来控制@code{fit-frame-to-buffer}的行为。

@defopt fit-frame-to-buffer-margins
这个选项可以用来指定@code{fit-frame-to-buffer}所要适应的框架的边距。这样的边距
对于避免调整后的窗框与任务栏或其父窗框的部分重叠是很有用的。
它指定了一个窗框的左边、上面、右边和下面的空闲像素数，这些像素数应该是适合的。默认情
况下，@code{nil}的意思是不使用边距。此处指定的值可以被特定帧的
@code{fit-fram-to-buffer-margins}参数（如果存在的话）覆盖。
@end defopt

@defopt fit-frame-to-buffer-sizes
这个选项指定了@code{fit-frame-to-buffer}的大小边界。它指定了任何窗框的根窗口的
最大和最小行数以及最大和最小列数。如果这些值中的任何一个是非@code{nil}，它将覆盖
@code{fit-frame-to-buffer}的相应参数。
@end defopt

@deffn Command shrink-window-if-larger-than-buffer &optional window
这条命令试图尽可能地减小@var{window}的高度，同时仍然显示完整的缓冲区，但不能少于
@code{window-min-height}行。如果窗口被调整了大小，返回值是非@code{nil}，否则为
@code{nil}。如果省略了@var{window}或者@code{nil}，则默认为选定的窗口。否则，它
应该是一个实时窗口。

如果窗口已经太短，无法显示所有的缓冲区，或者任何缓冲区被滚动到屏幕外，或者窗口是其窗
框中唯一的实时窗口，则该命令不做任何操作。

该命令调用@code{fit-window-to-buffer}。(见上文)来开展工作。
@end deffn


@cindex balancing window sizes
@deffn Command balance-windows &optional window-or-frame
这个函数以一种给全宽和/或全高的窗口提供更多空间的方式来平衡窗口。如果
@var{window-or-frame}指定了一个窗框，则平衡该窗框架的所有窗口。如果
@var{window-or-frame}指定了一个窗口，则只平衡该窗口及其同级窗口
(@pxref{窗口和窗框})。
@end deffn

@deffn Command balance-windows-area
此功能试图给所选窗框上的所有窗口提供大致相同的屏幕区域份额。全宽或全高的窗口不会比其
他窗口获得更多的空间。
@end deffn

@cindex maximizing windows
@deffn Command maximize-window &optional window
这个函数试图使@var{window}在两个维度上都尽可能的大，而不需要调整其窗框大小或删除其
他窗口。如果省略了@var{window}或者@code{nil}，则默认为选中的窗口。
@end deffn

@cindex minimizing windows
@deffn Command minimize-window &optional window
这个函数试图使@var{window}在两个维度上都尽可能的小，而不需要删除它或调整它的窗框大
小。如果省略了@var{window}或@code{nil}，则默认为选定的窗口。
@end deffn


@node 保留窗口大小
@section Preserving Window Sizes
@cindex preserving window sizes

窗口可以通过使用上一节中的一个函数显式地调整大小，也可以隐式地调整大小，例如，当调整
相邻窗口的大小时，当分割或删除窗口时（@pxref{分割窗口},@pxref{删除窗口}）或当调整
窗口的窗框大小时（@pxref{窗框大小}）。

当同一窗框上有一个或多个其他可调整大小的窗口时，可以避免隐式地调整特定窗口的大小，为
此，Emacs必须建议@dfn{preserve}该窗口的大小。有两种基本方法可以做到这一点。

@defvar window-size-fixed
如果这个缓冲区本地变量是非@code{nil}，通常不能改变任何显示缓冲区的窗口的大小。如果
没有选择，删除窗口或改变窗框的大小，仍然会改变窗口的大小。

如果值是@code{height}，则只固定窗口的高度；如果值是@code{width}，则只固定窗口的
宽度。其他任何非@code{nil}的值都会固定宽度和高度。

如果这个变量是@code{nil}，这并不意味着任何显示缓冲区的窗口都可以按照所需的方向调整
大小。要确定这一点，请使用函数@code{window-resizable}。@xref{调整窗口大小}。
@end defvar

通常情况下，@code{window-size-fixed}是过于激进的，因为它抑制了任何试图显式调整或
分割受影响窗口的行为。这种情况甚至可能发生在窗口被隐式调整大小之后，例如，在删除相邻窗口或调整窗口窗框大小的时候。下面的函数努力尝试不允许显式地调整这种窗口的大小:

@defun window-preserve-size &optional window horizontal preserve
此函数将窗口@var{window}的高度(取消)标记为保留，以便将来进行调整大小的操作。
@var{window}必须是一个实时窗口，并且默认为选定的窗口。如果参数@var{horizontal}
是非@code{nil}，则将@var{window}的宽度(取消)标记为保留。

如果可选的参数@var{preserve}是@code{t}，这意味着要保留@var{window}的主体的当前
高度/宽度。只有当Emacs没有更好的选择时，@var{window}的高度/宽度才会改变。调整一个
窗口的高度/宽度，如果这个函数保留了这个窗口的高度/宽度，则不会产生错误。

如果@var{preserve}是@code{nil}，这意味着停止保留@var{window}的高度/宽度，解除
之前调用此函数对@var{window}引起的限制。以@var{window}为参数调用
@code{enlarge-window}, @code{shrink-window}或
@code{fit-window-to-buffer}也可能会取消各自的限制。
@end defun

目前@code{window-preserve-size}被以下函数调用:

@table @code
@item fit-window-to-buffer
如果该函数(@pxref{调整窗口大小})的可选参数@var{preserve-size}是非@code{nil}，
则保留该函数建立的大小。

@item display-buffer
如果该函数(@pxref{选择窗口})的@var{alist}参数包含一个@code{preserve-size}条目，
则该函数产生的窗口大小将被保留。
@end table

  @code{window-preserved-size}安装了一个名为@code{window-preserved-size}
的窗口参数(@pxref{窗口参数})，该参数被窗口大小调整函数所参考。当窗口显示的缓冲区比
调用@code{window-preserve-size}时的缓冲区要大，或者它的大小在那之后发生了变化，
这个参数不会阻止调整窗口的大小。

下面的函数可以用来检查特定窗口的高度是否被保留:

@defun window-preserved-size &optional window horizontal
此函数返回窗口@var{window}的保留高度，单位为像素。@var{window}必须是一个实时窗口
，并且默认为选定的窗口。如果可选参数@var{horizontal}是非@code{nil}，则返回
@var{window}的保留宽度。如果@var{window}的大小没有保留，则返回@code{nil}。
@end defun


@node 分割窗口
@section Splitting Windows
@cindex splitting windows
@cindex window splitting

这个部分说明通过@dfn{splitting}一个现有的窗口创建新窗口的函数。 请注意，有些
窗口在特殊的意义上，这些函数可能无法像这里描述的那样将它们分割开来。这类窗口的
例子是侧边窗口（@pxref{侧边窗口}）和原子窗口（@pxref{原子窗口}）。

@defun split-window &optional window size side pixelwise
此函数在@var{window}窗口旁边创建一个新的实时窗口。如果省略了@var{window}或
@code{nil}，则默认为选定的窗口。该窗口被分割，并缩小了大小。新的窗口会占用空
间，而新的窗口会被返回。

可选的第二个参数@var{size}决定@var{window}和/或新窗口的大小。如果省略或
@code{nil}，则两个窗口的大小相等；如果有多出来的行，则分配给新窗口。如果
@var{size}是一个正数，则@var{window}被赋予@var{size}行（或列，取决于@var{side}
的值）。如果@var{size}是负数，那么新窗口将被分配给@minus{}@var{size}行（或列）。

如果@var{size}为@code{nil}，则该函数服从变量@code{window-min-height}和
@code{window-min-width}(@pxref{窗口大小})。因此，如果拆分会导致窗口小于这些变
量所指定的大小，它就会发出错误信号。然而，@var{size}的非@code{nil}值会导致这些
变量被忽略；在这种情况下，允许的最小窗口被认为是有一行高和/或两列宽的文本区域的
空间。

因此，如果指定了@var{size}，调用者有责任检查发出的窗口是否足够大，以涵盖所有区
域，如模式行或滚动条。函数@code{window-min-size}(@pxref{窗口大小})可以用来确
定@var{window}在这方面的最小要求。由于新窗口通常会继承@var{window}的模式行或
滚动条等区域，因此该函数也可以很好地猜测新窗口的最小尺寸。只有当调用者在下一次
重新显示之前相应地删除了一个继承的区域时，才应该指定一个较小的尺寸。

可选的第三个参数@var{side}决定了新窗口相对于@var{window}的位置，如果是
@code{nil}或@code{below}，则新窗口放在@var{window}的下方。如果是@code{above}
，则新窗口被放置在@var{window}的上方。在这两种情况下，@var{size}都指定了窗口
的总高度，以行为单位。

如果@var{side}是@code{t}或@code{right}，则新窗口被放置在@var{window}的右边。
如果@var{side}是 @code{left}，则新窗口被放置在@var{window}的左边。在这两种情
况下，@var{size}都指定了窗口的总宽度，以列为单位。

可选的第四个参数@var{pixelwise}，如果不是@code{nil}，则表示以像素为单位解释
@var{size}，而不是以行和列为单位。

如果@var{window}是一个实时窗口，那么新窗口将继承它的各种属性，包括边距和滚动
条。如果@var{window}是一个内部窗口，那么新的窗口会继承@var{window}窗框内所选
窗口的属性。

只要@code{ignore-window-parameters}变量为@code{nil}，本函数的行为就可以
被@var{window}的窗口参数所改变。如果@code{split-window}窗口参数的值是
@code{t}，那么这个函数将忽略所有其他窗口参数。否则，如果@code{split-window}
窗口参数的值是一个函数，则调用该函数的参数@var{window}, @var{size}, 和
@var{side}，以代替@code{split-window}的通常操作。否则，这个函数将服从
@code{window-atom}或@code{window-side}窗口参数（如果有的话）。
@xref{窗口参数}。
@end defun

  作为一个例子，这里是一个@code{split-window}调用的序列，它产生了在
@ref{Windows and Frames}中讨论的窗口配置。这个例子演示了分割一个实时窗口以
及分割一个内部窗口。我们从一个包含单个窗口（一个实时根窗口）的窗框开始，我们
用@var{W4}来表示它。调用@code{(split-window W4)}就会产生这个窗口配置：

@smallexample
@group
     ______________________________________
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||_________________W4_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||_________________W5_________________||
    |__________________W3__________________|

@end group
@end smallexample

@noindent
调用@code{split-window}创建了一个新的实时窗口，由@var{W5}表示。它还创建了
一个新的内部窗口，由@var{W3}表示，它成为根窗口，也是@var{W4}和@var{W5}的
父窗口。

  接下来，我们调用@code{(split-window W3 nil 'left)}，将内部窗口@var{W3}
作为参数。结果是：

@smallexample
@group
     ______________________________________
    | ______  ____________________________ |
    ||      || __________________________ ||
    ||      |||                          |||
    ||      |||                          |||
    ||      |||                          |||
    ||      |||____________W4____________|||
    ||      || __________________________ ||
    ||      |||                          |||
    ||      |||                          |||
    ||      |||____________W5____________|||
    ||__W2__||_____________W3_____________ |
    |__________________W1__________________|
@end group
@end smallexample

@noindent
在内部窗口@var{W3}的左侧，创建了一个新的实时窗口@var{W2}。创建一个新的内
部窗口@var{W1}，成为新的根窗口。

  对于交互式使用，Emacs提供了两个命令，它们总是分割所选窗口。这些命令在内
部调用@code{split-window}。

@deffn Command split-window-right &optional size
这个函数将选中的窗口分成两个并排的窗口，将选中的窗口放在左边。如果
@var{size}为正值，则左边的窗口得到@var{size}列；如果@var{size}为负值，
则右边的窗口得到@minus{}@var{size}列。
@end deffn

@deffn Command split-window-below &optional size
这个函数将选中的窗口分成两个窗口，一个在另一个上面，留下上面的窗口。如
果@var{size}为正值，则上层窗口得到@var{size}行；如果@var{size}为负值，
则下层窗口得到@minus{}@var{size}行。
@end deffn

@defopt split-window-keep-point
如果这个变量的值是非@code{nil}(默认)，@code{split-window-below}的行为
与上述相同。

如果是 @code{nil}，@code{split-window-below} 将调整两个窗口中的每一个
点，以最小化重新显示。(这在速度较慢的终端上很有用。)它选择哪个窗口包含该
点之前所在的屏幕线。请注意，这只影响@code{split-window-below}，而不是
低级的 @code{split-window} 函数。
@end defopt


@node 删除窗口
@section Deleting Windows
@cindex deleting windows

  @dfn{Deleting}窗口会从窗框的窗口树中移除它。如果该窗口是一个实时窗口，那
么它将从屏幕上消失。如果该窗口是内部窗口，那么它的子窗口也会被删除。

  即使在一个窗口被删除之后，它仍然作为一个Lisp对象继续存在，直到没有更多的
引用。窗口的删除可以通过恢复已保存的窗口配置（@pxref{窗口配置}）来逆转。

@deffn Command delete-window &optional window
此函数从显示窗口中删除@var{window}并返回@code{nil}。如果省略了@var{window}
或者@code{nil}，则默认为选中的窗口。

如果删除该窗口会使窗口树中没有更多的窗口（例如，如果它是窗框中唯一的活窗口）
，或者@var{window}的窗框上所有剩余的窗口都是侧窗口 (@pxref{Side Windows})，
则会发出一个错误信号。如果@var{window}是一个原子窗口的一部分 (
@pxref{原子窗口})，这个函数会尝试删除该原子窗口的根。

默认情况下，@var{window}所占用的空间会被分配给相邻的一个同级窗口（如果有的
话）。然而，如果变量@code{window-combination-size}是非@code{nil}，则空间
会按比例分配给同一窗口组合中的任何剩余窗口。@xref{重新组合窗口}。

只要@code{ignore-window-parameters}变量为@code{nil}，本函数的行为就可以
被@var{window}的窗口参数所改变。如果@code{delete-window}窗口参数的值是
@code{t}，那么这个函数将忽略所有其他窗口参数。否则，如果
@code{delete-window}窗口参数的值是一个函数，那么该函数将被调用，参数为
@var{window}，以代替@code{delete-window}的通常操作。@xref{窗口参数}。
@end deffn

@deffn Command delete-other-windows &optional window
此函数使@var{window}填充其窗框，必要时删除其他窗口。如果省略了
@var{window}或 @code{nil}，则默认为选定的窗口。如果@var{window}是一个侧边
窗口，则会发出错误信号(@pxref{侧边窗口})。如果@var{window}是一个原子窗口(
@pxref{原子窗口})的一部分，这个函数会尝试让该原子窗口的根填充其窗框。返回值
是@code{nil}。

只要@code{ignore-window-parameters}变量为@code{nil}，本函数的行为就可以被
@var{window}的窗口参数所改变。如果@code{delete-other-windows}窗口参数的值
是@code{t}，那么这个函数将忽略所有其他窗口参数。否则，如果
@code{delete-other-windows}窗口参数的值是一个函数，那么该函数将被调用，参
数为@var{window}，以代替@code{delete-other-windows}的通常操作。
@xref{窗口参数}。

另外，如果@code{ignore-window-parameters}为@code{nil}，则该函数不会删除任
何@code{no-delete-other-windows}参数为非@code{nil}的窗口。
@end deffn

@deffn Command delete-windows-on &optional buffer-or-name frame
这个函数通过调用@code{delete-window}来删除所有显示@var{buffer-or-name}的窗
口。@var{buffer-or-name}应该是一个缓冲区，或者一个缓冲区的名称；如果省略或
者@code{nil}，则默认为当前的缓冲区。如果没有显示指定缓冲区的窗口，则该函数不
做任何操作。如果指定的缓冲区是迷你缓冲区，则会发出错误信号。

如果有一个专门的窗口显示缓冲区，而该窗口是其窗框上唯一的一个窗口，如果该窗口
不是终端上唯一的窗框，那么这个函数也会删除该窗框。

可选参数@var{frame}指定要操作的窗框：

@itemize @bullet
@item @code{nil}
是指在所有窗框上操作。
@item @code{t}
意味着在选定的窗框上操作。
@item @code{visible}
是指在所有可见的窗框上操作。
@item @code{0}
是指对所有可见的或图标化的窗框进行操作。
@item A frame
是指在该窗框上操作。
@end itemize

请注意，这个参数与其他扫描所有实时窗口的函数（@pxref{循环窗口排序}）中的含
义不同。具体来说，这里@code{t}和@code{nil}的含义与其他函数中的含义相反。
@end deffn


@node 重新组合窗口
@section Recombining Windows
@cindex recombining windows
@cindex windows, recombining

当删除一个窗口的最后一个兄弟姐妹@var{W}时，它的父窗口也会被删除，而@var{W}
会在窗口树中取而代之。这意味着@var{W}必须与其父级的兄弟姐妹重新组合，以形成
一个新的窗口组合 (@pxref{窗口和窗框})。在某些情况下，删除一个实时窗口甚至可
能需要删除两个内部窗口。

@smallexample
@group
     ______________________________________
    | ______  ____________________________ |
    ||      || __________________________ ||
    ||      ||| ___________  ___________ |||
    ||      ||||           ||           ||||
    ||      ||||____W6_____||_____W7____||||
    ||      |||____________W4____________|||
    ||      || __________________________ ||
    ||      |||                          |||
    ||      |||                          |||
    ||      |||____________W5____________|||
    ||__W2__||_____________W3_____________ |
    |__________________W1__________________|

@end group
@end smallexample

@noindent
在此配置中删除@var{W5}通常会导致@var{W3}和@var{W4}的删除。其余的实时窗口
@var{W2}、@var{W6}和@var{W7}将与父窗口@var{W1}重新组合，形成一个新的横向
组合。

但有时，不删除父窗口（如 @var{W4}）是有道理的。特别是，当父窗口被用来保存
嵌入在同一类型的组合中的组合时，就不应该被删除。这样的嵌入是有意义的，以保
证当您拆分一个窗口并随后删除新的窗口时，Emacs会重新建立相关窗框的布局，就
像拆分前存在的一样。

考虑从两个实时窗口@var{W2}和@var{W3}及其父窗口@var{W1}开始。
@smallexample
@group
     ______________________________________
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||_________________W2_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W3_________________||
    |__________________W1__________________|

@end group
@end smallexample

@noindent
将@var{W2}拆分开来制作一个新的窗口@var{W4}，如下所示。

@smallexample
@group
     ______________________________________
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W2_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W4_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W3_________________||
    |__________________W1__________________|

@end group
@end smallexample

@noindent
现在，当垂直放大一个窗口时，Emacs会尝试从它的下级兄弟姐妹那里获得相应的
空间，前提是有这样一个窗口存在。在我们的方案中，放大@var{W4}将会从
@var{W3}中偷取空间。

@smallexample
@group
     ______________________________________
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W2_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||_________________W4_________________||
    | ____________________________________ |
    ||_________________W3_________________||
    |__________________W1__________________|

@end group
@end smallexample

@noindent
删除@var{W4}将会把整个空间交给@var{W2}，包括之前从@var{W3}窃取的空间。

@smallexample
@group
     ______________________________________
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||_________________W2_________________||
    | ____________________________________ |
    ||_________________W3_________________||
    |__________________W1__________________|

@end group
@end smallexample

@noindent
这可能会有悖于直觉，特别是如果@var{W4}只是暂时用于显示缓冲区(
@pxref{临时显示})，而你想继续使用初始布局。

当分割@var{W2}时，可以通过创建一个新的父窗口来修正这种行为。接下来描述的
变量允许这样做。

@defopt window-combination-limit
此变量控制是否将一个窗口分割成一个新的父窗口。认可以下值：

@table @code
@item nil
这意味着新的实时窗口被允许共享现有的父窗口（如果存在的话），前提是分割发生
在与现有窗口组合相同的方向上（否则，无论如何都会创建一个新的内部窗口）。

@item window-size
这意味着@code{display-buffer}在分割一个窗口时，如果在@var{alist}参数 (
@pxref{缓冲区显示动作函数}) 中传递了@code{window-height}或
@code{window-width}条目，就会生成一个新的父窗口。否则，窗口分割的行为与
@code{nil}的值一样。

@item temp-buffer-resize
在这种情况下，当@code{with-temp-buffer-window}拆分一个窗口，并且
@code{temp-buffer-resize-mode}被启用时，会生成一个新的父窗口 (
@pxref{临时显示})。否则，窗口分割的行为与@code{nil} 相同。

@item temp-buffer
在这种情况下，当@code{with-temp-buffer-window}拆分一个现有的窗口时，总
是会创建一个新的父窗口 (@pxref{临时显示})。否则，窗口分割的行为与
@code{nil}相同。

@item display-buffer
这意味着，当@code{display-buffer}的时候。(@pxref{选择窗口})拆分一个窗口
时，总是会生成一个新的父窗口。否则，窗口分割的行为与@code{nil}相同。

@item t
这意味着拆分一个窗口总是创建一个新的父窗口。因此，如果这个变量的值在任何
时候都是@code{t}，那么在任何时候，每棵窗口树都是一棵二叉树（在这棵树上，
除了根窗口外，每个窗口都有一个兄弟姐妹）。
@end table

默认值是@code{window-size}。其他值保留给将来使用。

如果由于这个变量的设置，@code{split-window}制造了一个新的父窗口，它也会
调用@code{set-window-combination-limit}。(见下文)的新创建的内部窗口。这
将影响删除子窗口时窗口树的重新排列方式（见下文）。
@end defopt

  如果@code{window-combination-limit}是@code{t}，那么在我们方案的初始配
置中拆分@var{W2}就会产生这样的结果：

@smallexample
@group
     ______________________________________
    | ____________________________________ |
    || __________________________________ ||
    |||                                  |||
    |||________________W2________________|||
    || __________________________________ ||
    |||                                  |||
    |||________________W4________________|||
    ||_________________W5_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W3_________________||
    |__________________W1__________________|

@end group
@end smallexample

@noindent
新的内部窗口@var{W5}已经创建；它的子窗口是@var{W2}和新的实时窗口@var{W4}。
现在，@var{W2}是@var{W4}的唯一兄弟姐妹，因此放大@var{W4}将尝试缩小
@var{W2}，让@var{W3}不受影响。请注意，@var{W5}代表了嵌入在垂直组合
@var{W1}中的两个窗口的垂直组合。

@cindex window combination limit
@defun set-window-combination-limit window limit
此函数将窗口@var{window}的@dfn{combination limit}设置为@var{limit}。这个
值可以通过函数@code{window-combination-limit}来获取。请看下面的效果，注意
它只对内部窗口有意义。@code{split-window}函数会自动调用这个函数，将
@code{t}作为@var{limit}传递给它，前提是调用时变量
@code{window-combination-limit}的值是@code{t}。
@end defun

@defun window-combination-limit window
此函数返回@var{window}的组合限制。

组合限制只对一个内部窗口有意义。如果是@code{nil}，那么Emacs允许自动删除
@var{window}，以使@var{window}的子窗口与其同级窗口组成一个新的窗口组合。如
果组合限制是@code{t}，则@var{window}的子窗口永远不会自动与它的同级窗口重新
组合。

如果在本节开头所示的配置中，@var{W4}的组合限值(@var{W6}和@var{W7}的父窗口)
是@code{t}，删除@var{W5}不会隐含式地将@var{W4}也删除。
@end defun

另外，每当拆分或删除一个窗口时，总是以相同的组合调整所有窗口的大小，就可以避
免上述问题。这也允许拆分窗口，否则窗口太小，无法进行这种操作。

@defopt window-combination-resize
如果这个变量是@code{nil}，那么@code{split-window}只能在@var{window}的屏幕
面积足够大，可以同时容纳自己和新窗口的情况下，才能分割一个窗口（用
@var{window}表示）。

如果这个变量是 @code{t}，@code{split-window}会尝试调整所有与@var{window}
属于同一组合的窗口的大小，以适应新窗口的需要。特别是，即使@var{window}是一
个固定大小的窗口，或者太小而无法正常分割，@code{split-window}也能成功。此外
，随后调整或删除@var{window}可能会调整其组合中所有其他窗口的大小。

默认值是@code{nil}。其他值保留给将来使用。如果一个特定的分割操作受到
@code{window-combination-limit}的非@code{nil}值的影响，那么这个变量的值可
能会被忽略。
@end defopt

 为了说明@code{window-combination-size}的效果，考虑以下窗框布局。

@smallexample
@group
     ______________________________________
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||_________________W2_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||_________________W3_________________||
    |__________________W1__________________|

@end group
@end smallexample

@noindent
如果@code{window-combination-size}为@code{nil}，则分割窗口@var{W3}时，
@var{W2}的大小不变：

@smallexample
@group
     ______________________________________
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||_________________W2_________________||
    | ____________________________________ |
    ||                                    ||
    ||_________________W3_________________||
    | ____________________________________ |
    ||                                    ||
    ||_________________W4_________________||
    |__________________W1__________________|

@end group
@end smallexample

@noindent
如果@code{window-combination-size}是@code{t}，拆分@var{W3}反而会让三个实
时窗口的高度大致相同：

@smallexample
@group
     ______________________________________
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W2_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W3_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W4_________________||
    |__________________W1__________________|

@end group
@end smallexample

@noindent
删除任何一个实时窗口@var{W2}、@var{W3}或@var{W4}都会将其空间按比例分配
给剩下的两个实时窗口。


@node 选择窗口
@section Selecting Windows
@cindex selecting a window

@defun select-window window &optional norecord
这个函数使@var{window}成为被选中的窗口和在其窗框(@pxref{基本窗口})中被
选中的窗口，并选择该窗框。它也使@var{window}的缓冲区(
@pxref{缓冲区和窗口})成为当前状态，并将该缓冲区中@code{point}的值设置为
@var{window}(@pxref{窗口点})中@code{window-point}的值。@var{window}必
须是一个实时窗口。返回值是@var{window}。

默认情况下，这个函数也会将@var{window}的缓冲区移动到缓冲区列表的前面 (
@pxref{缓冲区列表})，并使@var{window}成为最近选中的窗口。如果可选的参数
@var{norecord}是非@code{nil}，那么这些额外的操作将被省略。

此外，这个函数默认情况下还会告诉显示引擎，当@var{window}的窗框下一次被重
新显示时，要更新其显示。如果@var{norecord}是非@code{nil}，那么通常不会进
行这样的更新。但是，如果@var{norecord}等于特殊符号
@code{mark-for-redisplay}，那么上面提到的附加操作就会被省略，但
@var{window} 还是会被更新。

请注意，有时选择一个窗口并不足以显示它，或者使它的窗框成为显示的最上层窗
框：您可能还需要提高窗框或确保输入焦点指向该窗框。@xref{输入焦点}。
@end defun

@cindex select window hooks
@cindex running a hook when a window gets selected
由于历史原因，Emacs不会在窗口被选中时运行一个单独的钩子。应用程序和内部
例程经常会临时选择一个窗口来执行一些操作。他们这样做的目的是为了简化编
码--因为许多函数在没有指定@var{window}参数时默认在选定的窗口上操作--或
者因为一些函数没有（现在也没有）采用窗口作为参数，而总是在选定的窗口上操
作。每当一个窗口在短时间内被选中时运行一个钩子，而当之前选中的窗口被恢复
时再运行一次钩子是没有用的。

然而，当它的@var{norecord}参数为@code{nil}时，@code{select-window}会
更新缓冲区列表，从而间接运行正常的钩子@code{buffer-list-update-hook}。
(@pxref{缓冲区列表})。因此，该钩子提供了一种方法来运行一个函数，每当一
个窗口被更多的"永久"选中时，该函数就会运行。

因为@code{buffer-list-update-hook}也会被与窗口管理无关的函数运行，所以
通常在运行该钩子时，将所选窗口的值保存在某个地方并与
@code{selected-window}的值进行比较是有意义的。另外，为了避免在使用
@code{buffer-list-update-hook} 时出现误报，好的做法是，每一次
@code{select-window}调用都应该选择一个窗口，只是暂时传递一个非@code{nil}
的值。@var{norecord}参数。如果可能，在这种情况下，应使用宏
@code{with-selected-window}（见下文）。

Emacs还会在重新显示例程检测到自上次重新显示后有另一个窗口被选中时运行钩子
@code{window-selection-change-functions}。详细解释请参见
@xref{窗口钩子}。@code{window-state-change-functions}(在同一节中描述)
是在选择了不同的窗口后运行的另一个异常钩子，但也是由其他窗口变化触发的。

@cindex most recently selected windows
  有非@code{nil}的@var{norecord}参数的对@code{select-window}的调用序列，
决定了按窗口的选择时间进行排序。函数@code{get-lru-window}可以用来检索最
不近选择的的实时窗口（@pxref{循环窗口排序}）。

@defmac save-selected-window forms@dots{}
这个宏记录了所选的窗框，以及每个窗框所选的窗口，依次执行@var{forms}，然
后恢复之前所选的窗框和窗口。它还保存和恢复当前的缓冲区。它返回
@var{forms}中最后一个窗体的值。

这个宏不会保存或恢复任何关于窗口的大小、排列或内容的信息；因此，如果
@var{forms}改变了这些内容，则改变的内容会持续存在。如果在退出@var{forms}
时，某个窗框的先前选择的窗口不再有效，那么该窗框的选择窗口将被单独保留。
如果之前选中的窗口不再有效，那么在@var{forms}结束时选中的任何窗口都会保
持选中状态。只有当退出@var{forms}时，当前的缓冲区仍然有效时，才会被恢复。

这个宏既不改变最近选择的窗口的顺序，也不改变缓冲区列表。
@end defmac

@defmac with-selected-window window forms@dots{}
这个宏选择@var{window}，依次执行@var{forms}，然后恢复之前选择的窗口和当
前缓冲区。最近选中的窗口和缓冲区列表的顺序保持不变，除非你故意在
@var{forms}中改变它们；例如，通过调用@code{select-window}，参数
@var{norecord}为@code{nil}。因此，这个宏是暂时使用@var{window}作为选定
窗口的首选方法，而不需要运行@code{buffer-list-update-hook}。
@end defmac

@defun frame-selected-window &optional frame
此函数返回在@var{frame}上选择的窗口。@var{frame}应该是一个实时窗框；如果
省略或@code{nil}，则默认为选定的窗框。
@end defun

@defun set-frame-selected-window frame window &optional norecord
此函数使@var{window}成为在@var{frame}窗框内选择的窗口。@var{frame}应该
是一个实时窗框；如果@code{nil}，则默认为选中的窗框。@var{window}应该是
一个实时窗口；如果@code{nil}，则默认为选中的窗口。

如果@var{frame}是被选中的窗框，那么这将使@var{window}成为被选中的窗口。

如果可选参数@var{norecord}是非@code{nil}，则该函数不会改变最近选中的窗
口列表，也不会改变缓冲区列表。
@end defun

@cindex window use time
@cindex use time of window
@cindex window order by time of last use
@defun window-use-time &optional window
此函数返回@var{window}窗口的使用时间。@var{window}必须是一个实时窗口，
默认为选定的窗口。

窗口的@dfn{使用时间}并不是真正的时间值，而是一个整数，它确实随着
@code{select-window}的每一次调用而单调增加，并带有@code{nil}的
@var{norecord}参数。使用时间最少的窗口通常称为最不近使用的窗口，而使用
时间最多的窗口称为最近使用的窗口（@pxref{循环窗口排序}）。
@end defun


@node 循环窗口排序
@section Cyclic Ordering of Windows
@cindex cyclic ordering of windows
@cindex ordering of windows, cyclic
@cindex window ordering, cyclic

  当您使用@w{@kbd{C-x o}}命令时，您会发现，在您的电脑中，有很多人在使用
@w{@kbd{C-x o}(@code{other-window})来选择其他窗口，它按照特定的顺序在
实时窗口中移动。对于任何给定的窗口配置，这个顺序永远不会变化。这就是所谓
的@dfn{窗口的循环排序}。

顺序是通过对每个窗框的窗口树进行深度优先遍历来确定的，检索作为树叶节点的
实时窗口（@pxref{窗口和窗框}）。如果minibuffer是活动的，那么minibuffer
窗口也会被包含在内。顺序是循环的，所以序列中的最后一个窗口后面是第一个窗
口。

@defun next-window &optional window minibuf all-frames
@cindex minibuffer window, and @code{next-window}
此函数返回一个实时窗口，即在@var{window}之后的窗口，按照窗口的循环顺序
排列。@var{window}应该是一个实时窗口；如果省略或@code{nil}，则默认为选
定的窗口。

可选参数@var{minibuf}指定了迷你缓冲区窗口是否应该被包含在循环排序中，通
常情况下，当@var{minibuf}为@code{nil}时，迷你缓冲区窗口只有在当前处于
活动状态时才会被包含。通常情况下，当@var{minibuf}为@code{nil}时，只有
当minibuffer窗口当前处于活动状态时才会被包括在内；这与@w{@kbd{C-x o}}
的行为一致。(请注意，只要一个迷你缓冲区窗口的迷你缓冲区在使用中，它就处
于活动状态；参见@ref{迷你缓冲区}）。

如果@var{minibuf}是@code{t}，则循环排序包括所有迷你缓冲区窗口。如果
@var{minibuf}既不是@code{t}，也不是@code{nil}，则即使迷你缓冲区窗口处
于活动状态，也不会被包括在内。

可选参数@var{all-frames}指定要考虑的窗框：

@itemize @bullet
@item @code{nil}
意味着要考虑@var{window}窗框上的窗口。如果minibuffer窗口被考虑（如
@var{minibuf}参数所指定），那么共享minibuffer窗口的窗框也会被考虑。

@item @code{t}
是指考虑在所有现有窗框上的窗口。

@item @code{visible}
是指在所有可见的窗框上考虑窗口。

@item 0
是指在所有可见或图标化的窗框上考虑窗口。

@item A frame
是指在该特定窗框上考虑窗口。

@item Anything else
意味着要考虑@var{window}窗框上的窗口，而不考虑其他窗口。
@end itemize

如果考虑了一个以上的窗框，则通过追加这些窗框的排序，获得循环排序，顺序与
所有实时窗框的列表相同（@pxref{寻找所有窗框}）。
@end defun

@defun previous-window &optional window minibuf all-frames
这个函数返回一个实时窗口，也就是窗口循环排序中@var{window}之前的那个窗口。
其他参数的处理方式和@code{next-window}一样。
@end defun

@deffn Command other-window count &optional all-frames
该函数选择一个实时窗口，从被选中的窗口中按窗口的循环排序选出一个
@var{count}位。如果@var{count}为正数，则向前跳过@var{count}窗口；如果
@var{count}为负数，则向后跳过@minus{}@var{count}窗口；如果@var{count}为
零，则简单地重新选择所选窗口。当交互式调用时，@var{count}是数字前缀参数。

可选参数@var{all-frames}与@code{next-window}的含义相同，就像
@code{nil}一样。@var{minibuf}参数到@code{next-window}。

该函数不会选择一个非@code{nil}的窗口。@code{no-other-window}窗口参数（
@pxref{窗口参数}），前提是@code{ignore-window-parameters}是@code{nil}。

如果所选窗口的@code{other-window}参数是一个函数，而
@code{ignore-window-parameters}是@code{nil}，那么该函数将以@var{count}
和@var{all-frames}为参数被调用，而不是该函数的正常操作。
@end deffn

@defun walk-windows fun &optional minibuf all-frames
这个函数对每个实时窗口调用一次函数@var{fun}，以窗口为参数。

它遵循窗口的循环排序。可选参数@var{minibuf}和@var{all-frames}指定了所包
含的窗口集；这些参数与@code{next-window}中的参数相同。如果
@var{all-frames}指定了一个窗框，那么走过的第一个窗口就是该窗框上的第一个
窗口（由@code{frame-first-window}返回的窗口），而不一定是选定的窗口。

如果@var{fun}通过拆分或删除窗口来改变窗口配置，那么不会改变走过的窗口集，
这是在第一次调用@var{fun}之前确定的。
@end defun

@defun one-window-p &optional no-mini all-frames
如果选中的窗口是唯一的实时窗口，则该函数返回@code{t}，否则返回@code{nil}。

如果minibuffer窗口处于活动状态，通常会被考虑（因此本函数返回@code{nil}）。
但是，如果可选参数@var{no-mini}是非@code{nil}，那么即使minibuffer窗口处
于活动状态，也会被忽略。可选参数@var{all-frames}的含义与
@code{next-window}相同。
@end defun

@cindex finding windows
  下面的函数返回一个符合某种标准的窗口，而不选择它：

@cindex least recently used window
@defun get-lru-window &optional all-frames dedicated not-selected
这个函数返回一个实时窗口，这个窗口是最近使用次数最少的。可选参数
@var{all-frames}与@code{next-window}的这个参数含义相同。

如果存在任何全宽窗口，则只考虑这些窗口。minibuffer窗口永远不会成为候选者。
专用窗口 (@pxref{专用窗口}) 绝不是候选窗口，除非可选参数@var{dedicated}
是非@code{nil}。被选中的窗口永远不会返回，除非它是唯一的候选者。但是，如
果可选参数@var{not-selected}是非@code{nil}，那么在这种情况下，这个函数
将返回@code{nil}。
@end defun

@cindex most recently used window
@defun get-mru-window &optional all-frames dedicated not-selected
这个函数和@code{get-lru-window}类似，但是它返回的是最近使用的窗口。参数
的含义与@code{get-lru-window}相同。
@end defun

@cindex largest window
@defun get-largest-window &optional all-frames dedicated not-selected
This function returns the window with the largest area (height times
width).  The optional argument @var{all-frames} specifies the windows to
search, and has the same meaning as in @code{next-window}.

A minibuffer window is never a candidate.  A dedicated window
(@pxref{Dedicated Windows}) is never a candidate unless the optional
argument @var{dedicated} is non-@code{nil}.  The selected window is not
a candidate if the optional argument @var{not-selected} is
non-@code{nil}.  If the optional argument @var{not-selected} is
non-@code{nil} and the selected window is the only candidate, this
function returns @code{nil}.

If there are two candidate windows of the same size, this function
prefers the one that comes first in the cyclic ordering of windows,
starting from the selected window.
@end defun

@cindex window that satisfies a predicate
@cindex conditional selection of windows
@defun get-window-with-predicate predicate &optional minibuf all-frames default
This function calls the function @var{predicate} for each of the
windows in the cyclic order of windows in turn, passing it the window
as an argument.  If the predicate returns non-@code{nil} for any
window, this function stops and returns that window.  If no such
window is found, the return value is @var{default} (which defaults to
@code{nil}).

The optional arguments @var{minibuf} and @var{all-frames} specify the
windows to search, and have the same meanings as in
@code{next-window}.
@end defun


@node 缓冲区和窗口
@section Buffers and Windows
@cindex examining windows
@cindex windows, controlling precisely
@cindex buffers, controlled in windows

  This section describes low-level functions for examining and setting
the contents of windows.  @xref{Switching Buffers}, for higher-level
functions for displaying a specific buffer in a window.

@defun window-buffer &optional window
This function returns the buffer that @var{window} is displaying.  If
@var{window} is omitted or @code{nil} it defaults to the selected
window.  If @var{window} is an internal window, this function returns
@code{nil}.
@end defun

@defun set-window-buffer window buffer-or-name &optional keep-margins
This function makes @var{window} display @var{buffer-or-name}.
@var{window} should be a live window; if @code{nil}, it defaults to
the selected window.  @var{buffer-or-name} should be a buffer, or the
name of an existing buffer.  This function does not change which
window is selected, nor does it directly change which buffer is
current (@pxref{Current Buffer}).  Its return value is @code{nil}.

If @var{window} is @dfn{strongly dedicated} to a buffer and
@var{buffer-or-name} does not specify that buffer, this function
signals an error.  @xref{Dedicated Windows}.

By default, this function resets @var{window}'s position, display
margins, fringe widths, and scroll bar settings, based on the local
variables in the specified buffer.  However, if the optional argument
@var{keep-margins} is non-@code{nil}, it leaves @var{window}'s display
margins, fringes and scroll bar settings alone.

When writing an application, you should normally use
@code{display-buffer} (@pxref{Choosing Window}) or the higher-level
functions described in @ref{Switching Buffers}, instead of calling
@code{set-window-buffer} directly.

This runs @code{window-scroll-functions}, followed by
@code{window-configuration-change-hook}.  @xref{Window Hooks}.
@end defun

@defvar buffer-display-count
This buffer-local variable records the number of times a buffer has been
displayed in a window.  It is incremented each time
@code{set-window-buffer} is called for the buffer.
@end defvar

@defvar buffer-display-time
This buffer-local variable records the time at which a buffer was last
displayed in a window.  The value is @code{nil} if the buffer has
never been displayed.  It is updated each time
@code{set-window-buffer} is called for the buffer, with the value
returned by @code{current-time} (@pxref{Time of Day}).
@end defvar

@defun get-buffer-window &optional buffer-or-name all-frames
This function returns the first window displaying @var{buffer-or-name}
in the cyclic ordering of windows, starting from the selected window
(@pxref{Cyclic Window Ordering}).  If no such window exists, the
return value is @code{nil}.

@var{buffer-or-name} should be a buffer or the name of a buffer; if
omitted or @code{nil}, it defaults to the current buffer.  The
optional argument @var{all-frames} specifies which windows to
consider:

@itemize @bullet
@item
@code{t} means consider windows on all existing frames.
@item
@code{visible} means consider windows on all visible frames.
@item
0 means consider windows on all visible or iconified frames.
@item
A frame means consider windows on that frame only.
@item
Any other value means consider windows on the selected frame.
@end itemize

Note that these meanings differ slightly from those of the
@var{all-frames} argument to @code{next-window} (@pxref{Cyclic Window
Ordering}).  This function may be changed in a future version of Emacs
to eliminate this discrepancy.
@end defun

@defun get-buffer-window-list &optional buffer-or-name minibuf all-frames
This function returns a list of all windows currently displaying
@var{buffer-or-name}.  @var{buffer-or-name} should be a buffer or the
name of an existing buffer.  If omitted or @code{nil}, it defaults to
the current buffer.  If the currently selected window displays
@var{buffer-or-name}, it will be the first in the list returned by
this function.

The arguments @var{minibuf} and @var{all-frames} have the same
meanings as in the function @code{next-window} (@pxref{Cyclic Window
Ordering}).  Note that the @var{all-frames} argument does @emph{not}
behave exactly like in @code{get-buffer-window}.
@end defun

@deffn Command replace-buffer-in-windows &optional buffer-or-name
This command replaces @var{buffer-or-name} with some other buffer, in
all windows displaying it.  @var{buffer-or-name} should be a buffer, or
the name of an existing buffer; if omitted or @code{nil}, it defaults to
the current buffer.

The replacement buffer in each window is chosen via
@code{switch-to-prev-buffer} (@pxref{Window History}).  Any dedicated
window displaying @var{buffer-or-name} is deleted if possible
(@pxref{Dedicated Windows}).  If such a window is the only window on its
frame and there are other frames on the same terminal, the frame is
deleted as well.  If the dedicated window is the only window on the only
frame on its terminal, the buffer is replaced anyway.
@end deffn


@node 切换缓冲区
@section Switching to a Buffer in a Window
@cindex switching to a buffer

This section describes high-level functions for switching to a specified
buffer in some window.  In general, ``switching to a buffer'' means to
(1) show the buffer in some window, (2) make that window the selected
window (and its frame the selected frame), and (3) make the buffer the
current buffer.

  Do @emph{not} use these functions to make a buffer temporarily
current just so a Lisp program can access or modify it.  They have
side-effects, such as changing window histories (@pxref{Window
History}), which will surprise the user if used that way.  If you want
to make a buffer current to modify it in Lisp, use
@code{with-current-buffer}, @code{save-current-buffer}, or
@code{set-buffer}.  @xref{Current Buffer}.

@deffn Command switch-to-buffer buffer-or-name &optional norecord force-same-window
This command attempts to display @var{buffer-or-name} in the selected
window and make it the current buffer.  It is often used interactively
(as the binding of @kbd{C-x b}), as well as in Lisp programs.  The
return value is the buffer switched to.

If @var{buffer-or-name} is @code{nil}, it defaults to the buffer
returned by @code{other-buffer} (@pxref{Buffer List}).  If
@var{buffer-or-name} is a string that is not the name of any existing
buffer, this function creates a new buffer with that name; the new
buffer's major mode is determined by the variable @code{major-mode}
(@pxref{Major Modes}).

Normally, the specified buffer is put at the front of the buffer
list---both the global buffer list and the selected frame's buffer
list (@pxref{Buffer List}).  However, this is not done if the
optional argument @var{norecord} is non-@code{nil}.

Sometimes, the selected window may not be suitable for displaying the
buffer.  This happens if the selected window is a minibuffer window, or
if the selected window is strongly dedicated to its buffer
(@pxref{Dedicated Windows}).  In such cases, the command normally tries
to display the buffer in some other window, by invoking
@code{pop-to-buffer} (see below).

If the optional argument @var{force-same-window} is non-@code{nil} and
the selected window is not suitable for displaying the buffer, this
function always signals an error when called non-interactively.  In
interactive use, if the selected window is a minibuffer window, this
function will try to use some other window instead.  If the selected
window is strongly dedicated to its buffer, the option
@code{switch-to-buffer-in-dedicated-window} described next can be used
to proceed.
@end deffn

@defopt switch-to-buffer-in-dedicated-window
This option, if non-@code{nil}, allows @code{switch-to-buffer} to
proceed when called interactively and the selected window is strongly
dedicated to its buffer.

The following values are respected:

@table @code
@item nil
Disallows switching and signals an error as in non-interactive use.

@item prompt
Prompts the user whether to allow switching.

@item pop
Invokes @code{pop-to-buffer} to proceed.

@item t
Marks the selected window as non-dedicated and proceeds.
@end table

This option does not affect non-interactive calls of
@code{switch-to-buffer}.
@end defopt

By default, @code{switch-to-buffer} tries to preserve
@code{window-point}.  This behavior can be tuned using the following
option.

@defopt switch-to-buffer-preserve-window-point
If this variable is @code{nil}, @code{switch-to-buffer} displays the
buffer specified by @var{buffer-or-name} at the position of that
buffer's @code{point}.  If this variable is @code{already-displayed}, it
tries to display the buffer at its previous position in the selected
window, provided the buffer is currently displayed in some other window
on any visible or iconified frame.  If this variable is @code{t},
@code{switch-to-buffer} unconditionally tries to display the buffer at
its previous position in the selected window.

This variable is ignored if the buffer is already displayed in the
selected window or never appeared in it before, or if
@code{switch-to-buffer} calls @code{pop-to-buffer} to display the
buffer.
@end defopt

@defopt switch-to-buffer-obey-display-actions
If this variable is non-@code{nil}, @code{switch-to-buffer} respects
display actions specified by @code{display-buffer-overriding-action},
@code{display-buffer-alist} and other display related variables.
@end defopt

The next two commands are similar to @code{switch-to-buffer}, except for
the described features.

@deffn Command switch-to-buffer-other-window buffer-or-name &optional norecord
This function displays the buffer specified by @var{buffer-or-name} in
some window other than the selected window.  It uses the function
@code{pop-to-buffer} internally (see below).

If the selected window already displays the specified buffer, it
continues to do so, but another window is nonetheless found to display
it as well.

The @var{buffer-or-name} and @var{norecord} arguments have the same
meanings as in @code{switch-to-buffer}.
@end deffn

@deffn Command switch-to-buffer-other-frame buffer-or-name &optional norecord
This function displays the buffer specified by @var{buffer-or-name} in a
new frame.  It uses the function @code{pop-to-buffer} internally (see
below).

If the specified buffer is already displayed in another window, in any
frame on the current terminal, this switches to that window instead of
creating a new frame.  However, the selected window is never used for
this.

The @var{buffer-or-name} and @var{norecord} arguments have the same
meanings as in @code{switch-to-buffer}.
@end deffn

The above commands use the function @code{pop-to-buffer}, which
flexibly displays a buffer in some window and selects that window for
editing.  In turn, @code{pop-to-buffer} uses @code{display-buffer} for
displaying the buffer.  Hence, all the variables affecting
@code{display-buffer} will affect it as well.  @xref{Choosing Window},
for the documentation of @code{display-buffer}.

@deffn Command pop-to-buffer buffer-or-name &optional action norecord
This function makes @var{buffer-or-name} the current buffer and
displays it in some window, preferably not the window currently
selected.  It then selects the displaying window.  If that window is
on a different graphical frame, that frame is given input focus if
possible (@pxref{Input Focus}).

If @var{buffer-or-name} is @code{nil}, it defaults to the buffer
returned by @code{other-buffer} (@pxref{Buffer List}).  If
@var{buffer-or-name} is a string that is not the name of any existing
buffer, this function creates a new buffer with that name; the new
buffer's major mode is determined by the variable @code{major-mode}
(@pxref{Major Modes}).  In any case, that buffer is made current and
returned, even when no suitable window was found to display it.

If @var{action} is non-@code{nil}, it should be a display action to
pass to @code{display-buffer} (@pxref{Choosing Window}).
Alternatively, a non-@code{nil}, non-list value means to pop to a
window other than the selected one---even if the buffer is already
displayed in the selected window.

Like @code{switch-to-buffer}, this function updates the buffer list
unless @var{norecord} is non-@code{nil}.
@end deffn


@node 显示缓冲区
@section Displaying a Buffer in a Suitable Window
@cindex buffer display
@cindex displaying a buffer

This section describes lower-level functions Emacs uses to find or
create a window for displaying a specified buffer.  The common
workhorse of these functions is @code{display-buffer} which eventually
handles all incoming requests for buffer display (@pxref{Choosing
Window}).

   @code{display-buffer} delegates the task of finding a suitable
window to so-called action functions (@pxref{Buffer Display Action
Functions}).  First, @code{display-buffer} compiles a so-called action
alist---a special association list that action functions can use to
fine-tune their behavior.  Then it passes that alist on to each action
function it calls (@pxref{Buffer Display Action Alists}).

   The behavior of @code{display-buffer} is highly customizable.  To
understand how customizations are used in practice, you may wish to
study examples illustrating the order of precedence which
@code{display-buffer} uses to call action functions (@pxref{Precedence
of Action Functions}).  To avoid conflicts between Lisp programs
calling @code{display-buffer} and user customizations of its behavior,
it may make sense to follow a number of guidelines which are sketched
in the final part of this section (@pxref{The Zen of Buffer Display}).

@menu
* Choosing Window::         How to choose a window for displaying a buffer.
* Buffer Display Action Functions:: Support functions for buffer display.
* Buffer Display Action Alists:: Alists for fine-tuning buffer display.
* Choosing Window Options:: Extra options affecting how buffers are displayed.
* Precedence of Action Functions:: Examples to explain the precedence of
                              action functions.
* The Zen of Buffer Display:: How to avoid that buffers get lost in between
                              windows.
@end menu


@node Choosing Window
@subsection Choosing a Window for Displaying a Buffer

The command @code{display-buffer} flexibly chooses a window for
display, and displays a specified buffer in that window.  It can be
called interactively, via the key binding @kbd{C-x 4 C-o}.  It is also
used as a subroutine by many functions and commands, including
@code{switch-to-buffer} and @code{pop-to-buffer} (@pxref{Switching
Buffers}).

@cindex buffer display display action
@cindex display action
  This command performs several complex steps to find a window to
display in.  These steps are described by means of @dfn{display
actions}, which have the form @code{(@var{functions} . @var{alist})}.
Here, @var{functions} is either a single function or a list of
functions, referred to as ``action functions'' (@pxref{Buffer Display
Action Functions}); and @var{alist} is an association list, referred
to as ``action alist'' (@pxref{Buffer Display Action Alists}).
@xref{The Zen of Buffer Display}, for samples of display actions.

  An action function accepts two arguments: the buffer to display and
an action alist.  It attempts to display the buffer in some window,
picking or creating a window according to its own criteria.  If
successful, it returns the window; otherwise, it returns @code{nil}.

  @code{display-buffer} works by combining display actions from
several sources, and calling the action functions in turn, until one
of them manages to display the buffer and returns a non-@code{nil}
value.

@deffn Command display-buffer buffer-or-name &optional action frame
This command makes @var{buffer-or-name} appear in some window, without
selecting the window or making the buffer current.  The argument
@var{buffer-or-name} must be a buffer or the name of an existing
buffer.  The return value is the window chosen to display the buffer,
or @code{nil} if no suitable window was found.

The optional argument @var{action}, if non-@code{nil}, should normally
be a display action (described above).  @code{display-buffer} builds a
list of action functions and an action alist, by consolidating display
actions from the following sources (in order of their precedence,
from highest to lowest):

@itemize
@item
The variable @code{display-buffer-overriding-action}.

@item
The user option @code{display-buffer-alist}.

@item
The @var{action} argument.

@item
The user option @code{display-buffer-base-action}.

@item
The constant @code{display-buffer-fallback-action}.
@end itemize

@noindent
In practice this means that @code{display-buffer} builds a list of all
action functions specified by these display actions.  The first
element of this list is the first action function specified by
@code{display-buffer-overriding-action}, if any.  Its last element is
@code{display-buffer-pop-up-frame}---the last action function
specified by @code{display-buffer-fallback-action}.  Duplicates are
not removed from this list---hence one and the same action function
may be called multiple times during one call of @code{display-buffer}.

@code{display-buffer} calls the action functions specified by this
list in turn, passing the buffer as the first argument and the
combined action alist as the second argument, until one of the
functions returns non-@code{nil}.  @xref{Precedence of Action
Functions}, for examples how display actions specified by different
sources are processed by @code{display-buffer}.

Note that the second argument is always the list of @emph{all} action
alist entries specified by the sources named above.  Hence, the first
element of that list is the first action alist entry specified by
@code{display-buffer-overriding-action}, if any.  Its last element is
the last alist entry of @code{display-buffer-base-action}, if any (the
action alist of @code{display-buffer-fallback-action} is empty).

Note also, that the combined action alist may contain duplicate
entries and entries for the same key with different values.  As a
rule, action functions always use the first association of a key they
find.  Hence, the association an action function uses is not
necessarily the association provided by the display action that
specified that action function,

The argument @var{action} can also have a non-@code{nil}, non-list
value.  This has the special meaning that the buffer should be
displayed in a window other than the selected one, even if the
selected window is already displaying it.  If called interactively
with a prefix argument, @var{action} is @code{t}.  Lisp programs
should always supply a list value.

The optional argument @var{frame}, if non-@code{nil}, specifies which
frames to check when deciding whether the buffer is already displayed.
It is equivalent to adding an element @w{@code{(reusable-frames
. @var{frame})}} to the action alist of @var{action} (@pxref{Buffer
Display Action Alists}).  The @var{frame} argument is provided for
compatibility reasons, Lisp programs should not use it.
@end deffn

@defvar display-buffer-overriding-action
The value of this variable should be a display action, which is
treated with the highest priority by @code{display-buffer}.  The
default value is an empty display action, i.e., @w{@code{(nil . nil)}}.
@end defvar

@defopt display-buffer-alist
The value of this option is an alist mapping conditions to display
actions.  Each condition may be either a regular expression matching a
buffer name or a function that takes two arguments: a buffer name and
the @var{action} argument passed to @code{display-buffer}.  If either
the name of the buffer passed to @code{display-buffer} matches a
regular expression in this alist, or the function specified by a
condition returns non-@code{nil}, then @code{display-buffer} uses the
corresponding display action to display the buffer.
@end defopt

@defopt display-buffer-base-action
The value of this option should be a display action.  This option can
be used to define a standard display action for calls to
@code{display-buffer}.
@end defopt

@defvr Constant display-buffer-fallback-action
This display action specifies the fallback behavior for
@code{display-buffer} if no other display actions are given.
@end defvr


@node Buffer Display Action Functions
@subsection Action Functions for Buffer Display
@cindex buffer display action function
@cindex action function, for buffer display

An @dfn{action function} is a function @code{display-buffer} calls for
choosing a window to display a buffer.  Action functions take two
arguments: @var{buffer}, the buffer to display, and @var{alist}, an
action alist (@pxref{Buffer Display Action Alists}).  They are
supposed to return a window displaying @var{buffer} if they succeed
and @code{nil} if they fail.

   The following basic action functions are defined in Emacs.

@defun display-buffer-same-window buffer alist
This function tries to display @var{buffer} in the selected window.
It fails if the selected window is a minibuffer window or is dedicated
to another buffer (@pxref{Dedicated Windows}).  It also fails if
@var{alist} has a non-@code{nil} @code{inhibit-same-window} entry.
@end defun

@defun display-buffer-reuse-window buffer alist
This function tries to display @var{buffer} by finding a window that
is already displaying it.  Windows on the selected frame are preferred
to windows on other frames.

If @var{alist} has a non-@code{nil} @code{inhibit-same-window} entry,
the selected window is not eligible for reuse.  The set of frames to
search for a window already displaying @var{buffer} can be specified
with the help of the @code{reusable-frames} action alist entry.  If
@var{alist} contains no @code{reusable-frames} entry, this function
searches just the selected frame.

If this function chooses a window on another frame, it makes that
frame visible and, unless @var{alist} contains an
@code{inhibit-switch-frame} entry, raises that frame if necessary.
@end defun

@defun display-buffer-reuse-mode-window buffer alist
This function tries to display @var{buffer} by finding a window
that is displaying a buffer in a given mode.

If @var{alist} contains a @code{mode} entry, its value specifes a
major mode (a symbol) or a list of major modes.  If @var{alist}
contains no @code{mode} entry, the current major mode of @var{buffer}
is used instead.  A window is a candidate if it displays a buffer
whose mode derives from one of the modes specified thusly.

The behavior is also controlled by @var{alist} entries for
@code{inhibit-same-window}, @code{reusable-frames} and
@code{inhibit-switch-frame}, like @code{display-buffer-reuse-window}
does.
@end defun

@defun display-buffer-pop-up-window buffer alist
This function tries to display @var{buffer} by splitting the largest
or least recently-used window (usually located on the selected frame).
It actually performs the split by calling the function specified by
@code{split-window-preferred-function} (@pxref{Choosing Window
Options}).

The size of the new window can be adjusted by supplying
@code{window-height} and @code{window-width} entries in @var{alist}.
If @var{alist} contains a @code{preserve-size} entry, Emacs will also
try to preserve the size of the new window during future resize
operations (@pxref{Preserving Window Sizes}).

This function fails if no window can be split.  More often than not,
this happens because no window is large enough to allow splitting.
Setting @code{split-height-threshold} or @code{split-width-threshold}
to lower values may help in this regard.  Splitting also fails when
the selected frame has an @code{unsplittable} frame parameter;
@pxref{Buffer Parameters}.
@end defun

@defun display-buffer-in-previous-window buffer alist
This function tries to display @var{buffer} in a window where it was
displayed previously.

If @var{alist} contains a non-@code{nil} @code{inhibit-same-window}
entry, the selected window is not eligible for use.  A dedicated
window is usable only if it already shows @var{buffer}.  If
@var{alist} contains a @code{previous-window} entry, the window
specified by that entry is usable even if it never showed @var{buffer}
before.

If @var{alist} contains a @code{reusable-frames} entry (@pxref{Buffer
Display Action Alists}), its value determines which frames to search
for a suitable window.  If @var{alist} contains no
@code{reusable-frames} entry, this function searches just the selected
frame if @code{display-buffer-reuse-frames} and @code{pop-up-frames}
are both @code{nil}; it searches all frames on the current terminal if
either of those variables is non-@code{nil}.

If more than one window qualifies as usable according to these rules,
this function makes a choice in the following order of preference:

@itemize @bullet
@item
The window specified by any @code{previous-window} @var{alist} entry,
provided it is not the selected window.

@item
A window that showed @var{buffer} before, provided it is not the
selected window.

@item
The selected window if it is either specified by a
@code{previous-window} @var{alist} entry or showed @var{buffer}
before.
@end itemize
@end defun

@defun display-buffer-use-some-window buffer alist
This function tries to display @var{buffer} by choosing an existing
window and displaying the buffer in that window.  It can fail if all
windows are dedicated to other buffers (@pxref{Dedicated Windows}).
@end defun

@defun display-buffer-in-direction buffer alist
This function tries to display @var{buffer} at a location specified by
@var{alist}.  For this purpose, @var{alist} should contain a
@code{direction} entry whose value is one of @code{left}, @code{above}
(or @code{up}), @code{right} and @code{below} (or @code{down}).  Other
values are usually interpreted as @code{below}.

If @var{alist} also contains a @code{window} entry, its value
specifies a reference window.  That value can be a special symbol like
@code{main} which stands for the selected frame's main window
(@pxref{Side Window Options and Functions}) or @code{root} standing
for the selected frame's root window (@pxref{窗口和窗框}).  It
can also specify an arbitrary valid window.  Any other value (or
omitting the @code{window} entry entirely) means to use the selected
window as reference window.

This function first tries to reuse a window in the specified direction
that already shows @var{buffer}.  If no such window exists, it tries
to split the reference window in order to produce a new window in the
specified direction.  If this fails as well, it will try to display
@var{buffer} in an existing window in the specified direction.  In
either case, the window chosen will appear on the side of the
reference window specified by the @code{direction} entry, sharing at
least one edge with the reference window.

If the reference window is live, the edge the chosen window will share
with it is always the opposite of the one specified by the
@code{direction} entry.  For example, if the value of the
@code{direction} entry is @code{left}, the chosen window's right edge
coordinate (@pxref{Coordinates and Windows}) will equal the reference
window's left edge coordinate.

If the reference window is internal, a reused window must share with
it the edge specified by the @code{direction} entry.  Hence if, for
example, the reference window is the frame's root window and the value
of the @code{direction} entry is @code{left}, a reused window must be
on the left of the frame.  This means that the left edge coordinate of
the chosen window and that of the reference window are the same.

A new window, however, will be created by splitting the reference
window such that the chosen window will share the opposite edge with
the reference window.  In our example, a new root window would be
created with a new live window and the reference window as its
children.  The chosen window's right edge coordinate would then equal
the left edge coordinate of the reference window.  Its left edge
coordinate would equal the left edge coordinate of the frame's new
root window.

Four special values for @code{direction} entries allow to implicitly
specify the selected frame's main window as the reference window:
@code{leftmost}, @code{top}, @code{rightmost} and @code{bottom}.  This
means that instead of, for example, @w{@code{(direction . left)
(window . main)}} one can just specify @w{@code{(direction
. leftmost)}}.  An existing @code{window} @var{alist} entry is ignored
in such cases.
@end defun

@defun display-buffer-below-selected buffer alist
This function tries to display @var{buffer} in a window below the
selected window.  If there is a window below the selected one and that
window already displays @var{buffer}, it reuses that window.

If there is no such window, this function tries to create a new window
by splitting the selected one, and displays @var{buffer} there.  It will
also try to adjust that window's size provided @var{alist} contains a
suitable @code{window-height} or @code{window-width} entry, see above.

If splitting the selected window fails and there is a non-dedicated
window below the selected one showing some other buffer, this function
tries to use that window for showing @var{buffer}.

If @var{alist} contains a @code{window-min-height} entry, this
function ensures that the window used is or can become at least as
high as specified by that entry's value.  Note that this is only a
guarantee.  In order to actually resize the window used, @var{alist}
must also provide an appropriate @code{window-height} entry.
@end defun

@defun display-buffer-at-bottom buffer alist
This function tries to display @var{buffer} in a window at the bottom
of the selected frame.

This either tries to split the window at the bottom of the frame or
the frame's root window, or to reuse an existing window at the bottom
of the selected frame.
@end defun

@defun display-buffer-pop-up-frame buffer alist
This function creates a new frame, and displays the buffer in that
frame's window.  It actually performs the frame creation by calling
the function specified in @code{pop-up-frame-function}
(@pxref{Choosing Window Options}).  If @var{alist} contains a
@code{pop-up-frame-parameters} entry, the associated value is added to
the newly created frame's parameters.
@end defun

@defun display-buffer-in-child-frame buffer alist
This function tries to display @var{buffer} in a child frame
(@pxref{Child Frames}) of the selected frame, either reusing an
existing child frame or by making a new one.  If @var{alist} has a
non-@code{nil} @code{child-frame-parameters} entry, the corresponding
value is an alist of frame parameters to give the new frame.  A
@code{parent-frame} parameter specifying the selected frame is
provided by default.  If the child frame should become the child of
another frame, a corresponding entry must be added to @var{alist}.

The appearance of child frames is largely dependent on the parameters
provided via @var{alist}.  It is advisable to use at least ratios to
specify the size (@pxref{Size Parameters}) and the position
(@pxref{Position Parameters}) of the child frame, and to add a
@code{keep-ratio} parameter (@pxref{Frame Interaction Parameters}), in
order to make sure that the child frame remains visible.  For other
parameters that should be considered see @ref{Child Frames}.
@end defun

@defun display-buffer-use-some-frame buffer alist
This function tries to display @var{buffer} by finding a frame that
meets a predicate (by default any frame other than the selected
frame).

If this function chooses a window on another frame, it makes that
frame visible and, unless @var{alist} contains an
@code{inhibit-switch-frame} entry, raises that frame if necessary.

If @var{alist} has a non-@code{nil} @code{frame-predicate} entry, its
value is a function taking one argument (a frame), returning
non-@code{nil} if the frame is a candidate; this function replaces the
default predicate.

If @var{alist} has a non-@code{nil} @code{inhibit-same-window} entry,
the selected window is not used; thus if the selected frame has a
single window, it is not used.
@end defun

@defun display-buffer-no-window buffer alist
If @var{alist} has a non-@code{nil} @code{allow-no-window} entry, then
this function does not display @var{buffer} and returns the symbol
@code{fail}.  This constitutes the only exception to the convention
that an action function returns either @code{nil} or a window showing
@var{buffer}.  If @var{alist} has no such @code{allow-no-window}
entry, this function returns @code{nil}.

If this function returns @code{fail}, @code{display-buffer} will skip
the execution of any further display actions and return @code{nil}
immediately.  If this function returns @code{nil},
@code{display-buffer} will continue with the next display action, if
any.

It is assumed that when a caller of @code{display-buffer} specifies a
non-@code{nil} @code{allow-no-window} entry, it is also able to handle
a @code{nil} return value.
@end defun

Two other action functions are described in their proper
sections---@code{display-buffer-in-side-window} (@pxref{Displaying
Buffers in Side Windows}) and @code{display-buffer-in-atom-window}
(@pxref{Atomic Windows}).


@node Buffer Display Action Alists
@subsection Action Alists for Buffer Display
@cindex buffer display action alist
@cindex action alist for buffer display

An @dfn{action alist} is an association list mapping predefined
symbols recognized by action functions to values these functions are
supposed to interpret accordingly.  In each call,
@code{display-buffer} constructs a new, possibly empty action alist
and passes that entire list on to any action function it calls.

   By design, action functions are free in their interpretation of
action alist entries.  In fact, some entries like
@code{allow-no-window} or @code{previous-window} have a meaning only
for one or a few action functions, and are ignored by the rest.  Other
entries, like @code{inhibit-same-window} or @code{window-parameters},
are supposed to be respected by most action functions, including those
provided by application programs and external packages.

   In the previous subsection we have described in detail how
individual action functions interpret the action alist entries they
care about.  Here we give a reference list of all known action alist
entries according to their symbols, together with their values and
action functions (@pxref{Buffer Display Action Functions}) that
recognize them.  Throughout this list, the terms ``buffer'' will refer
to the buffer @code{display-buffer} is supposed to display, and
``value'' refers to the entry's value.

@table @code
@vindex inhibit-same-window@r{, a buffer display action alist entry}
@item inhibit-same-window
If the value is non-@code{nil}, this signals that the selected window
must not be used for displaying the buffer.  All action functions that
(re-)use an existing window should respect this entry.

@vindex previous-window@r{, a buffer display action alist entry}
@item previous-window
The value must specify a window that may have displayed the buffer
previously.  @code{display-buffer-in-previous-window} will give
preference to such a window provided it is still live and not
dedicated to another buffer.

@vindex mode@r{, a buffer display action alist entry}
@item mode
The value is either a major mode or a list of major modes.
@code{display-buffer-reuse-mode-window} may reuse a window whenever
the value specified by this entry matches the major mode of that
window's buffer.  Other action functions ignore such entries.

@vindex frame-predicate@r{, a buffer display action alist entry}
@item frame-predicate
The value must be a function taking one argument (a frame), supposed
to return non-@code{nil} if that frame is a candidate for displaying
the buffer.  This entry is used by
@code{display-buffer-use-some-frame}.

@vindex reusable-frames@r{, a buffer display action alist entry}
@item reusable-frames
The value specifies the set of frames to search for a window that can
be reused because it already displays the buffer.  It can be set as
follows:

@itemize @bullet
@item
@code{nil} means consider only windows on the selected frame.
(Actually, the last frame used that is not a minibuffer-only frame.)
@item
@code{t} means consider windows on all frames.
@item
@code{visible} means consider windows on all visible frames.
@item
0 means consider windows on all visible or iconified frames.
@item
A frame means consider windows on that frame only.
@end itemize

Note that the meaning of @code{nil} differs slightly from that of the
@var{all-frames} argument to @code{next-window} (@pxref{Cyclic Window
Ordering}).

A major client of this is @code{display-buffer-reuse-window}, but all
other action functions that try to reuse a window are affected as
well.  @code{display-buffer-in-previous-window} consults it when
searching for a window that previously displayed the buffer on another
frame.

@vindex inhibit-switch-frame@r{, a buffer display action alist entry}
@item inhibit-switch-frame
A non-@code{nil} value prevents another frame from being raised or
selected, if the window chosen by @code{display-buffer} is displayed
there.  Primarily affected by this are
@code{display-buffer-use-some-frame} and
@code{display-buffer-reuse-window}.
@code{display-buffer-pop-up-frame} should be affected as well, but
there is no guarantee that the window manager will comply.

@vindex window-parameters@r{, a buffer display action alist entry}
@item window-parameters
The value specifies an alist of window parameters to give the chosen
window.  All action functions that choose a window should process this
entry.

@vindex window-min-height@r{, a buffer display action alist entry}
@item window-min-height
The value specifies a minimum height of the window used, in lines.  If
a window is not or cannot be made as high as specified by this entry,
the window is not considered for use.  The only client of this entry
is presently @code{display-buffer-below-selected}.

Note that providing such an entry alone does not necessarily make the
window as tall as specified by its value.  To actually resize an
existing window or make a new window as tall as specified by that
value, a @code{window-height} entry specifying that value should be
provided as well.  Such a @code{window-height} entry can, however,
specify a completely different value or ask the window height to be
fit to that of its buffer in which case the @code{window-min-height}
entry provides the guaranteed minimum height of the window used.

@vindex window-height@r{, a buffer display action alist entry}
@item window-height
The value specifies whether and how to adjust the height of the chosen
window and can be one of the following:

@itemize @bullet
@item
@code{nil} means to leave the height of the chosen window alone.

@item
An integer number specifies the desired total height of the chosen
window in lines.

@item
A floating-point number specifies the fraction of the chosen window's
desired total height with respect to the total height of its frame's
root window.

@item
If the value specifies a function, that function is called with one
argument---the chosen window.  The function is supposed to adjust the
height of the window; its return value is ignored.  Suitable functions
are @code{shrink-window-if-larger-than-buffer} and
@code{fit-window-to-buffer}, see @ref{Resizing Windows}.
@end itemize

By convention, the height of the chosen window is adjusted only if the
window is part of a vertical combination (@pxref{窗口和窗框})
to avoid changing the height of other, unrelated windows.  Also, this
entry should be processed only under certain conditions which are
specified right below this list.

@vindex window-width@r{, a buffer display action alist entry}
@item window-width
This entry is similar to the @code{window-height} entry described
before, but used to adjust the chosen window's width instead.  The
value can be one of the following:

@itemize @bullet
@item
@code{nil} means to leave the width of the chosen window alone.

@item
An integer specifies the desired total width of the chosen window in
columns.

@item
A floating-point number specifies the fraction of the chosen window's
desired total width with respect to the total width of the frame's
root window.

@item
If the value specifies a function, that function is called with one
argument---the chosen window.  The function is supposed to adjust the
width of the window; its return value is ignored.
@end itemize

By convention, the width of the chosen window is adjusted only if the
window is part of a horizontal combination (@pxref{窗口和窗框}) to avoid changing the width of other, unrelated windows.
Also, this entry should be processed under only certain conditions
which are specified right below this list.

@vindex dedicated@r{, a buffer display action alist entry}
@item dedicated
If non-@code{nil}, such an entry tells @code{display-buffer} to mark
any window it creates as dedicated to its buffer (@pxref{Dedicated
Windows}).  It does that by calling @code{set-window-dedicated-p} with
the chosen window as first argument and the entry's value as second.

@vindex preserve-size@r{, a buffer display action alist entry}
@item preserve-size
If non-@code{nil} such an entry tells Emacs to preserve the size of
the window chosen (@pxref{Preserving Window Sizes}).  The value should
be either @w{@code{(t . nil)}} to preserve the width of the window,
@w{@code{(nil . t)}} to preserve its height or @w{@code{(t . t)}} to
preserve both, its width and its height.  This entry should be
processed only under certain conditions which are specified right
after this list.

@vindex pop-up-frame-parameters@r{, a buffer display action alist entry}
@item pop-up-frame-parameters
The value specifies an alist of frame parameters to give a new frame,
if one is created.  @code{display-buffer-pop-up-frame} is its one and
only addressee.

@vindex parent-frame@r{, a buffer display action alist entry}
@item parent-frame
The value specifies the parent frame to be used when the buffer is
displayed on a child frame.  This entry is used only by
@code{display-buffer-in-child-frame}.

@vindex child-frame-parameters@r{, a buffer display action alist entry}
@item child-frame-parameters
The value specifies an alist of frame parameters to use when the buffer
is displayed on a child frame.  This entry is used only by
@code{display-buffer-in-child-frame}.

@vindex side@r{, a buffer display action alist entry}
@item side
The value denotes the side of the frame or window where a new window
displaying the buffer shall be created.  This entry is used by
@code{display-buffer-in-side-window} to indicate the side of the frame
where a new side window shall be placed (@pxref{Displaying Buffers in
Side Windows}).  It is also used by
@code{display-buffer-in-atom-window} to indicate the side of an
existing window where the new window shall be located (@pxref{Atomic
Windows}).

@vindex slot@r{, a buffer display action alist entry}
@item slot
If non-@code{nil}, the value specifies the slot of the side window
supposed to display the buffer.  This entry is used only by
@code{display-buffer-in-side-window}.

@vindex direction@r{, a buffer display action alist entry}
@item direction
The value specifies a direction which, together with a @code{window}
entry, allows @code{display-buffer-in-direction} to determine the
location of the window to display the buffer.

@vindex window@r{, a buffer display action alist entry}
@item window
The value specifies a window that is in some way related to the window
chosen by @code{display-buffer}.  This entry is currently used by
@code{display-buffer-in-atom-window} to indicate the window on whose
side the new window shall be created.  It is also used by
@code{display-buffer-in-direction} to specify the reference window on
whose side the resulting window shall appear.

@vindex allow-no-window@r{, a buffer display action alist entry}
@item allow-no-window
If the value is non-@code{nil}, @code{display-buffer} does not
necessarily have to display the buffer and the caller is prepared to
accept that.  This entry is not intended for user customizations,
since there is no guarantee that an arbitrary caller of
@code{display-buffer} will be able to handle the case that no window
will display the buffer.  @code{display-buffer-no-window} is the only
action function that cares about this entry.

@vindex body-function@r{, a buffer display action alist entry}
@item body-function
The value must be a function taking one argument (a displayed window).
This function can be used to fill the displayed window's body with
some contents that might depend on dimensions of the displayed window.
It is called @emph{after} the buffer is displayed, and @emph{before}
the entries @code{window-height}, @code{window-width} and
@code{preserve-size} are applied that could resize the window to fit
it to the inserted contents.
@end table

By convention, the entries @code{window-height}, @code{window-width}
and @code{preserve-size} are applied after the chosen window's buffer
has been set up and if and only if that window never showed another
buffer before.  More precisely, the latter means that the window must
have been either created by the current @code{display-buffer} call or
the window was created earlier by @code{display-buffer} to show the
buffer and never was used to show another buffer until it was reused
by the current invocation of @code{display-buffer}.


@node Choosing Window Options
@subsection Additional Options for Displaying Buffers

The behavior of buffer display actions (@pxref{Choosing Window}) can
be further modified by the following user options.

@defopt pop-up-windows
If the value of this variable is non-@code{nil}, @code{display-buffer}
is allowed to split an existing window to make a new window for
displaying in.  This is the default.

This variable is provided for backward compatibility only.  It is
obeyed by @code{display-buffer} via a special mechanism in
@code{display-buffer-fallback-action}, which calls the action function
@code{display-buffer-pop-up-window} (@pxref{Buffer Display Action
Functions}) when the value of this option is non-@code{nil}.  It is
not consulted by @code{display-buffer-pop-up-window} itself, which the
user may specify directly in @code{display-buffer-alist} etc.
@end defopt

@defopt split-window-preferred-function
This variable specifies a function for splitting a window, in order to
make a new window for displaying a buffer.  It is used by the
@code{display-buffer-pop-up-window} action function to actually split
the window.

The value must be a function that takes one argument, a window, and
returns either a new window (which will be used to display the desired
buffer) or @code{nil} (which means the splitting failed).  The default
value is @code{split-window-sensibly}, which is documented next.
@end defopt

@defun split-window-sensibly &optional window
This function tries to split @var{window} and return the newly created
window.  If @var{window} cannot be split, it returns @code{nil}.  If
@var{window} is omitted or @code{nil}, it defaults to the selected
window.

This function obeys the usual rules that determine when a window may
be split (@pxref{Splitting Windows}).  It first tries to split by
placing the new window below, subject to the restriction imposed by
@code{split-height-threshold} (see below), in addition to any other
restrictions.  If that fails, it tries to split by placing the new
window to the right, subject to @code{split-width-threshold} (see
below).  If that also fails, and the window is the only window on its
frame, this function again tries to split and place the new window
below, disregarding @code{split-height-threshold}.  If this fails as
well, this function gives up and returns @code{nil}.
@end defun

@defopt split-height-threshold
This variable specifies whether @code{split-window-sensibly} is
allowed to split the window placing the new window below.  If it is an
integer, that means to split only if the original window has at least
that many lines.  If it is @code{nil}, that means not to split this
way.
@end defopt

@defopt split-width-threshold
This variable specifies whether @code{split-window-sensibly} is
allowed to split the window placing the new window to the right.  If
the value is an integer, that means to split only if the original
window has at least that many columns.  If the value is @code{nil},
that means not to split this way.
@end defopt

@defopt even-window-sizes
This variable, if non-@code{nil}, causes @code{display-buffer} to even
window sizes whenever it reuses an existing window, and that window is
adjacent to the selected one.

If its value is @code{width-only}, sizes are evened only if the reused
window is on the left or right of the selected one and the selected
window is wider than the reused one.  If its value is @code{height-only}
sizes are evened only if the reused window is above or beneath the
selected window and the selected window is higher than the reused one.
Any other non-@code{nil} value means to even sizes in any of these cases
provided the selected window is larger than the reused one in the sense
of their combination.
@end defopt

@defopt pop-up-frames
If the value of this variable is non-@code{nil}, that means
@code{display-buffer} may display buffers by making new frames.  The
default is @code{nil}.

A non-@code{nil} value also means that when @code{display-buffer} is
looking for a window already displaying @var{buffer-or-name}, it can
search any visible or iconified frame, not just the selected frame.

This variable is provided mainly for backward compatibility.  It is
obeyed by @code{display-buffer} via a special mechanism in
@code{display-buffer-fallback-action}, which calls the action function
@code{display-buffer-pop-up-frame} (@pxref{Buffer Display Action
Functions}) if the value is non-@code{nil}.  (This is done before
attempting to split a window.)  This variable is not consulted by
@code{display-buffer-pop-up-frame} itself, which the user may specify
directly in @code{display-buffer-alist} etc.
@end defopt

@defopt pop-up-frame-function
This variable specifies a function for creating a new frame, in order
to make a new window for displaying a buffer.  It is used by the
@code{display-buffer-pop-up-frame} action function.

The value should be a function that takes no arguments and returns a
frame, or @code{nil} if no frame could be created.  The default value
is a function that creates a frame using the parameters specified by
@code{pop-up-frame-alist} (see below).
@end defopt

@defopt pop-up-frame-alist
This variable holds an alist of frame parameters (@pxref{Frame
Parameters}), which is used by the function specified by
@code{pop-up-frame-function} to make a new frame.  The default is
@code{nil}.

This option is provided for backward compatibility only.  Note, that
when @code{display-buffer-pop-up-frame} calls the function specified
by @code{pop-up-frame-function}, it prepends the value of all
@code{pop-up-frame-parameters} action alist entries to
@code{pop-up-frame-alist} so that the values specified by the action
alist entry effectively override any corresponding values of
@code{pop-up-frame-alist}.

Hence, users should set up a @code{pop-up-frame-parameters} action
alist entry in @code{display-buffer-alist} instead of customizing
@code{pop-up-frame-alist}.  Only this will guarantee that the value of
a parameter specified by the user overrides the value of that
parameter specified by the caller of @code{display-buffer}.
@end defopt

   Many efforts in the design of @code{display-buffer} have been given
to maintain compatibility with code that uses older options like
@code{pop-up-windows}, @code{pop-up-frames},
@code{pop-up-frame-alist}, @code{same-window-buffer-names} and
@code{same-window-regexps}.  Lisp Programs and users should refrain
from using these options.  Above we already warned against customizing
@code{pop-up-frame-alist}.  Here we describe how to convert the
remaining options to use display actions instead.

@table @code
@item pop-up-windows
@vindex pop-up-windows@r{, replacement for}
This variable is @code{t} by default.  Instead of customizing it to
@code{nil} and thus telling @code{display-buffer} what not to do, it's
much better to list in @code{display-buffer-base-action} the action
functions it should try instead as, for example:

@example
@group
(customize-set-variable
 'display-buffer-base-action
 '((display-buffer-reuse-window display-buffer-same-window
    display-buffer-in-previous-window
    display-buffer-use-some-window)))
@end group
@end example

@item pop-up-frames
@vindex pop-up-frames@r{, replacement for}
Instead of customizing this variable to @code{t}, customize
@code{display-buffer-base-action}, for example, as follows:

@example
@group
(customize-set-variable
 'display-buffer-base-action
 '((display-buffer-reuse-window display-buffer-pop-up-frame)
   (reusable-frames . 0)))
@end group
@end example

@item same-window-buffer-names
@itemx same-window-regexps
@vindex same-window-buffer-names@r{, replacement for}
@vindex same-window-regexps@r{, replacement for}
Instead of adding a buffer name or a regular expression to one of
these options use a @code{display-buffer-alist} entry for that buffer
specifying the action function @code{display-buffer-same-window}.

@example
@group
(customize-set-variable
 'display-buffer-alist
 (cons '("\\*foo\\*" (display-buffer-same-window))
        display-buffer-alist))
@end group
@end example
@end table


@node Precedence of Action Functions
@subsection Precedence of Action Functions
@cindex precedence of buffer display action functions
@cindex execution order of buffer display action functions
@cindex buffer display action functions, precedence

From the past subsections we already know that @code{display-buffer}
must be supplied with a number of display actions (@pxref{Choosing
Window}) in order to display a buffer.  In a completely uncustomized
Emacs, these actions are specified by
@code{display-buffer-fallback-action} in the following order of
precedence: Reuse a window, pop up a new window on the same frame, use
a window previously showing the buffer, use some window and pop up a
new frame.  (Note that the remaining actions named by
@code{display-buffer-fallback-action} are void in an uncustomized
Emacs).

Consider the following form:

@example
(display-buffer (get-buffer-create "*foo*"))
@end example

@noindent
Evaluating this form in the buffer @file{*scratch*} of an uncustomized
Emacs session will usually fail to reuse a window that shows
@file{*foo*} already, but succeed in popping up a new window.
Evaluating the same form again will now not cause any visible
changes---@code{display-buffer} reused the window already showing
@file{*foo*} because that action was applicable and had the highest
precedence among all applicable actions.

   Popping up a new window will fail if there is not enough space on
the selected frame.  In an uncustomized Emacs it typically fails when
there are already two windows on a frame.  For example, if you now
type @w{@kbd{C-x 1}} followed by @w{@kbd{C-x 2}} and evaluate the form
once more, @file{*foo*} should show up in the lower
window---@code{display-buffer} just used ``some'' window.  If, before
typing @w{@kbd{C-x 2}} you had typed @w{@kbd{C-x o}}, @file{*foo*}
would have been shown in the upper window because ``some'' window
stands for the ``least recently used'' window and the selected window
has been least recently used if and only if it is alone on its frame.

   Let's assume you did not type @w{@kbd{C-x o}} and @file{*foo*} is
shown in the lower window.  Type @w{@kbd{C-x o}} to get there followed
by @w{@kbd{C-x left}} and evaluate the form again.  This should
display @file{*foo*} in the same, lower window because that window had
already shown @file{*foo*} previously and was therefore chosen instead
of some other window.

  So far we have only observed the default behavior in an uncustomized
Emacs session.  To see how this behavior can be customized, let's
consider the option @code{display-buffer-base-action}.  It provides a
very coarse customization which conceptually affects the display of
@emph{any} buffer.  It can be used to supplement the actions supplied
by @code{display-buffer-fallback-action} by reordering them or by
adding actions that are not present there but fit more closely the
user's editing practice.   However, it can also be used to change the
default behavior in a more profound way.

   Let's consider a user who, as a rule, prefers to display buffers on
another frame.  Such a user might provide the following customization:

@example
@group
(customize-set-variable
 'display-buffer-base-action
 '((display-buffer-reuse-window display-buffer-pop-up-frame)
   (reusable-frames . 0)))
@end group
@end example

@noindent
This setting will cause @code{display-buffer} to first try to find a
window showing the buffer on a visible or iconified frame and, if no
such frame exists, pop up a new frame.  You can observe this behavior
on a graphical system by typing @w{@kbd{C-x 1}} in the window showing
@file{*scratch*} and evaluating our canonical @code{display-buffer}
form.  This will usually create (and give focus to) a new frame whose
root window shows @file{*foo*}.  Iconify that frame and evaluate the
canonical form again: @code{display-buffer} will reuse the window on
the new frame (usually raising the frame and giving it focus too).

   Only if creating a new frame fails, @code{display-buffer} will
apply the actions supplied by @code{display-buffer-fallback-action}
which means to again try reusing a window, popping up a new window and
so on.  A trivial way to make frame creation fail is supplied by the
following form:

@example
@group
(let ((pop-up-frame-function 'ignore))
  (display-buffer (get-buffer-create "*foo*")))
@end group
@end example

@noindent
We will forget about that form immediately after observing that it
fails to create a new frame and uses a fallback action instead.

   Note that @code{display-buffer-reuse-window} appears redundant in
the customization of @code{display-buffer-base-action} because it is
already part of @code{display-buffer-fallback-action} and should be
tried there anyway.  However, that would fail because due to the
precedence of @code{display-buffer-base-action} over
@code{display-buffer-fallback-action}, at that time
@code{display-buffer-pop-up-frame} would have already won the race.
In fact, this:

@example
@group
(customize-set-variable
 'display-buffer-base-action
 '(display-buffer-pop-up-frame (reusable-frames . 0)))
@end group
@end example

@noindent
would cause @code{display-buffer} to @emph{always} pop up a new frame
which is probably not what our user wants.

   So far, we have only shown how @emph{users} can customize the
default behavior of @code{display-buffer}.  Let us now see how
@emph{applications} can change the course of @code{display-buffer}.
The canonical way to do that is to use the @var{action} argument of
@code{display-buffer} or a function that calls it, like, for example,
@code{pop-to-buffer} (@pxref{Switching Buffers}).

   Suppose an application wants to display @file{*foo*} preferably
below the selected window (to immediately attract the attention of the
user to the new window) or, if that fails, in a window at the bottom
of the frame.  It could do that with a call like this:

@example
@group
(display-buffer
 (get-buffer-create "*foo*")
 '((display-buffer-below-selected display-buffer-at-bottom)))
@end group
@end example

@noindent
In order to see how this new, modified form works, delete any frame
showing @file{*foo*}, type @w{@kbd{C-x 1}} followed by @w{@kbd{C-x 2}} in the
window showing @file{*scratch*}, and subsequently evaluate that form.
@code{display-buffer} should split the upper window, and show
@file{*foo*} in the new window.  Alternatively, if after @w{@kbd{C-x 2}}
you had typed @w{@kbd{C-x o}}, @code{display-buffer} would have split the
window at the bottom instead.

   Suppose now that, before evaluating the new form, you have made the
selected window as small as possible, for example, by evaluating the
form @code{(fit-window-to-buffer)} in that window.  In that case,
@code{display-buffer} would have failed to split the selected window
and would have split the frame's root window instead, effectively
displaying @file{*foo*} at the bottom of the frame.

   In either case, evaluating the new form a second time should reuse
the window already showing @file{*foo*} since both functions supplied
by the @var{action} argument try to reuse such a window first.

   By setting the @var{action} argument, an application effectively
overrules any customization of @code{display-buffer-base-action}.  Our
user can now either accept the choice of the application, or redouble
by customizing the option @code{display-buffer-alist} as follows:

@example
@group
(customize-set-variable
 'display-buffer-alist
 '(("\\*foo\\*"
    (display-buffer-reuse-window display-buffer-pop-up-frame))))
@end group
@end example

@noindent
Trying this with the new, modified form above in a configuration that
does not show @file{*foo*} anywhere, will display @file{*foo*} on a
separate frame, completely ignoring the @var{action} argument of
@code{display-buffer}.

   Note that we didn't care to specify a @code{reusable-frames} action
alist entry in our specification of @code{display-buffer-alist}.
@code{display-buffer} always takes the first one it finds---in our
case the one specified by @code{display-buffer-base-action}.  If we
wanted to use a different specification, for example, to exclude
iconified frames showing @file{*foo*} from the list of reusable ones,
we would have to specify that separately, however:

@example
@group
(customize-set-variable
 'display-buffer-alist
 '(("\\*foo\\*"
    (display-buffer-reuse-window display-buffer-pop-up-frame)
    (reusable-frames . visible))))
@end group
@end example

@noindent
If you try this, you will notice that repeated attempts to display
@file{*foo*} will succeed to reuse a frame only if that frame is
visible.

   The above example would allow the conclusion that users customize
@code{display-buffer-alist} for the sole purpose to overrule the
@var{action} argument chosen by applications.  Such a conclusion would
be incorrect.  @code{display-buffer-alist} is the standard option for
users to direct the course of display of specific buffers in a
preferred way regardless of whether the display is also guided by an
@var{action} argument.

   We can, however, reasonably conclude that customizing
@code{display-buffer-alist} differs from customizing
@code{display-buffer-base-action} in two major aspects: it is stronger
because it overrides the @var{action} argument of
@code{display-buffer}, and it allows to explicitly specify the
affected buffers.  In fact, displaying other buffers is not affected
in any way by a customization for @file{*foo*}.  For example,

@example
(display-buffer (get-buffer-create "*bar*"))
@end example

@noindent
continues being governed by the settings of
@code{display-buffer-base-action} and
@code{display-buffer-fallback-action} only.

   We could stop with our examples here but Lisp programs still have
an ace up their sleeves which they can use to overrule any
customization of @code{display-buffer-alist}.  It's the variable
@code{display-buffer-overriding-action} which they can bind around
@code{display-buffer} calls as follows:

@example
@group
(let ((display-buffer-overriding-action
       '((display-buffer-same-window))))
  (display-buffer
   (get-buffer-create "*foo*")
   '((display-buffer-below-selected display-buffer-at-bottom))))
@end group
@end example

@noindent
Evaluating this form will usually display @file{*foo*} in the selected
window regardless of the @var{action} argument and any user
customizations.  (Usually, an application will not bother to also
provide an @var{action} argument.  Here it just serves to illustrate
the fact that it gets overridden.)

It might be illustrative to look at the list of action functions
@code{display-buffer} would have tried to display @file{*foo*} with
the customizations we provided here.  The list (including comments
explaining who added this and the subsequent elements) is:

@example
@group
(display-buffer-same-window  ;; `display-buffer-overriding-action'
 display-buffer-reuse-window ;; `display-buffer-alist'
 display-buffer-pop-up-frame
 display-buffer-below-selected ;; ACTION argument
 display-buffer-at-bottom
 display-buffer-reuse-window ;; `display-buffer-base-action'
 display-buffer-pop-up-frame
 display-buffer--maybe-same-window ;; `display-buffer-fallback-action'
 display-buffer-reuse-window
 display-buffer--maybe-pop-up-frame-or-window
 display-buffer-in-previous-window
 display-buffer-use-some-window
 display-buffer-pop-up-frame)
@end group
@end example

@noindent
Note that among the internal functions listed here,
@code{display-buffer--maybe-same-window} is effectively ignored while
@code{display-buffer--maybe-pop-up-frame-or-window} actually runs
@code{display-buffer-pop-up-window}.

The action alist passed in each function call is:

@example
@group
((reusable-frames . visible)
 (reusable-frames . 0))
@end group
@end example

@noindent
which shows that we have used the second specification of
@code{display-buffer-alist} above, overriding the specification
supplied by @code{display-buffer-base-action}.  Suppose our user had
written that as

@example
@group
(customize-set-variable
 'display-buffer-alist
 '(("\\*foo\\*"
    (display-buffer-reuse-window display-buffer-pop-up-frame)
    (inhibit-same-window . t)
    (reusable-frames . visible))))
@end group
@end example

@noindent
In this case the @code{inhibit-same-window} alist entry will
successfully invalidate the @code{display-buffer-same-window}
specification from @code{display-buffer-overriding-action} and
@code{display-buffer} will show @file{*foo*} on another frame.  To
make @code{display-buffer-overriding-action} more robust in this
regard, the application would have to specify an appropriate
@code{inhibit-same-window} entry too, for example, as follows:

@example
@group
(let ((display-buffer-overriding-action
       '(display-buffer-same-window (inhibit-same-window . nil))))
  (display-buffer (get-buffer-create "*foo*")))
@end group
@end example

@noindent
This last example shows that while the precedence order of action
functions is fixed, as described in @ref{Choosing Window}, an action
alist entry specified by a display action ranked lower in that order
can affect the execution of a higher ranked display action.


@node The Zen of Buffer Display
@subsection The Zen of Buffer Display
@cindex guidelines for buffer display
@cindex writing buffer display actions
@cindex buffer display conventions

In its most simplistic form, a frame accommodates always one single
window that can be used for displaying a buffer.  As a consequence, it
is always the latest call of @code{display-buffer} that will have
succeeded in placing its buffer there.

   Since working with such a frame is not very practical, Emacs by
default allows for more complex frame layouts controlled by the
default values of the frame size and the @code{split-height-threshold}
and @code{split-width-threshold} options.  Displaying a buffer not yet
shown on a frame then either splits the single window on that frame or
(re-)uses one of its two windows.

   The default behavior is abandoned as soon as the user customizes
one of these thresholds or manually changes the frame's layout.  The
default behavior is also abandoned when calling @code{display-buffer}
with a non-@code{nil} @var{action} argument or the user customizes one
of the options mentioned in the previous subsections.  Mastering
@code{display-buffer} soon may become a frustrating experience due to
the plethora of applicable display actions and the resulting frame
layouts.

   However, refraining from using buffer display functions and falling
back on a split & delete windows metaphor is not a good idea either.
Buffer display functions give Lisp programs and users a framework to
reconcile their different needs; no comparable framework exists for
splitting and deleting windows.  Buffer display functions also allow
to at least partially restore the layout of a frame when removing a
buffer from it later (@pxref{Quitting Windows}).

   Below we will give a number of guidelines to redeem the frustration
mentioned above and thus to avoid literally losing buffers in-between
the windows of a frame.

@table @asis
@item Write display actions without stress
Writing display actions can be a pain because one has to lump together
action functions and action alists in one huge list.  (Historical
reasons prevented us from having @code{display-buffer} support
separate arguments for these.)  It might help to memorize some basic
forms like the ones listed below:

@example
'(nil (inhibit-same-window . t))
@end example

@noindent
specifies an action alist entry only and no action function.  Its sole
purpose is to inhibit a @code{display-buffer-same-window} function
specified elsewhere from showing the buffer in the same window, see
also the last example of the preceding subsection.

@example
'(display-buffer-below-selected)
@end example

@noindent
on the other hand, specifies one action function and an empty action
alist.  To combine the effects of the above two specifications one
would write the form

@example
'(display-buffer-below-selected (inhibit-same-window . t))
@end example

@noindent
to add another action function one would write

@example
@group
'((display-buffer-below-selected display-buffer-at-bottom)
  (inhibit-same-window . t))
@end group
@end example

@noindent
and to add another alist entry one would write

@example
@group
'((display-buffer-below-selected display-buffer-at-bottom)
  (inhibit-same-window . t)
  (window-height . fit-window-to-buffer))
@end group
@end example

@noindent
That last form can be used as @var{action} argument of
@code{display-buffer} in the following way:

@example
@group
(display-buffer
 (get-buffer-create "*foo*")
 '((display-buffer-below-selected display-buffer-at-bottom)
   (inhibit-same-window . t)
   (window-height . fit-window-to-buffer)))
@end group
@end example

@noindent
In a customization of @code{display-buffer-alist} it would be used as
follows:

@example
@group
(customize-set-variable
 'display-buffer-alist
 '(("\\*foo\\*"
    (display-buffer-below-selected display-buffer-at-bottom)
    (inhibit-same-window . t)
    (window-height . fit-window-to-buffer))))
@end group
@end example

@noindent
To add a customization for a second buffer one would then write:

@example
@group
(customize-set-variable
 'display-buffer-alist
 '(("\\*foo\\*"
    (display-buffer-below-selected display-buffer-at-bottom)
    (inhibit-same-window . t)
    (window-height . fit-window-to-buffer))
   ("\\*bar\\*"
    (display-buffer-reuse-window display-buffer-pop-up-frame)
    (reusable-frames . visible))))
@end group
@end example

@item Treat each other with respect
@code{display-buffer-alist} and @code{display-buffer-base-action} are
user options---Lisp programs must never set or rebind them.
@code{display-buffer-overriding-action}, on the other hand, is
reserved for applications---who seldom use that option and if they use
it, then with utmost care.

   Older implementations of @code{display-buffer} frequently caused
users and applications to fight over the settings of user options like
@code{pop-up-frames} and @code{pop-up-windows} (@pxref{Choosing Window
Options}).  This was one major reason for redesigning
@code{display-buffer}---to provide a clear framework specifying what
users and applications should be allowed to do.

   Lisp programs must be prepared that user customizations may
cause buffers to get displayed in an unexpected way.  They should
never assume in their subsequent behavior, that the buffer has been
shown precisely the way they asked for in the @var{action} argument of
@code{display-buffer}.

   Users should not pose too many and too severe restrictions on how
arbitrary buffers get displayed.  Otherwise, they will risk to lose
the characteristics of showing a buffer for a certain purpose.
Suppose a Lisp program has been written to compare different versions
of a buffer in two windows side-by-side.  If the customization of
@code{display-buffer-alist} prescribes that any such buffer should be
always shown in or below the selected window, the program will have a
hard time to set up the desired window configuration via
@code{display-buffer}.

   To specify a preference for showing an arbitrary buffer, users
should customize @code{display-buffer-base-action}.  An example of how
users who prefer working with multiple frames would do that was given
in the previous subsection.  @code{display-buffer-alist} should be
reserved for displaying specific buffers in a specific way.

@item Consider reusing a window that already shows the buffer
Generally, it's always a good idea for users and Lisp
programmers to be prepared for the case that a window already shows
the buffer in question and to reuse that window.  In the preceding
subsection we have shown that failing to do so properly may cause
@code{display-buffer} to continuously pop up a new frame although a
frame showing that buffer existed already.  In a few cases only, it
might be undesirable to reuse a window, for example, when a different
portion of the buffer should be shown in that window.

   Hence, @code{display-buffer-reuse-window} is one action function
that should be used as often as possible, both in @var{action}
arguments and customizations.  An @code{inhibit-same-window} entry in
the @var{action} argument usually takes care of the most common case
where reusing a window showing the buffer should be avoided---that
where the window in question is the selected one.

@item Attract focus to the window chosen
This is a no-brainer for people working with multiple frames---the
frame showing the buffer will automatically raise and get focus unless
an @code{inhibit-switch-frame} entry forbids it.  For single frame
users this task can be considerably more difficult.  In particular,
@code{display-buffer-pop-up-window} and
@code{display-buffer-use-some-window} can become obtrusive in this
regard.  They split or use a seemingly arbitrary (often the largest or
least recently used) window, distracting the user's attention.

Some Lisp programs therefore try to choose a window at the bottom of
the frame, for example, in order to display the buffer in vicinity of
the minibuffer window where the user is expected to answer a question
related to the new window.  For non-input related actions
@code{display-buffer-below-selected} might be preferable because the
selected window usually already has the user's attention.

@item Handle subsequent invocations of @code{display-buffer}
@code{display-buffer} is not overly well suited for displaying several
buffers in sequence and making sure that all these buffers are shown
orderly in the resulting window configuration.  Again, the standard
action functions @code{display-buffer-pop-up-window} and
@code{display-buffer-use-some-window} are not very suited for this
purpose due to their somewhat chaotic nature in more complex
configurations.

   To produce a window configuration displaying multiple buffers (or
different views of one and the same buffer) in one and the same
display cycle, Lisp programmers will unavoidably have to write
their own action functions.  A few tricks listed below might help in
this regard.

@itemize @bullet
@item
Making windows atomic (@pxref{Atomic Windows}) avoids breaking an
existing window composition when popping up a new window.
The new window will pop up outside the composition instead.

@item
Temporarily dedicating windows to their buffers (@pxref{Dedicated
Windows}) avoids using a window for displaying a different
buffer.  A non-dedicated window will be used instead.

@item
Calling @code{window-preserve-size} (@pxref{Preserving Window Sizes})
will try to keep the size of the argument window unchanged when
popping up a new window.  You have to make sure that another window in
the same combination can be shrunk instead, though.

@item
Side windows (@pxref{Side Windows}) can be used for displaying
specific buffers always in a window at the same position of a frame.
This permits grouping buffers that do not compete for being shown at
the same time on a frame and showing any such buffer in the same window
without disrupting the display of other buffers.

@item
Child frames (@pxref{Child Frames}) can be used to display a buffer
within the screen estate of the selected frame without disrupting that
frame's window configuration and without the overhead associated with
full-fledged frames as inflicted by @code{display-buffer-pop-up-frame}.
@end itemize
@end table


@node 窗口历史记录
@section Window History
@cindex window history

Each window remembers in a list the buffers it has previously
displayed, and the order in which these buffers were removed from it.
This history is used, for example, by @code{replace-buffer-in-windows}
(@pxref{Buffers and Windows}), and when quitting windows
(@pxref{Quitting Windows}).  The list is automatically maintained by
Emacs, but you can use the following functions to explicitly inspect
or alter it:

@defun window-prev-buffers &optional window
This function returns a list specifying the previous contents of
@var{window}.  The optional argument @var{window} should be a live
window and defaults to the selected one.

Each list element has the form @code{(@var{buffer} @var{window-start}
@var{window-pos})}, where @var{buffer} is a buffer previously shown in
the window, @var{window-start} is the window start position
(@pxref{Window Start and End}) when that buffer was last shown, and
@var{window-pos} is the point position (@pxref{Window Point}) when
that buffer was last shown in @var{window}.

The list is ordered so that earlier elements correspond to more
recently-shown buffers, and the first element usually corresponds to the
buffer most recently removed from the window.
@end defun

@defun set-window-prev-buffers window prev-buffers
This function sets @var{window}'s previous buffers to the value of
@var{prev-buffers}.  The argument @var{window} must be a live window
and defaults to the selected one.  The argument @var{prev-buffers}
should be a list of the same form as that returned by
@code{window-prev-buffers}.
@end defun

In addition, each window maintains a list of @dfn{next buffers}, which
is a list of buffers re-shown by @code{switch-to-prev-buffer} (see
below).  This list is mainly used by @code{switch-to-prev-buffer} and
@code{switch-to-next-buffer} for choosing buffers to switch to.

@defun window-next-buffers &optional window
This function returns the list of buffers recently re-shown in
@var{window} via @code{switch-to-prev-buffer}.  The @var{window}
argument must denote a live window or @code{nil} (meaning the selected
window).
@end defun

@defun set-window-next-buffers window next-buffers
This function sets the next buffer list of @var{window} to
@var{next-buffers}.  The @var{window} argument should be a live window
or @code{nil} (meaning the selected window).  The argument
@var{next-buffers} should be a list of buffers.
@end defun

The following commands can be used to cycle through the global buffer
list, much like @code{bury-buffer} and @code{unbury-buffer}.  However,
they cycle according to the specified window's history list, rather
than the global buffer list.  In addition, they restore
window-specific window start and point positions, and may show a
buffer even if it is already shown in another window.  The
@code{switch-to-prev-buffer} command, in particular, is used by
@code{replace-buffer-in-windows}, @code{bury-buffer} and
@code{quit-window} to find a replacement buffer for a window.

@deffn Command switch-to-prev-buffer &optional window bury-or-kill
This command displays the previous buffer in @var{window}.  The
argument @var{window} should be a live window or @code{nil} (meaning
the selected window).  If the optional argument @var{bury-or-kill} is
non-@code{nil}, this means that the buffer currently shown in
@var{window} is about to be buried or killed and consequently should
not be switched to in future invocations of this command.

The previous buffer is usually the buffer shown before the buffer
currently shown in @var{window}.  However, a buffer that has been buried
or killed, or has been already shown by a recent invocation of
@code{switch-to-prev-buffer}, does not qualify as previous buffer.

If repeated invocations of this command have already shown all buffers
previously shown in @var{window}, further invocations will show buffers
from the buffer list of the frame @var{window} appears on (@pxref{Buffer
List}).

The option @code{switch-to-prev-buffer-skip} described below can be
used to inhibit switching to certain buffers, for example, to those
already shown in another window.  Also, if @var{window}'s frame has a
@code{buffer-predicate} parameter (@pxref{Buffer Parameters}), that
predicate may inhibit switching to certain buffers.
@end deffn

@deffn Command switch-to-next-buffer &optional window
This command switches to the next buffer in @var{window}, thus undoing
the effect of the last @code{switch-to-prev-buffer} command in
@var{window}.  The argument @var{window} must be a live window and
defaults to the selected one.

If there is no recent invocation of @code{switch-to-prev-buffer} that
can be undone, this function tries to show a buffer from the buffer list
of the frame @var{window} appears on (@pxref{Buffer List}).

The option @code{switch-to-prev-buffer-skip} and the
@code{buffer-predicate} (@pxref{Buffer Parameters}) of @var{window}'s
frame affect this command as they do for @code{switch-to-prev-buffer}.
@end deffn

By default @code{switch-to-prev-buffer} and
@code{switch-to-next-buffer} can switch to a buffer that is already
shown in another window.  The following option can be used to override
this behavior.

@defopt switch-to-prev-buffer-skip
If this variable is @code{nil}, @code{switch-to-prev-buffer} may
switch to any buffer, including those already shown in other windows.

If this variable is non-@code{nil}, @code{switch-to-prev-buffer} will
refrain from switching to certain buffers.  The following values can
be used:

@itemize @bullet
@item
@code{this} means do not switch to a buffer shown on the frame that
hosts the window @code{switch-to-prev-buffer} is acting upon.

@item
@code{visible} means do not switch to a buffer shown on any visible
frame.

@item
0 (the number zero) means do not switch to a buffer shown on any
visible or iconified frame.

@item
@code{t} means do not switch to a buffer shown on any live frame.

@item
A function that takes three arguments---the @var{window} argument of
@code{switch-to-prev-buffer}, a buffer @code{switch-to-prev-buffer}
intends to switch to and the @var{bury-or-kill} argument of
@code{switch-to-prev-buffer}.  If that function returns
non-@code{nil}, @code{switch-to-prev-buffer} will refrain from
switching to the buffer specified by the second argument.
@end itemize

The command @code{switch-to-next-buffer} obeys this option in a
similar way.  If this option specifies a function,
@code{switch-to-next-buffer} will call that function with the third
argument always @code{nil}.

Note that since @code{switch-to-prev-buffer} is called by
@code{bury-buffer}, @code{replace-buffer-in-windows} and
@code{quit-restore-window} as well, customizing this option may also
affect the behavior of Emacs when a window is quit or a buffer gets
buried or killed.

Note also that under certain circumstances
@code{switch-to-prev-buffer} and @code{switch-to-next-buffer} may
ignore this option, for example, when there is only one buffer left
these functions can switch to.
@end defopt


@node 专用窗口
@section Dedicated Windows
@cindex dedicated window

Functions for displaying a buffer can be told to not use specific
windows by marking these windows as @dfn{dedicated} to their buffers.
@code{display-buffer} (@pxref{Choosing Window}) never uses a dedicated
window for displaying another buffer in it.  @code{get-lru-window} and
@code{get-largest-window} (@pxref{Cyclic Window Ordering}) do not
consider dedicated windows as candidates when their @var{dedicated}
argument is non-@code{nil}.  The behavior of @code{set-window-buffer}
(@pxref{Buffers and Windows}) with respect to dedicated windows is
slightly different, see below.

   Functions supposed to remove a buffer from a window or a window from
a frame can behave specially when a window they operate on is dedicated.
We will distinguish three basic cases, namely where (1) the window is
not the only window on its frame, (2) the window is the only window on
its frame but there are other frames on the same terminal left, and (3)
the window is the only window on the only frame on the same terminal.

   In particular, @code{delete-windows-on} (@pxref{Deleting Windows})
handles case (2) by deleting the associated frame and case (3) by
showing another buffer in that frame's only window.  The function
@code{replace-buffer-in-windows} (@pxref{Buffers and Windows}) which is
called when a buffer gets killed, deletes the window in case (1) and
behaves like @code{delete-windows-on} otherwise.
@c FIXME: Does replace-buffer-in-windows _delete_ a window in case (1)?

   When @code{bury-buffer} (@pxref{Buffer List}) operates on the
selected window (which shows the buffer that shall be buried), it
handles case (2) by calling @code{frame-auto-hide-function}
(@pxref{Quitting Windows}) to deal with the selected frame.  The other
two cases are handled as with @code{replace-buffer-in-windows}.

@defun window-dedicated-p &optional window
This function returns non-@code{nil} if @var{window} is dedicated to its
buffer and @code{nil} otherwise.  More precisely, the return value is
the value assigned by the last call of @code{set-window-dedicated-p} for
@var{window}, or @code{nil} if that function was never called with
@var{window} as its argument.  The default for @var{window} is the
selected window.
@end defun

@defun set-window-dedicated-p window flag
This function marks @var{window} as dedicated to its buffer if
@var{flag} is non-@code{nil}, and non-dedicated otherwise.

As a special case, if @var{flag} is @code{t}, @var{window} becomes
@dfn{strongly} dedicated to its buffer.  @code{set-window-buffer}
signals an error when the window it acts upon is strongly dedicated to
its buffer and does not already display the buffer it is asked to
display.  Other functions do not treat @code{t} differently from any
non-@code{nil} value.
@end defun

You can also tell @code{display-buffer} to mark a window it creates as
dedicated to its buffer by providing a suitable @code{dedicated}
action alist entry (@pxref{Buffer Display Action Alists}).

@node 退出窗口
@section Quitting Windows

When you want to get rid of a window used for displaying a buffer, you
can call @code{delete-window} or @code{delete-windows-on}
(@pxref{Deleting Windows}) to remove that window from its frame.  If the
buffer is shown on a separate frame, you might want to call
@code{delete-frame} (@pxref{Deleting Frames}) instead.  If, on the other
hand, a window has been reused for displaying the buffer, you might
prefer showing the buffer previously shown in that window, by calling the
function @code{switch-to-prev-buffer} (@pxref{Window History}).
Finally, you might want to either bury (@pxref{Buffer List}) or kill
(@pxref{Killing Buffers}) the window's buffer.

   The following command uses information on how the window for
displaying the buffer was obtained in the first place, thus attempting
to automate the above decisions for you.

@deffn Command quit-window &optional kill window
This command quits @var{window} and buries its buffer.  The argument
@var{window} must be a live window and defaults to the selected one.
With prefix argument @var{kill} non-@code{nil}, it kills the buffer
instead of burying it.  It calls the function @code{quit-restore-window}
described next to deal with the window and its buffer.

@vindex quit-window-hook
The functions in @code{quit-window-hook} are run before doing anything
else.
@end deffn

@defun quit-restore-window &optional window bury-or-kill
This function handles @var{window} and its buffer after quitting.  The
optional argument @var{window} must be a live window and defaults to
the selected one. The function's behavior is determined by the four
elements of the list specified by @var{window}'s @code{quit-restore}
parameter (@pxref{Window Parameters}).

The first element of the @code{quit-restore} parameter is one of the
symbols @code{window}, meaning that the window has been specially
created by @code{display-buffer}; @code{frame}, a separate frame has
been created; @code{same}, the window has only ever displayed this
buffer; or @code{other}, the window showed another buffer before.
@code{frame} and @code{window} affect how the window is quit, while
@code{same} and @code{other} affect the redisplay of buffers
previously shown in @var{window}.

The parameter's second element is either one of the symbols
@code{window} or @code{frame}, or a list whose elements are the buffer
shown in @var{window} before, that buffer's window start and window
point positions, and @var{window}'s height at that time.  If that
buffer is still live when @var{window} is quit, then this function may
reuse @var{window} to display it.

The third element is the window selected at the time the parameter was
created.  If this function deletes @var{window}, it subsequently tries
to reselect the window named by that element.

The fourth element is the buffer whose display caused the creation of
this parameter.  This function may delete @var{window} if and only if
it still shows that buffer.

This function will try to delete @var{window} if and only if (1) the
first element of its @code{quit-restore} parameter is either
@code{window} or @code{frame}, (2) the window has no history of
previously-displayed buffers and (3) the fourth element of the
@code{quit-restore} parameter specifies the buffer currently displayed
in @var{window}.  If @var{window} is part of an atomic window
(@pxref{Atomic Windows}), it will try to delete the root of that
atomic window instead.  In either case, it tries to avoid signaling an
error when @var{window} cannot be deleted.

If @var{window} shall be deleted, is the only window on its frame and
there are other frames on that frame's terminal, the value of the
optional argument @var{bury-or-kill} determines how to proceed with
the window.  If @var{bury-or-kill} equals @code{kill}, the frame is
deleted unconditionally.  Otherwise, the fate of the frame is
determined by calling @code{frame-auto-hide-function} (see below) with
that frame as sole argument.

If the third element of the @code{quit-restore} parameter is a list of
buffer, window start (@pxref{Window Start and End}), and point
(@pxref{Window Point}), and that buffer is still live, the buffer will
be displayed, and start and point set accordingly.  If, in addition,
@var{window}'s buffer was temporarily resized, this function will also
try to restore the original height of @var{window}.

Otherwise, if @var{window} was previously used for displaying other
buffers (@pxref{Window History}), the most recent buffer in that
history will be displayed.  In either case, if @var{window} is not
deleted, its @code{quit-restore} parameter is reset to @code{nil}.

The optional argument @var{bury-or-kill} specifies how to deal with
@var{window}'s buffer.  The following values are handled:

@table @code
@item nil
This means to not deal with the buffer in any particular way.  As a
consequence, if @var{window} is not deleted, invoking
@code{switch-to-prev-buffer} will usually show the buffer again.

@item append
This means that if @var{window} is not deleted, its buffer is moved to
the end of @var{window}'s list of previous buffers, so it's less likely
that a future invocation of @code{switch-to-prev-buffer} will switch to
it.  Also, it moves the buffer to the end of the frame's buffer list.

@item bury
This means that if @var{window} is not deleted, its buffer is removed
from @var{window}'s list of previous buffers.  Also, it moves the buffer
to the end of the frame's buffer list.  This value provides the most
reliable remedy to not have @code{switch-to-prev-buffer} switch to this
buffer again without killing the buffer.

@item kill
This means to kill @var{window}'s buffer.
@end table

Typically, the display routines run by @code{display-buffer} will set
the @code{quit-restore} window parameter correctly.  It's also
possible to set it manually, using the following code for displaying
@var{buffer} in @var{window}:

@example
@group
(display-buffer-record-window type window buffer)

(set-window-buffer window buffer)

(set-window-prev-buffers window nil)
@end group
@end example

Setting the window history to @code{nil} ensures that a future call to
@code{quit-window} can delete the window altogether.

@end defun

The following option specifies how to deal with a frame containing just
one window that should be either quit, or whose buffer should be buried.

@defopt frame-auto-hide-function
The function specified by this option is called to automatically hide
frames.  This function is called with one argument---a frame.

The function specified here is called by @code{bury-buffer}
(@pxref{Buffer List}) when the selected window is dedicated and shows
the buffer to bury.  It is also called by @code{quit-restore-window}
(see above) when the frame of the window to quit has been specially
created for displaying that window's buffer and the buffer is not
killed.

The default is to call @code{iconify-frame} (@pxref{Visibility of
Frames}).  Alternatively, you may specify either @code{delete-frame}
(@pxref{Deleting Frames}) to remove the frame from its display,
@code{make-frame-invisible} to make the frame invisible, @code{ignore}
to leave the frame unchanged, or any other function that can take a
frame as its sole argument.

Note that the function specified by this option is called only if the
specified frame contains just one live window and there is at least one
other frame on the same terminal.

For a particular frame, the value specified here may be overridden by
that frame's @code{auto-hide-function} frame parameter (@pxref{Frame
Interaction Parameters}).
@end defopt


@node 侧边窗口
@section Side Windows
@cindex side windows
@cindex main window
@cindex main window of a frame

Side windows are special windows positioned at any of the four sides of
a frame's root window (@pxref{窗口和窗框}).  In practice, this
means that the area of the frame's root window is subdivided into a main
window and a number of side windows surrounding that main window.  The
main window is either a ``normal'' live window or specifies the area
containing all the normal windows.

   In their most simple form of use, side windows allow to display
specific buffers always in the same area of a frame.  Hence they can
be regarded as a generalization of the concept provided by
@code{display-buffer-at-bottom} (@pxref{Buffer Display Action
Functions}) to the remaining sides of a frame.  With suitable
customizations, however, side windows can be also used to provide
frame layouts similar to those found in so-called integrated
development environments (IDEs).

@menu
* Displaying Buffers in Side Windows:: An action function for displaying
                              buffers in side windows.
* Side Window Options and Functions:: Further tuning of side windows.
* Frame Layouts with Side Windows:: Setting up frame layouts with side
                              windows.
@end menu


@node Displaying Buffers in Side Windows
@subsection Displaying Buffers in Side Windows

The following action function for @code{display-buffer} (@pxref{Buffer
Display Action Functions}) creates or reuses a side window for
displaying the specified buffer.

@defun display-buffer-in-side-window buffer alist
This function displays @var{buffer} in a side window of the selected
frame.  It returns the window used for displaying @var{buffer},
@code{nil} if no such window can be found or created.

@var{alist} is an association list of symbols and values as for
@code{display-buffer}.  The following symbols in @var{alist} are special
for this function:

@table @code
@item side
Denotes the side of the frame where the window shall be located.  Valid
values are @code{left}, @code{top}, @code{right} and @code{bottom}.  If
unspecified, the window is located at the bottom of the frame.

@item slot
Denotes a slot at the specified side where to locate the window.  A
value of zero means to preferably position the window in the middle of
the specified side.  A negative value means to use a slot preceding
(that is, above or on the left of) the middle slot.  A positive value
means to use a slot following (that is, below or on the right of) the
middle slot.  Hence, all windows on a specific side are ordered by their
@code{slot} value.  If unspecified, the window is located in the middle
of the specified side.
@end table

If you specify the same slot on the same side for two or more different
buffers, the buffer displayed last is shown in the corresponding window.
Hence, slots can be used for sharing the same side window between
buffers.

This function installs the @code{window-side} and @code{window-slot}
parameters (@pxref{Window Parameters}) and makes them persistent.  It
does not install any other window parameters unless they have been
explicitly provided via a @code{window-parameters} entry in @var{alist}.
@end defun

By default, side windows cannot be split via @code{split-window}
(@pxref{Splitting Windows}).  Also, a side window is not reused or
split by any buffer display action (@pxref{Buffer Display Action
Functions}) unless it is explicitly specified as target of that
action.  Note also that @code{delete-other-windows} cannot make a side
window the only window on its frame (@pxref{Deleting Windows}).

   Once set up, side windows also change the behavior of the commands
@code{switch-to-prev-buffer} and @code{switch-to-next-buffer}
(@pxref{Window History}).  In particular, these commands will refrain
from showing, in a side window, buffers that have not been displayed in
that window before.  They will also refrain from having a normal,
non-side window show a buffer that has been already displayed in a side
window.  A notable exception to the latter rule occurs when an
application, after displaying a buffer, resets that buffer's local
variables.


@node Side Window Options and Functions
@subsection Side Window Options and Functions

The following options provide additional control over the placement of
side windows.

@defopt window-sides-vertical
If non-@code{nil}, the side windows on the left and right of a frame
occupy the frame's full height.  Otherwise, the side windows on the top
and bottom of the frame occupy the frame's full width.
@end defopt

@defopt window-sides-slots
This option specifies the maximum number of side windows on each side of
a frame.  The value is a list of four elements specifying the number of
side window slots on (in this order) the left, top, right and bottom of
each frame.  If an element is a number, it means to display at most that
many windows on the corresponding side.  If an element is @code{nil}, it
means there's no bound on the number of slots on that side.

If any of the specified values is zero, no window can be created on the
corresponding side.  @code{display-buffer-in-side-window} will not
signal an error in that case, but will return @code{nil}.  If a specified
value just forbids the creation of an additional side window, the most
suitable window on that side is reused and may have its
@code{window-slot} parameter changed accordingly.
@end defopt

@defopt window-sides-reversed
This option specifies whether top/bottom side windows should appear in
reverse order.  When this is @code{nil}, side windows on the top and
bottom of a frame are always drawn from left to right with increasing
slot values.  When this is @code{t}, the drawing order is reversed and
side windows on the top and bottom of a frame are drawn from right to
left with increasing slot values.

When this is @code{bidi}, the drawing order is reversed if and only if
the value of @code{bidi-paragraph-direction} (@pxref{Bidirectional
Display}) is @code{right-to-left} in the buffer displayed in the window
most recently selected within the main window area of this frame.
Sometimes that window may be hard to find, so heuristics are used to
avoid that the drawing order changes inadvertently when another window
gets selected.

The layout of side windows on the left or right of a frame is not
affected by the value of this variable.
@end defopt

When a frame has side windows, the following function returns the main
window of that frame.

@defun window-main-window &optional frame
This function returns the main window of the specified @var{frame}.  The
optional argument @var{frame} must be a live frame and defaults to the
selected one.

If @var{frame} has no side windows, it returns @var{frame}'s root
window.  Otherwise, it returns either an internal non-side window such
that all other non-side windows on @var{frame} descend from it, or the
single live non-side window of @var{frame}.  Note that the main window
of a frame cannot be deleted via @code{delete-window}.
@end defun

The following command is handy to toggle the appearance of all side
windows on a specified frame.

@deffn Command window-toggle-side-windows &optional frame
This command toggles side windows on the specified @var{frame}.  The
optional argument @var{frame} must be a live frame and defaults to the
selected one.

If @var{frame} has at least one side window, this command saves the
state of @var{frame}'s root window in the @var{frame}'s
@code{window-state} frame parameter and deletes all side windows on
@var{frame} afterwards.

If @var{frame} has no side windows, but does have a @code{window-state}
parameter, this command uses that parameter's value to restore the side
windows on @var{frame} leaving @var{frame}'s main window alone.

An error is signaled if @var{frame} has no side windows and no saved
state is found for it.
@end deffn


@node Frame Layouts with Side Windows
@subsection Frame Layouts with Side Windows

Side windows can be used to create more complex frame layouts like those
provided by integrated development environments (IDEs).  In such
layouts, the area of the main window is where the normal editing
activities take place.  Side windows are not conceived for editing in
the usual sense.  Rather, they are supposed to display information
complementary to the current editing activity, like lists of files, tags
or buffers, help information, search or grep results or shell output.

   The layout of such a frame might appear as follows:

@smallexample
@group
     ___________________________________
    |          *Buffer List*            |
    |___________________________________|
    |     |                       |     |
    |  *  |                       |  *  |
    |  d  |                       |  T  |
    |  i  |                       |  a  |
    |  r  |   Main Window Area    |  g  |
    |  e  |                       |  s  |
    |  d  |                       |  *  |
    |  *  |                       |     |
    |_____|_______________________|_____|
    | *help*/*grep*/  |  *shell*/       |
    | *Completions*   |  *compilation*  |
    |_________________|_________________|
    |             Echo Area             |
    |___________________________________|


@end group
@end smallexample

The following example illustrates how window parameters (@pxref{Window
Parameters}) can be used with @code{display-buffer-in-side-window}
(@pxref{Displaying Buffers in Side Windows}) to set up code for
producing the frame layout sketched above.

@example
@group
(defvar parameters
  '(window-parameters . ((no-other-window . t)
                         (no-delete-other-windows . t))))

(setq fit-window-to-buffer-horizontally t)
(setq window-resize-pixelwise t)

(setq
 display-buffer-alist
 `(("\\*Buffer List\\*" display-buffer-in-side-window
    (side . top) (slot . 0) (window-height . fit-window-to-buffer)
    (preserve-size . (nil . t)) ,parameters)
   ("\\*Tags List\\*" display-buffer-in-side-window
    (side . right) (slot . 0) (window-width . fit-window-to-buffer)
    (preserve-size . (t . nil)) ,parameters)
   ("\\*\\(?:help\\|grep\\|Completions\\)\\*"
    display-buffer-in-side-window
    (side . bottom) (slot . -1) (preserve-size . (nil . t))
    ,parameters)
   ("\\*\\(?:shell\\|compilation\\)\\*" display-buffer-in-side-window
    (side . bottom) (slot . 1) (preserve-size . (nil . t))
    ,parameters)))
@end group
@end example

This specifies @code{display-buffer-alist} entries (@pxref{Choosing
Window}) for buffers with fixed names.  In particular, it asks for
showing @file{*Buffer List*} with adjustable height at the top of the
frame and @file{*Tags List*} with adjustable width on the frame's right.
It also asks for having the @file{*help*}, @file{*grep*} and
@file{*Completions*} buffers share a window on the bottom left side of
the frame and the @file{*shell*} and @file{*compilation*} buffers appear
in a window on the bottom right side of the frame.

   Note that the option @code{fit-window-to-buffer-horizontally} must
have a non-@code{nil} value in order to allow horizontal adjustment of
windows.  Entries are also added that ask for preserving the height of
side windows at the top and bottom of the frame and the width of side
windows at the left or right of the frame.  To assure that side windows
retain their respective sizes when maximizing the frame, the variable
@code{window-resize-pixelwise} is set to a non-@code{nil} value.
@xref{Resizing Windows}.

   The last form also makes sure that none of the created side windows
are accessible via @w{@kbd{C-x o}} by installing the @code{no-other-window}
parameter for each of these windows.  In addition, it makes sure that
side windows are not deleted via @w{@kbd{C-x 1}} by installing the
@code{no-delete-other-windows} parameter for each of these windows.

   Since @code{dired} buffers have no fixed names, we use a special
function @code{dired-default-directory-on-left} in order to display a
lean directory buffer on the left side of the frame.

@example
@group
(defun dired-default-directory-on-left ()
  "Display `default-directory' in side window on left, hiding details."
  (interactive)
  (let ((buffer (dired-noselect default-directory)))
    (with-current-buffer buffer (dired-hide-details-mode t))
    (display-buffer-in-side-window
     buffer `((side . left) (slot . 0)
              (window-width . fit-window-to-buffer)
              (preserve-size . (t . nil)) ,parameters))))
@end group
@end example

Evaluating the preceding forms and typing, in any order, @w{@kbd{M-x
list-buffers}}, @kbd{C-h f}, @kbd{M-x shell}, @w{@kbd{M-x list-tags}},
and @kbd{M-x dired-default-directory-on-left} should now reproduce the
frame layout sketched above.


@node 原子窗口
@section Atomic Windows
@cindex atomic windows

Atomic windows are rectangular compositions of at least two live
windows.  They have the following distinctive characteristics:

@itemize @bullet
@item
The function @code{split-window} (@pxref{Splitting Windows}), when
applied to a constituent of an atomic window, will try to create the new
window outside of the atomic window.

@item
The function @code{delete-window} (@pxref{Deleting Windows}), when
applied to a constituent of an atomic window, will try to delete the
entire atomic window instead.

@item
The function @code{delete-other-windows} (@pxref{Deleting Windows}),
when applied to a constituent of an atomic window, will try to make the
atomic window fill its frame or main window (@pxref{Side Windows}).
@end itemize

This means that the basic groups of functions that alter the window
structure treat an atomic window like a live one, thus preserving the
internal structure of the atomic window.

   Atomic windows are useful to construct and preserve window layouts
that are meaningful only when all involved buffers are shown
simultaneously in a specific manner, such as when showing differences
between file revisions, or the same text in different languages or
markups.  They can also be used to permanently display information
pertinent to a specific window in bars on that window's sides.

@cindex root window of atomic window
   Atomic windows are implemented with the help of the reserved
@code{window-atom} window parameter (@pxref{Window Parameters}) and an
internal window (@pxref{Basic Windows}) called the root window of the
atomic window.  All windows that are part of the same atomic window have
this root window as their common ancestor and are assigned a
non-@code{nil} @code{window-atom} parameter.

  The following function returns the root of the atomic window a
specified window is part of:

@defun window-atom-root &optional window
This functions returns the root of the atomic window @var{window} is a
part of.  The specified @var{window} must be a valid window and defaults
to the selected one.  It returns @code{nil} if @var{window} is not part
of an atomic window.
@end defun

The most simple approach to make a new atomic window is to take an
existing internal window and apply the following function:

@defun window-make-atom window
This function converts @var{window} into an atomic window.  The
specified @var{window} must be an internal window.  All this function
does is to set the @code{window-atom} parameter of each descendant of
@var{window} to @code{t}.
@end defun

To create a new atomic window from an existing live window or to add a
new window to an existing atomic window, the following buffer display
action function (@pxref{Buffer Display Action Functions}) can be used:

@defun display-buffer-in-atom-window buffer alist
This function tries to display @var{buffer} in a new window that will be
combined with an existing window to form an atomic window.  If the
existing window is already part of an atomic window, it adds the new
window to that atomic window.

The specified @var{alist} is an association list of symbols and values.
The following symbols have a special meaning:

@table @code
@item window
The value of such an element specifies an existing window the new window
shall be combined with.  If it specifies an internal window, all
children of that window become part of the atomic window too.  If no
window is specified, the new window becomes a sibling of the selected
window.  The @code{window-atom} parameter of the existing window is set
to @code{main} provided that window is live and its @code{window-atom}
parameter was not already set.

@item side
The value of such an element denotes the side of the existing window
where the new window shall be located.  Valid values are @code{below},
@code{right}, @code{above} and @code{left}.  The default is
@code{below}.  The @code{window-atom} parameter of the new window is set
to this value.
@end table

The return value is the new window, @code{nil} when creating that window
failed.
@end defun

Note that the value of the @code{window-atom} parameter does not really
matter as long as it is non-@code{nil}.  The values assigned by
@code{display-buffer-in-atom-window} just allow for easy retrieval of
the original and the new window after that function has been applied.
Note also that the @code{window-atom} parameter is the only window
parameter assigned by @code{display-buffer-in-atom-window}.  Further
parameters have to be set by the application explicitly via a
@code{window-parameters} entry in @var{alist}.

   Atomic windows automatically cease to exist when one of their
constituents gets deleted.  To dissolve an atomic window manually,
reset the @code{window-atom} parameter of its constituents---the root
of the atomic window and all its descendants.

   The following code snippet, when applied to a single-window frame,
first splits the selected window and makes the selected and the new
window constituents of an atomic window with their parent as root.  It
then displays the buffer @file{*Messages*} in a new window at the
frame's bottom and makes that new window part of the atomic window just
created.

@example
@group
(let ((window (split-window-right)))
  (window-make-atom (window-parent window))
  (display-buffer-in-atom-window
   (get-buffer-create "*Messages*")
   `((window . ,(window-parent window)) (window-height . 5))))
@end group
@end example

At this moment typing @w{@kbd{C-x 2}} in any window of that frame
produces a new window at the bottom of the frame.  Typing @w{@kbd{C-x
3}} instead will put the new window at the frame's right.  In either
case, typing now @w{@kbd{C-x 1}} in any window of the atomic window will
remove the new window only.  Typing @w{@kbd{C-x 0}} in any window of the
atomic window will make that new window fill the frame.


@node 窗口点
@section Windows and Point
@cindex window position
@cindex window point
@cindex position in window
@cindex point in window

  Each window has its own value of point (@pxref{Point}), independent of
the value of point in other windows displaying the same buffer.  This
makes it useful to have multiple windows showing one buffer.

@itemize @bullet
@item
The window point is established when a window is first created; it is
initialized from the buffer's point, or from the window point of another
window opened on the buffer if such a window exists.

@item
Selecting a window sets the value of point in its buffer from the
window's value of point.  Conversely, deselecting a window sets the
window's value of point from that of the buffer.  Thus, when you switch
between windows that display a given buffer, the point value for the
selected window is in effect in the buffer, while the point values for
the other windows are stored in those windows.

@item
As long as the selected window displays the current buffer, the window's
point and the buffer's point always move together; they remain equal.
@end itemize

@cindex cursor
   Emacs displays the cursor, by default as a rectangular block, in
each window at the position of that window's point.  When the user
switches to another buffer in a window, Emacs moves that window's
cursor to where point is in that buffer.  If the exact position of
point is hidden behind some display element, such as a display string
or an image, Emacs displays the cursor immediately before or after
that display element.

@defun window-point &optional window
This function returns the current position of point in @var{window}.
For a nonselected window, this is the value point would have (in that
window's buffer) if that window were selected.  The default for
@var{window} is the selected window.

When @var{window} is the selected window, the value returned is the
value of point in that window's buffer.  Strictly speaking, it would be
more correct to return the top-level value of point, outside of any
@code{save-excursion} forms.  But that value is hard to find.
@end defun

@defun set-window-point window position
This function positions point in @var{window} at position
@var{position} in @var{window}'s buffer.  It returns @var{position}.

If @var{window} is selected, this simply does @code{goto-char} in
@var{window}'s buffer.
@end defun

@defvar window-point-insertion-type
This variable specifies the marker insertion type (@pxref{Marker
Insertion Types}) of @code{window-point}.  The default is @code{nil},
so @code{window-point} will stay behind text inserted there.
@end defvar

@node 窗口开始和结束
@section The Window Start and End Positions
@cindex window start position
@cindex display-start position

  Each window maintains a marker used to keep track of a buffer position
that specifies where in the buffer display should start.  This position
is called the @dfn{display-start} position of the window (or just the
@dfn{start}).  The character after this position is the one that appears
at the upper left corner of the window.  It is usually, but not
inevitably, at the beginning of a text line.

  After switching windows or buffers, and in some other cases, if the
window start is in the middle of a line, Emacs adjusts the window
start to the start of a line.  This prevents certain operations from
leaving the window start at a meaningless point within a line.  This
feature may interfere with testing some Lisp code by executing it
using the commands of Lisp mode, because they trigger this
readjustment.  To test such code, put it into a command and bind the
command to a key.

@defun window-start &optional window
@cindex window top line
This function returns the display-start position of window
@var{window}.  If @var{window} is @code{nil}, the selected window is
used.

When you create a window, or display a different buffer in it, the
display-start position is set to a display-start position recently used
for the same buffer, or to @code{point-min} if the buffer doesn't have
any.

Redisplay updates the window-start position (if you have not specified
it explicitly since the previous redisplay)---to make sure point appears
on the screen.  Nothing except redisplay automatically changes the
window-start position; if you move point, do not expect the window-start
position to change in response until after the next redisplay.
@end defun

@defun window-group-start &optional window
@vindex window-group-start-function
This function is like @code{window-start}, except that when
@var{window} is a part of a group of windows (@pxref{Window Group}),
@code{window-group-start} returns the start position of the entire
group.  This condition holds when the buffer local variable
@code{window-group-start-function} is set to a function.  In this
case, @code{window-group-start} calls the function with the single
argument @var{window}, then returns its result.
@end defun

@cindex window end position
@cindex last visible position in a window
@defun window-end &optional window update
This function returns the position where display of its buffer ends in
@var{window}.  The default for @var{window} is the selected window.

Simply changing the buffer text or moving point does not update the
value that @code{window-end} returns.  The value is updated only when
Emacs redisplays and redisplay completes without being preempted.

If the last redisplay of @var{window} was preempted, and did not finish,
Emacs does not know the position of the end of display in that window.
In that case, this function returns @code{nil}.

If @var{update} is non-@code{nil}, @code{window-end} always returns an
up-to-date value for where display ends, based on the current
@code{window-start} value.  If a previously saved value of that position
is still valid, @code{window-end} returns that value; otherwise it
computes the correct value by scanning the buffer text.

Even if @var{update} is non-@code{nil}, @code{window-end} does not
attempt to scroll the display if point has moved off the screen, the
way real redisplay would do.  It does not alter the
@code{window-start} value.  In effect, it reports where the displayed
text will end if scrolling is not required.  Note that the position it
returns might be only partially visible.
@end defun

@vindex window-group-end-function
@defun window-group-end &optional window update
This function is like @code{window-end}, except that when @var{window}
is a part of a group of windows (@pxref{Window Group}),
@code{window-group-end} returns the end position of the entire group.
This condition holds when the buffer local variable
@code{window-group-end-function} is set to a function.  In this case,
@code{window-group-end} calls the function with the two arguments
@var{window} and @var{update}, then returns its result.  The argument
@var{update} has the same meaning as in @code{window-end}.
@end defun

@defun set-window-start window position &optional noforce
This function sets the display-start position of @var{window} to
@var{position} in @var{window}'s buffer.  It returns @var{position}.

The display routines insist that the position of point be visible when a
buffer is displayed.  Normally, they select the display-start position
according to their internal logic (and scroll the window if necessary)
to make point visible.  However, if you specify the start position
with this function using @code{nil} for @var{noforce}, it means you
want display to start at @var{position} even if that would put the
location of point off the screen.  If this does place point off
screen, the display routines attempt to move point to the left margin
on the middle line in the window.

For example, if point @w{is 1} and you set the start of the window
@w{to 37}, the start of the next line, point will be above the top
of the window.  The display routines will automatically move point if
it is still 1 when redisplay occurs.  Here is an example:

@example
@group
;; @r{Here is what @samp{foo} looks like before executing}
;;   @r{the @code{set-window-start} expression.}
@end group

@group
---------- Buffer: foo ----------
@point{}This is the contents of buffer foo.
2
3
4
5
6
---------- Buffer: foo ----------
@end group

@group
(set-window-start
 (selected-window)
 (save-excursion
   (goto-char 1)
   (forward-line 1)
   (point)))
@result{} 37
@end group

@group
;; @r{Here is what @samp{foo} looks like after executing}
;;   @r{the @code{set-window-start} expression.}
---------- Buffer: foo ----------
2
3
@point{}4
5
6
---------- Buffer: foo ----------
@end group
@end example

If the attempt to make point visible (i.e., in a fully-visible screen
line) fails, the display routines will disregard the requested
window-start position and compute a new one anyway.  Thus, for
reliable results Lisp programs that call this function should always
move point to be inside the window whose display starts at
@var{position}.

If @var{noforce} is non-@code{nil}, and @var{position} would place point
off screen at the next redisplay, then redisplay computes a new window-start
position that works well with point, and thus @var{position} is not used.
@end defun

@vindex set-window-group-start-function
@defun set-window-group-start window position &optional noforce
This function is like @code{set-window-start}, except that when
@var{window} is a part of a group of windows (@pxref{Window Group}),
@code{set-window-group-start} sets the start position of the entire
group.  This condition holds when the buffer local variable
@code{set-window-group-start-function} is set to a function.  In this
case, @code{set-window-group-start} calls the function with the three
arguments @var{window}, @var{position}, and @var{noforce}, then
returns its result.  The arguments @var{position} and @var{noforce} in
this function have the same meaning as in @code{set-window-start}.
@end defun

@defun pos-visible-in-window-p &optional position window partially
This function returns non-@code{nil} if @var{position} is within the
range of text currently visible on the screen in @var{window}.  It
returns @code{nil} if @var{position} is scrolled vertically out of
view.  Locations that are partially obscured are not considered
visible unless @var{partially} is non-@code{nil}.  The argument
@var{position} defaults to the current position of point in
@var{window}; @var{window} defaults to the selected window.  If
@var{position} is @code{t}, that means to check either the first
visible position of the last screen line in @var{window}, or the
end-of-buffer position, whichever comes first.

This function considers only vertical scrolling.  If @var{position} is
out of view only because @var{window} has been scrolled horizontally,
@code{pos-visible-in-window-p} returns non-@code{nil} anyway.
@xref{Horizontal Scrolling}.

If @var{position} is visible, @code{pos-visible-in-window-p} returns
@code{t} if @var{partially} is @code{nil}; if @var{partially} is
non-@code{nil}, and the character following @var{position} is fully
visible, it returns a list of the form @code{(@var{x} @var{y})}, where
@var{x} and @var{y} are the pixel coordinates relative to the top left
corner of the window; otherwise it returns an extended list of the form
@code{(@var{x} @var{y} @var{rtop} @var{rbot} @var{rowh} @var{vpos})},
where @var{rtop} and @var{rbot} specify the number of off-window pixels
at the top and bottom of the row at @var{position}, @var{rowh} specifies
the visible height of that row, and @var{vpos} specifies the vertical
position (zero-based row number) of that row.

Here is an example:

@example
@group
;; @r{If point is off the screen now, recenter it now.}
(or (pos-visible-in-window-p
     (point) (selected-window))
    (recenter 0))
@end group
@end example
@end defun

@vindex pos-visible-in-window-group-p-function
@defun pos-visible-in-window-group-p &optional position window partially
This function is like @code{pos-visible-in-window-p}, except that when
@var{window} is a part of a group of windows (@pxref{Window Group}),
@code{pos-visible-in-window-group-p} tests the visibility of @var{pos}
in the entire group, not just in the single @var{window}.  This
condition holds when the buffer local variable
@code{pos-visible-in-window-group-p-function} is set to a function.
In this case @code{pos-visible-in-window-group-p} calls the function
with the three arguments @var{position}, @var{window}, and
@var{partially}, then returns its result.  The arguments
@var{position} and @var{partially} have the same meaning as in
@code{pos-visible-in-window-p}.
@end defun

@defun window-line-height &optional line window
This function returns the height of text line @var{line} in
@var{window}.  If @var{line} is one of @code{header-line} or
@code{mode-line}, @code{window-line-height} returns information about
the corresponding line of the window.  Otherwise, @var{line} is a text
line number starting from 0.  A negative number counts from the end of
the window.  The default for @var{line} is the current line in
@var{window}; the default for @var{window} is the selected window.

If the display is not up to date, @code{window-line-height} returns
@code{nil}.  In that case, @code{pos-visible-in-window-p} may be used
to obtain related information.

If there is no line corresponding to the specified @var{line},
@code{window-line-height} returns @code{nil}.  Otherwise, it returns
a list @code{(@var{height} @var{vpos} @var{ypos} @var{offbot})},
where @var{height} is the height in pixels of the visible part of the
line, @var{vpos} and @var{ypos} are the vertical position in lines and
pixels of the line relative to the top of the first text line, and
@var{offbot} is the number of off-window pixels at the bottom of the
text line.  If there are off-window pixels at the top of the (first)
text line, @var{ypos} is negative.
@end defun

@node 文本滚动
@section Textual Scrolling
@cindex textual scrolling
@cindex scrolling textually

  @dfn{Textual scrolling} means moving the text up or down through a
window.  It works by changing the window's display-start location.  It
may also change the value of @code{window-point} to keep point on the
screen (@pxref{Window Point}).

  The basic textual scrolling functions are @code{scroll-up} (which
scrolls forward) and @code{scroll-down} (which scrolls backward).  In
these function names, ``up'' and ``down'' refer to the direction of
motion of the buffer text relative to the window.  Imagine that the
text is written on a long roll of paper and that the scrolling
commands move the paper up and down.  Thus, if you are looking at the
middle of a buffer and repeatedly call @code{scroll-down}, you will
eventually see the beginning of the buffer.

  Unfortunately, this sometimes causes confusion, because some people
tend to think in terms of the opposite convention: they
imagine the window moving over text that remains in place, so that
``down'' commands take you to the end of the buffer.  This convention
is consistent with fact that such a command is bound to a key named
@key{PageDown} on modern keyboards.
@ignore
We have not switched to this convention as that is likely to break
existing Emacs Lisp code.
@end ignore

  Textual scrolling functions (aside from @code{scroll-other-window})
have unpredictable results if the current buffer is not the one
displayed in the selected window.  @xref{Current Buffer}.

  If the window contains a row taller than the height of the window
(for example in the presence of a large image), the scroll functions
will adjust the window's vertical scroll position to scroll the
partially visible row.  Lisp callers can disable this feature by
binding the variable @code{auto-window-vscroll} to @code{nil}
(@pxref{Vertical Scrolling}).

@deffn Command scroll-up &optional count
This function scrolls forward by @var{count} lines in the selected
window.

If @var{count} is negative, it scrolls backward instead.  If
@var{count} is @code{nil} (or omitted), the distance scrolled is
@code{next-screen-context-lines} lines less than the height of the
window's text area.

If the selected window cannot be scrolled any further, this function
signals an error.  Otherwise, it returns @code{nil}.
@end deffn

@deffn Command scroll-down &optional count
This function scrolls backward by @var{count} lines in the selected
window.

If @var{count} is negative, it scrolls forward instead.  In other
respects, it behaves the same way as @code{scroll-up} does.
@end deffn

@deffn Command scroll-up-command &optional count
This behaves like @code{scroll-up}, except that if the selected window
cannot be scrolled any further and the value of the variable
@code{scroll-error-top-bottom} is @code{t}, it tries to move to the
end of the buffer instead.  If point is already there, it signals an
error.
@end deffn

@deffn Command scroll-down-command &optional count
This behaves like @code{scroll-down}, except that if the selected
window cannot be scrolled any further and the value of the variable
@code{scroll-error-top-bottom} is @code{t}, it tries to move to the
beginning of the buffer instead.  If point is already there, it
signals an error.
@end deffn

@deffn Command scroll-other-window &optional count
This function scrolls the text in another window upward @var{count}
lines.  Negative values of @var{count}, or @code{nil}, are handled
as in @code{scroll-up}.

You can specify which buffer to scroll by setting the variable
@code{other-window-scroll-buffer} to a buffer.  If that buffer isn't
already displayed, @code{scroll-other-window} displays it in some
window.

When the selected window is the minibuffer, the next window is normally
the leftmost one immediately above it.  You can specify a different
window to scroll, when the minibuffer is selected, by setting the variable
@code{minibuffer-scroll-window}.  This variable has no effect when any
other window is selected.  When it is non-@code{nil} and the
minibuffer is selected, it takes precedence over
@code{other-window-scroll-buffer}.  @xref{Definition of
minibuffer-scroll-window}.

When the minibuffer is active, it is the next window if the selected
window is the one at the bottom right corner.  In this case,
@code{scroll-other-window} attempts to scroll the minibuffer.  If the
minibuffer contains just one line, it has nowhere to scroll to, so the
line reappears after the echo area momentarily displays the message
@samp{End of buffer}.
@end deffn

@deffn Command scroll-other-window-down &optional count
This function scrolls the text in another window downward @var{count}
lines.  Negative values of @var{count}, or @code{nil}, are handled as
in @code{scroll-down}.  In other respects, it behaves the same way as
@code{scroll-other-window} does.
@end deffn

@defvar other-window-scroll-buffer
If this variable is non-@code{nil}, it tells @code{scroll-other-window}
which buffer's window to scroll.
@end defvar

@defopt scroll-margin
This option specifies the size of the scroll margin---a minimum number
of lines between point and the top or bottom of a window.  Whenever
point gets within this many lines of the top or bottom of the window,
redisplay scrolls the text automatically (if possible) to move point
out of the margin, closer to the center of the window.
@end defopt

@defopt maximum-scroll-margin
This variable limits the effective value of @code{scroll-margin} to a
fraction of the current window line height.  For example, if the
current window has 20 lines and @code{maximum-scroll-margin} is 0.1,
then the scroll margins will never be larger than 2 lines, no matter
how big @code{scroll-margin} is.

@code{maximum-scroll-margin} itself has a maximum value of 0.5, which
allows setting margins large to keep the cursor at the middle line of
the window (or two middle lines if the window has an even number of
lines).  If it's set to a larger value (or any value other than a
float between 0.0 and 0.5) then the default value of 0.25 will be used
instead.
@end defopt

@defopt scroll-conservatively
This variable controls how scrolling is done automatically when point
moves off the screen (or into the scroll margin).  If the value is a
positive integer @var{n}, then redisplay scrolls the text up to
@var{n} lines in either direction, if that will bring point back into
proper view.  This behavior is called @dfn{conservative scrolling}.
Otherwise, scrolling happens in the usual way, under the control of
other variables such as @code{scroll-up-aggressively} and
@code{scroll-down-aggressively}.

The default value is zero, which means that conservative scrolling
never happens.
@end defopt

@defopt scroll-down-aggressively
The value of this variable should be either @code{nil} or a fraction
@var{f} between 0 and 1.  If it is a fraction, that specifies where on
the screen to put point when scrolling down.  More precisely, when a
window scrolls down because point is above the window start, the new
start position is chosen to put point @var{f} part of the window
height from the top.  The larger @var{f}, the more aggressive the
scrolling.

A value of @code{nil} is equivalent to .5, since its effect is to center
point.  This variable automatically becomes buffer-local when set in any
fashion.
@end defopt

@defopt scroll-up-aggressively
Likewise, for scrolling up.  The value, @var{f}, specifies how far
point should be placed from the bottom of the window; thus, as with
@code{scroll-down-aggressively}, a larger value scrolls more
aggressively.
@end defopt

@defopt scroll-step
This variable is an older variant of @code{scroll-conservatively}.
The difference is that if its value is @var{n}, that permits scrolling
only by precisely @var{n} lines, not a smaller number.  This feature
does not work with @code{scroll-margin}.  The default value is zero.
@end defopt

@cindex @code{scroll-command} property
@defopt scroll-preserve-screen-position
If this option is @code{t}, whenever a scrolling command moves point
off-window, Emacs tries to adjust point to keep the cursor at its old
vertical position in the window, rather than the window edge.

If the value is non-@code{nil} and not @code{t}, Emacs adjusts point
to keep the cursor at the same vertical position, even if the
scrolling command didn't move point off-window.

This option affects all scroll commands that have a non-@code{nil}
@code{scroll-command} symbol property.
@end defopt

@defopt next-screen-context-lines
The value of this variable is the number of lines of continuity to
retain when scrolling by full screens.  For example, @code{scroll-up}
with an argument of @code{nil} scrolls so that this many lines at the
bottom of the window appear instead at the top.  The default value is
@code{2}.
@end defopt

@defopt scroll-error-top-bottom
If this option is @code{nil} (the default), @code{scroll-up-command}
and @code{scroll-down-command} simply signal an error when no more
scrolling is possible.

If the value is @code{t}, these commands instead move point to the
beginning or end of the buffer (depending on scrolling direction);
only if point is already on that position do they signal an error.
@end defopt

@deffn Command recenter &optional count redisplay
@cindex centering point
This function scrolls the text in the selected window so that point is
displayed at a specified vertical position within the window.  It does
not move point with respect to the text.

If @var{count} is a non-negative number, that puts the line containing
point @var{count} lines down from the top of the window.  If
@var{count} is a negative number, then it counts upward from the
bottom of the window, so that @minus{}1 stands for the last usable
line in the window.

If @var{count} is @code{nil} (or a non-@code{nil} list),
@code{recenter} puts the line containing point in the middle of the
window.  If @var{count} is @code{nil} and @var{redisplay} is
non-@code{nil}, this function may redraw the frame, according to the
value of @code{recenter-redisplay}.  Thus, omitting the second
argument can be used to countermand the effect of
@code{recenter-redisplay} being non-@code{nil}.  Interactive calls
pass non-‘nil’ for @var{redisplay}.

When @code{recenter} is called interactively, @var{count} is the raw
prefix argument.  Thus, typing @kbd{C-u} as the prefix sets the
@var{count} to a non-@code{nil} list, while typing @kbd{C-u 4} sets
@var{count} to 4, which positions the current line four lines from the
top.

With an argument of zero, @code{recenter} positions the current line at
the top of the window.  The command @code{recenter-top-bottom} offers
a more convenient way to achieve this.
@end deffn

@vindex recenter-window-group-function
@defun recenter-window-group &optional count
This function is like @code{recenter}, except that when the selected
window is part of a group of windows (@pxref{Window Group}),
@code{recenter-window-group} scrolls the entire group.  This condition
holds when the buffer local variable
@code{recenter-window-group-function} is set to a function.  In this
case, @code{recenter-window-group} calls the function with the
argument @var{count}, then returns its result.  The argument
@var{count} has the same meaning as in @code{recenter}, but with
respect to the entire window group.
@end defun

@defopt recenter-redisplay
If this variable is non-@code{nil}, calling @code{recenter} with a
@code{nil} @var{count} argument and non-@code{nil} @var{redisplay}
argument redraws the frame.  The default value is @code{tty}, which
means only redraw the frame if it is a tty frame.
@end defopt

@deffn Command recenter-top-bottom &optional count
This command, which is the default binding for @kbd{C-l}, acts like
@code{recenter}, except if called with no argument.  In that case,
successive calls place point according to the cycling order defined
by the variable @code{recenter-positions}.
@end deffn

@defopt recenter-positions
This variable controls how @code{recenter-top-bottom} behaves when
called with no argument.  The default value is @code{(middle top
bottom)}, which means that successive calls of
@code{recenter-top-bottom} with no argument cycle between placing
point at the middle, top, and bottom of the window.
@end defopt


@node 垂直滚动
@section Vertical Fractional Scrolling
@cindex vertical fractional scrolling
@cindex vertical scroll position

   @dfn{Vertical fractional scrolling} means shifting text in a window
up or down by a specified multiple or fraction of a line.  Emacs uses
it, for example, on images and screen lines which are taller than the
window.  Each window has a @dfn{vertical scroll position}, which is a
number, never less than zero.  It specifies how far to raise the
contents of the window when displaying them.  Raising the window
contents generally makes all or part of some lines disappear off the
top, and all or part of some other lines appear at the bottom.  The
usual value is zero.

   The vertical scroll position is measured in units of the normal line
height, which is the height of the default font.  Thus, if the value is
.5, that means the window contents will be scrolled up half the normal
line height.  If it is 3.3, that means the window contents are scrolled
up somewhat over three times the normal line height.

   What fraction of a line the vertical scrolling covers, or how many
lines, depends on what the lines contain.  A value of .5 could scroll a
line whose height is very short off the screen, while a value of 3.3
could scroll just part of the way through a tall line or an image.

@defun window-vscroll &optional window pixels-p
This function returns the current vertical scroll position of
@var{window}.  The default for @var{window} is the selected window.
If @var{pixels-p} is non-@code{nil}, the return value is measured in
pixels, rather than in units of the normal line height.

@example
@group
(window-vscroll)
     @result{} 0
@end group
@end example
@end defun

@defun set-window-vscroll window lines &optional pixels-p
This function sets @var{window}'s vertical scroll position to
@var{lines}.  If @var{window} is @code{nil}, the selected window is
used.  The argument @var{lines} should be zero or positive; if not, it
is taken as zero.


The actual vertical scroll position must always correspond
to an integral number of pixels, so the value you specify
is rounded accordingly.

The return value is the result of this rounding.

@example
@group
(set-window-vscroll (selected-window) 1.2)
     @result{} 1.13
@end group
@end example

If @var{pixels-p} is non-@code{nil}, @var{lines} specifies a number of
pixels.  In this case, the return value is @var{lines}.
@end defun

@defvar auto-window-vscroll
If this variable is non-@code{nil}, the @code{line-move},
@code{scroll-up}, and @code{scroll-down} functions will automatically
modify the vertical scroll position to scroll through display rows
that are taller than the height of the window, for example in the
presence of large images.
@end defvar

@node 水平滚动
@section Horizontal Scrolling
@cindex horizontal scrolling

  @dfn{Horizontal scrolling} means shifting the image in the window left
or right by a specified multiple of the normal character width.  Each
window has a @dfn{horizontal scroll position}, which is a number, never
less than zero.  It specifies how far to shift the contents left.
Shifting the window contents left generally makes all or part of some
characters disappear off the left, and all or part of some other
characters appear at the right.  The usual value is zero.

  The horizontal scroll position is measured in units of the normal
character width, which is the width of space in the default font.  Thus,
if the value is 5, that means the window contents are scrolled left by 5
times the normal character width.  How many characters actually
disappear off to the left depends on their width, and could vary from
line to line.

  Because we read from side to side in the inner loop, and from top
to bottom in the outer loop, the effect of horizontal scrolling is
not like that of textual or vertical scrolling.  Textual scrolling
involves selection of a portion of text to display, and vertical
scrolling moves the window contents contiguously; but horizontal
scrolling causes part of @emph{each line} to go off screen.

  Usually, no horizontal scrolling is in effect; then the leftmost
column is at the left edge of the window.  In this state, scrolling to
the right is meaningless, since there is no data to the left of the edge
to be revealed by it; so this is not allowed.  Scrolling to the left is
allowed; it scrolls the first columns of text off the edge of the window
and can reveal additional columns on the right that were truncated
before.  Once a window has a nonzero amount of leftward horizontal
scrolling, you can scroll it back to the right, but only so far as to
reduce the net horizontal scroll to zero.  There is no limit to how far
left you can scroll, but eventually all the text will disappear off the
left edge.

@vindex auto-hscroll-mode
  If @code{auto-hscroll-mode} is set, redisplay automatically alters
the horizontal scrolling of a window as necessary to ensure that point
is always visible.  However, you can still set the horizontal
scrolling value explicitly.  The value you specify serves as a lower
bound for automatic scrolling, i.e., automatic scrolling will not
scroll a window to a column less than the specified one.

  The default value of @code{auto-hscroll-mode} is @code{t}; setting
it to @code{current-line} activates a variant of automatic horizontal
scrolling whereby only the line showing the cursor is horizontally
scrolled to make point visible, the rest of the window is left either
unscrolled, or at the minimum scroll amount set by @code{scroll-left}
and @code{scroll-right}, see below.

@deffn Command scroll-left &optional count set-minimum
This function scrolls the selected window @var{count} columns to the
left (or to the right if @var{count} is negative).  The default
for @var{count} is the window width, minus 2.

The return value is the total amount of leftward horizontal scrolling in
effect after the change---just like the value returned by
@code{window-hscroll} (below).

Note that text in paragraphs whose base direction is right-to-left
(@pxref{Bidirectional Display}) moves in the opposite direction: e.g.,
it moves to the right when @code{scroll-left} is invoked with a
positive value of @var{count}.

Once you scroll a window as far right as it can go, back to its normal
position where the total leftward scrolling is zero, attempts to scroll
any farther right have no effect.

If @var{set-minimum} is non-@code{nil}, the new scroll amount becomes
the lower bound for automatic scrolling; that is, automatic scrolling
will not scroll a window to a column less than the value returned by
this function.  Interactive calls pass non-@code{nil} for
@var{set-minimum}.
@end deffn

@deffn Command scroll-right &optional count set-minimum
This function scrolls the selected window @var{count} columns to the
right (or to the left if @var{count} is negative).  The default
for @var{count} is the window width, minus 2.  Aside from the direction
of scrolling, this works just like @code{scroll-left}.
@end deffn

@defun window-hscroll &optional window
This function returns the total leftward horizontal scrolling of
@var{window}---the number of columns by which the text in @var{window}
is scrolled left past the left margin.  (In right-to-left paragraphs,
the value is the total amount of the rightward scrolling instead.)
The default for @var{window} is the selected window.

The return value is never negative.  It is zero when no horizontal
scrolling has been done in @var{window} (which is usually the case).


@example
@group
(window-hscroll)
     @result{} 0
@end group
@group
(scroll-left 5)
     @result{} 5
@end group
@group
(window-hscroll)
     @result{} 5
@end group
@end example
@end defun

@defun set-window-hscroll window columns
This function sets horizontal scrolling of @var{window}.  The value of
@var{columns} specifies the amount of scrolling, in terms of columns
from the left margin (right margin in right-to-left paragraphs).  The
argument @var{columns} should be zero or positive; if not, it is taken
as zero.  Fractional values of @var{columns} are not supported at
present.

Note that @code{set-window-hscroll} may appear not to work if you test
it by evaluating a call with @kbd{M-:} in a simple way.  What happens
is that the function sets the horizontal scroll value and returns, but
then redisplay adjusts the horizontal scrolling to make point visible,
and this overrides what the function did.  You can observe the
function's effect if you call it while point is sufficiently far from
the left margin that it will remain visible.

The value returned is @var{columns}.

@example
@group
(set-window-hscroll (selected-window) 10)
     @result{} 10
@end group
@end example
@end defun

   Here is how you can determine whether a given position @var{position}
is off the screen due to horizontal scrolling:

@c FIXME: Maybe hscroll-on-screen-p is a better name?
@example
@group
(defun hscroll-on-screen (window position)
  (save-excursion
    (goto-char position)
    (and
     (>= (- (current-column) (window-hscroll window)) 0)
     (< (- (current-column) (window-hscroll window))
        (window-width window)))))
@end group
@end example


@node 坐标和窗口
@section Coordinates and Windows
@cindex frame-relative coordinate
@cindex coordinate, relative to frame
@cindex window position

This section describes functions that report positions of and within a
window.  Most of these functions report positions relative to an origin
at the native position of the window's frame (@pxref{Frame Geometry}).
Some functions report positions relative to the origin of the display of
the window's frame.  In any case, the origin has the coordinates (0, 0)
and X and Y coordinates increase rightward and downward respectively.

  For the following functions, X and Y coordinates are reported in
integer character units, i.e., numbers of lines and columns
respectively.  On a graphical display, each ``line'' and ``column''
corresponds to the height and width of the default character specified by
the frame's default font (@pxref{Frame Font}).

@defun window-edges &optional window body absolute pixelwise
This function returns a list of the edge coordinates of @var{window}.
If @var{window} is omitted or @code{nil}, it defaults to the selected
window.

The return value has the form @code{(@var{left} @var{top} @var{right}
@var{bottom})}.  These list elements are, respectively, the X
coordinate of the leftmost column occupied by the window, the Y
coordinate of the topmost row, the X coordinate one column to the
right of the rightmost column, and the Y coordinate one row down from
the bottommost row.

Note that these are the actual outer edges of the window, including any
header line, mode line, scroll bar, fringes, window divider and display
margins.  On a text terminal, if the window has a neighbor on its right,
its right edge includes the separator line between the window and its
neighbor.

If the optional argument @var{body} is @code{nil}, this means to
return the edges corresponding to the total size of @var{window}.
@var{body} non-@code{nil} means to return the edges of @var{window}'s
body (aka text area).  If @var{body} is non-@code{nil}, @var{window}
must specify a live window.

If the optional argument @var{absolute} is @code{nil}, this means to
return edges relative to the native position of @var{window}'s frame.
@var{absolute} non-@code{nil} means to return coordinates relative to
the origin (0, 0) of @var{window}'s display.  On non-graphical systems
this argument has no effect.

If the optional argument @var{pixelwise} is @code{nil}, this means to
return the coordinates in terms of the default character width and
height of @var{window}'s frame (@pxref{Frame Font}), rounded if
necessary.  @var{pixelwise} non-@code{nil} means to return the
coordinates in pixels.  Note that the pixel specified by @var{right} and
@var{bottom} is immediately outside of these edges.  If @var{absolute}
is non-@code{nil}, @var{pixelwise} is implicitly non-@code{nil} too.
@end defun

@defun window-body-edges &optional window
This function returns the edges of @var{window}'s body (@pxref{Window
Sizes}).  Calling @code{(window-body-edges window)} is equivalent to
calling @code{(window-edges window t)}, see above.
@end defun

@comment The following two functions are confusing and hardly used.
@ignore
@defun window-left-column &optional window
This function returns the leftmost column of @var{window}.  This value
equals the @var{left} entry in the list returned by @code{(window-edges
window)} minus the number of columns occupied by the internal border of
@var{window}'s frame.
@end defun

@defun window-top-line &optional window
This function returns the topmost row of @var{window}.  This value is
equal to the @var{top} entry in the list returned by @code{(window-edges
window)} minus the number of lines occupied by the internal border of
@var{window}'s frame.
@end defun
@end ignore

  The following functions can be used to relate a set of
frame-relative coordinates to a window:

@defun window-at x y &optional frame
This function returns the live window at the coordinates @var{x} and
@var{y} given in default character sizes (@pxref{Frame Font}) relative
to the native position of @var{frame} (@pxref{Frame Geometry}).

If there is no window at that position, the return value is @code{nil}.
If @var{frame} is omitted or @code{nil}, it defaults to the selected
frame.
@end defun

@defun coordinates-in-window-p coordinates window
This function checks whether a window @var{window} occupies the frame
relative coordinates @var{coordinates}, and if so, which part of the
window that is.  @var{window} should be a live window.

@var{coordinates} should be a cons cell of the form @code{(@var{x}
. @var{y})}, where @var{x} and @var{y} are given in default character
sizes (@pxref{Frame Font}) relative to the native position of
@var{window}'s frame (@pxref{Frame Geometry}).

If there is no window at the specified position, the return value is
@code{nil} .  Otherwise, the return value is one of the following:

@table @code
@item (@var{relx} . @var{rely})
The coordinates are inside @var{window}.  The numbers @var{relx} and
@var{rely} are the equivalent window-relative coordinates for the
specified position, counting from 0 at the top left corner of the
window.

@item mode-line
The coordinates are in the mode line of @var{window}.

@item header-line
The coordinates are in the header line of @var{window}.

@item tab-line
The coordinates are in the tab line of @var{window}.

@item right-divider
The coordinates are in the divider separating @var{window} from a
window on the right.

@item bottom-divider
The coordinates are in the divider separating @var{window} from a
window beneath.

@item vertical-line
The coordinates are in the vertical line between @var{window} and its
neighbor to the right.  This value occurs only if the window doesn't
have a scroll bar; positions in a scroll bar are considered outside the
window for these purposes.

@item left-fringe
@itemx right-fringe
The coordinates are in the left or right fringe of the window.

@item left-margin
@itemx right-margin
The coordinates are in the left or right margin of the window.

@item nil
The coordinates are not in any part of @var{window}.
@end table

The function @code{coordinates-in-window-p} does not require a frame as
argument because it always uses the frame that @var{window} is on.
@end defun

  The following functions return window positions in pixels, rather
than character units.  Though mostly useful on graphical displays,
they can also be called on text terminals, where the screen area of
each text character is taken to be one pixel.

@defun window-pixel-edges &optional window
This function returns a list of pixel coordinates for the edges of
@var{window}.  Calling @code{(window-pixel-edges window)} is equivalent
to calling @code{(window-edges window nil nil t)}, see above.
@end defun

@comment The following two functions are confusing and hardly used.
@ignore
@defun window-pixel-left &optional window
This function returns the left pixel edge of window @var{window}.  This
value equals the @var{left} entry in the list returned by
@code{(window-pixel-edges window)} minus the number of pixels occupied
by the internal border of @var{window}'s frame.  @var{window} must be a
valid window and defaults to the selected one.
@end defun

@defun window-pixel-top &optional window
This function returns the top pixel edge of window @var{window}.  This
value is equal to the @var{top} entry in the list returned by
@code{(window-pixel-edges window)} minus the number of pixels occupied
by the internal border of @var{window}'s frame.  @var{window} must be a
valid window and defaults to the selected one.
@end defun
@end ignore

@defun window-body-pixel-edges &optional window
This function returns the pixel edges of @var{window}'s body.  Calling
@code{(window-body-pixel-edges window)} is equivalent to calling
@code{(window-edges window t nil t)}, see above.
@end defun

  The following functions return window positions in pixels, relative to
the origin of the display screen rather than that of the frame:

@defun window-absolute-pixel-edges &optional window
This function returns the pixel coordinates of @var{window} relative to
an origin at (0, 0) of the display of @var{window}'s frame.  Calling
@code{(window-absolute-pixel-edges)} is equivalent to calling
@code{(window-edges window nil t t)}, see above.
@end defun

@defun window-absolute-body-pixel-edges &optional window
This function returns the pixel coordinates of @var{window}'s body
relative to an origin at (0, 0) of the display of @var{window}'s frame.
Calling @code{(window-absolute-body-pixel-edges window)} is equivalent
to calling @code{(window-edges window t t t)}, see above.

Combined with @code{set-mouse-absolute-pixel-position}, this function
can be used to move the mouse pointer to an arbitrary buffer position
visible in some window:

@example
@group
(let ((edges (window-absolute-body-pixel-edges))
      (position (pos-visible-in-window-p nil nil t)))
  (set-mouse-absolute-pixel-position
   (+ (nth 0 edges) (nth 0 position))
   (+ (nth 1 edges) (nth 1 position))))
@end group
@end example

On a graphical terminal this form ``warps'' the mouse cursor to the
upper left corner of the glyph at the selected window's point.  A
position calculated this way can be also used to show a tooltip window
there.
@end defun

The following function returns the screen coordinates of a buffer
position visible in a window:

@defun window-absolute-pixel-position &optional position window
If the buffer position @var{position} is visible in window @var{window},
this function returns the display coordinates of the upper/left corner
of the glyph at @var{position}.  The return value is a cons of the X-
and Y-coordinates of that corner, relative to an origin at (0, 0) of
@var{window}'s display.  It returns @code{nil} if @var{position} is not
visible in @var{window}.

@var{window} must be a live window and defaults to the selected
window.  @var{position} defaults to the value of @code{window-point}
of @var{window}.

This means that in order to move the mouse pointer to the position of
point in the selected window, it's sufficient to write:

@example
@group
(let ((position (window-absolute-pixel-position)))
  (set-mouse-absolute-pixel-position
   (car position) (cdr position)))
@end group
@end example
@end defun

The following function returns the largest rectangle that can be
inscribed in a window without covering text displayed in that window.

@defun window-largest-empty-rectangle &optional window count min-width min-height positions left
This function calculates the dimensions of the largest empty rectangle
that can be inscribed in the specified @var{window}'s text area.
@var{window} must be a live window and defaults to the selected one.

The return value is a triple of the width and the start and end
y-coordinates of the largest rectangle that can be inscribed into the
empty space (space not displaying any text) of the text area of
@var{window}.  No x-coordinates are returned by this function---any such
rectangle is assumed to end at the right edge of @var{window}'s text
area.  If no empty space can be found, the return value is @code{nil}.

The optional argument @var{count}, if non-@code{nil}, specifies a
maximum number of rectangles to return.  This means that the return
value is a list of triples specifying rectangles with the largest
rectangle first.  @var{count} can be also a cons cell whose car
specifies the number of rectangles to return and whose @sc{cdr}, if
non-@code{nil}, states that all rectangles returned must be disjoint.

The optional arguments @var{min-width} and @var{min-height}, if
non-@code{nil}, specify the minimum width and height of any rectangle
returned.

The optional argument @var{positions}, if non-@code{nil}, is a cons cell
whose @sc{car} specifies the uppermost and whose @sc{cdr} specifies the
lowermost pixel position that must be covered by any rectangle returned.
These positions measure from the start of the text area of @var{window}.

The optional argument @var{left}, if non-@code{nil}, means to return
values suitable for buffers displaying right to left text.  In that
case, any rectangle returned is assumed to start at the left edge of
@var{window}'s text area.

Note that this function has to retrieve the dimensions of each line of
@var{window}'s glyph matrix via @code{window-lines-pixel-dimensions}
(@pxref{Size of Displayed Text}).  Hence, this function may also return
@code{nil} when the current glyph matrix of @var{window} is not
up-to-date.
@end defun


@node 鼠标自动选择窗口
@section Mouse Window Auto-selection
@cindex window auto-selection
@cindex auto-selection of window
The following option allows to automatically select the window under the
mouse pointer.  This accomplishes a policy similar to that of window
managers that give focus to a frame (and thus trigger its subsequent
selection) whenever the mouse pointer enters its window-system window
(@pxref{Input Focus}).

@defopt mouse-autoselect-window
If this variable is non-@code{nil}, Emacs will try to automatically
select the window under the mouse pointer.  The following values are
meaningful:

@table @asis
@item A positive number
This specifies a delay in seconds after which auto-selection triggers.
The window under the mouse pointer is selected after the mouse has
remained in it for the entire duration of the delay.

@item A negative number
A negative number has a similar effect as a positive number, but selects
the window under the mouse pointer only after the mouse pointer has
remained in it for the entire duration of the absolute value of that
number and in addition has stopped moving.

@item Other value
Any other non-@code{nil} value means to select a window instantaneously
as soon as the mouse pointer enters it.
@end table

In either case, the mouse pointer must enter the text area of a window in
order to trigger its selection.  Dragging the scroll bar slider or the
mode line of a window conceptually should not cause its auto-selection.

Mouse auto-selection selects the minibuffer window only if it is active,
and never deselects the active minibuffer window.
@end defopt

Mouse auto-selection can be used to emulate a focus follows mouse policy
for child frames (@pxref{Child Frames}) which usually are not tracked by
the window manager.  This requires to set the value of
@code{focus-follows-mouse} (@pxref{Input Focus}) to a non-@code{nil}
value.  If the value of @code{focus-follows-mouse} is @code{auto-raise},
entering a child frame with the mouse will raise it automatically above
all other child frames of that frame's parent frame.


@node 窗口配置
@section Window Configurations
@cindex window configurations
@cindex saving window information

A @dfn{window configuration} records the entire layout of one
frame---all windows, their sizes, which buffers they contain, how those
buffers are scrolled, and their value of point; also their
fringes, margins, and scroll bar settings.  It also includes the value
of @code{minibuffer-scroll-window}.  As a special exception, the window
configuration does not record the value of point in the selected window
for the current buffer.

  You can bring back an entire frame layout by restoring a previously
saved window configuration.  If you want to record the layout of all
frames instead of just one, use a frame configuration instead of a
window configuration.  @xref{Frame Configurations}.

@defun current-window-configuration &optional frame
This function returns a new object representing @var{frame}'s current
window configuration.  The default for @var{frame} is the selected
frame.  The variable @code{window-persistent-parameters} specifies
which window parameters (if any) are saved by this function.
@xref{Window Parameters}.
@end defun

@defun set-window-configuration configuration
This function restores the configuration of windows and buffers as
specified by @var{configuration}, for the frame that
@var{configuration} was created for, regardless of whether that frame
is selected or not.  The argument @var{configuration} must be a value
that was previously returned by @code{current-window-configuration}
for that frame.

If the frame from which @var{configuration} was saved is dead, all
this function does is to restore the value of the variable
@code{minibuffer-scroll-window} and to adjust the value returned by
@code{minibuffer-selected-window}.  In this case, the function returns
@code{nil}.  Otherwise, it returns @code{t}.

If the buffer of a window of @var{configuration} has been killed since
@var{configuration} was made, that window is, as a rule, removed from
the restored configuration.  However, if that window is the last
window remaining in the restored configuration, another live buffer is
shown in it.

Here is a way of using this function to get the same effect as
@code{save-window-excursion}:

@example
@group
(let ((config (current-window-configuration)))
  (unwind-protect
      (progn (split-window-below nil)
             @dots{})
    (set-window-configuration config)))
@end group
@end example
@end defun

@defmac save-window-excursion forms@dots{}
This macro records the window configuration of the selected frame,
executes @var{forms} in sequence, then restores the earlier window
configuration.  The return value is the value of the final form in
@var{forms}.

Most Lisp code should not use this macro; @code{save-selected-window}
is typically sufficient.  In particular, this macro cannot reliably
prevent the code in @var{forms} from opening new windows, because new
windows might be opened in other frames (@pxref{Choosing Window}), and
@code{save-window-excursion} only saves and restores the window
configuration on the current frame.
@end defmac

@defun window-configuration-p object
This function returns @code{t} if @var{object} is a window configuration.
@end defun

@defun compare-window-configurations config1 config2
This function compares two window configurations as regards the
structure of windows, but ignores the values of point and the
saved scrolling positions---it can return @code{t} even if those
aspects differ.
@end defun

@defun window-configuration-frame config
This function returns the frame for which the window configuration
@var{config} was made.
@end defun

  Other primitives to look inside of window configurations would make
sense, but are not implemented because we did not need them.  See the
file @file{winner.el} for some more operations on windows
configurations.

  The objects returned by @code{current-window-configuration} die
together with the Emacs process.  In order to store a window
configuration on disk and read it back in another Emacs session, you
can use the functions described next.  These functions are also useful
to clone the state of a frame into an arbitrary live window
(@code{set-window-configuration} effectively clones the windows of a
frame into the root window of that very frame only).

@cindex window state
@defun window-state-get &optional window writable
This function returns the state of @var{window} as a Lisp object.  The
argument @var{window} must be a valid window and defaults to the root
window of the selected frame.

If the optional argument @var{writable} is non-@code{nil}, this means to
not use markers for sampling positions like @code{window-point} or
@code{window-start}.  This argument should be non-@code{nil} when the
state will be written to disk and read back in another session.

Together, the argument @var{writable} and the variable
@code{window-persistent-parameters} specify which window parameters are
saved by this function.  @xref{Window Parameters}.
@end defun

The value returned by @code{window-state-get} can be used in the same
session to make a clone of a window in another window.  It can be also
written to disk and read back in another session.  In either case, use
the following function to restore the state of the window.

@defun window-state-put state &optional window ignore
This function puts the window state @var{state} into @var{window}.
The argument @var{state} should be the state of a window returned by
an earlier invocation of @code{window-state-get}, see above.  The
optional argument @var{window} can be either a live window or an
internal window (@pxref{窗口和窗框}).  If @var{window} is not
a live window, it is replaced by a new live window created on the same
frame before putting @var{state} into it.  If @var{window} is @code{nil},
it puts the window state into a new window.

If the optional argument @var{ignore} is non-@code{nil}, it means to ignore
minimum window sizes and fixed-size restrictions.  If @var{ignore}
is @code{safe}, this means windows can get as small as one line
and/or two columns.
@end defun

The functions @code{window-state-get} and @code{window-state-put} also
allow to exchange the contents of two live windows.  The following
function does precisely that:

@deffn Command window-swap-states &optional window-1 window-2 size
This command swaps the states of the two live windows @var{window-1} and
@var{window-2}.  @var{window-1} must specify a live window and defaults
to the selected one.  @var{window-2} must specify a live window and
defaults to the window following @var{window-1} in the cyclic ordering
of windows, excluding minibuffer windows and including live windows on
all visible frames.

Optional argument @var{size} non-@code{nil} means to try swapping the
sizes of @var{window-1} and @var{window-2} as well.  A value of
@code{height} means to swap heights only, a value of @code{width}
means to swap widths only, while @code{t} means to swap both widths
and heights, if possible.  Frames are not resized by this function.
@end deffn


@node 窗口参数
@section Window Parameters
@cindex window parameters

This section describes the window parameters that can be used to
associate additional information with windows.

@defun window-parameter window parameter
This function returns @var{window}'s value for @var{parameter}.  The
default for @var{window} is the selected window.  If @var{window} has no
setting for @var{parameter}, this function returns @code{nil}.
@end defun

@defun window-parameters &optional window
This function returns all parameters of @var{window} and their values.
The default for @var{window} is the selected window.  The return value
is either @code{nil}, or an association list whose elements have the form
@code{(@var{parameter} . @var{value})}.
@end defun

@defun set-window-parameter window parameter value
This function sets @var{window}'s value of @var{parameter} to
@var{value} and returns @var{value}.  The default for @var{window}
is the selected window.
@end defun

By default, the functions that save and restore window configurations
or the states of windows (@pxref{Window Configurations}) do not care
about window parameters.  This means that when you change the value of
a parameter within the body of a @code{save-window-excursion}, the
previous value is not restored when that macro exits.  It also means
that when you restore via @code{window-state-put} a window state saved
earlier by @code{window-state-get}, all cloned windows have their
parameters reset to @code{nil}.  The following variable allows you to
override the standard behavior:

@cindex persistent window parameters
@defvar window-persistent-parameters
This variable is an alist specifying which parameters get saved by
@code{current-window-configuration} and @code{window-state-get}, and
subsequently restored by @code{set-window-configuration} and
@code{window-state-put}.  @xref{Window Configurations}.

The @sc{car} of each entry of this alist is a symbol specifying the
parameter.  The @sc{cdr} should be one of the following:

@table @asis
@item @code{nil}
This value means the parameter is saved neither by
@code{window-state-get} nor by @code{current-window-configuration}.

@item @code{t}
This value specifies that the parameter is saved by
@code{current-window-configuration} and (provided its @var{writable}
argument is @code{nil}) by @code{window-state-get}.

@item @code{writable}
This means that the parameter is saved unconditionally by both
@code{current-window-configuration} and @code{window-state-get}.  This
value should not be used for parameters whose values do not have a read
syntax.  Otherwise, invoking @code{window-state-put} in another session
may fail with an @code{invalid-read-syntax} error.
@end table
@end defvar

Some functions (notably @code{delete-window},
@code{delete-other-windows} and @code{split-window}), may behave
specially when the window specified by their @var{window} argument has
a parameter whose name is equal to the function's name.  You can
override such special behavior by binding the following variable to a
non-@code{nil} value:

@defvar ignore-window-parameters
If this variable is non-@code{nil}, some standard functions do not
process window parameters.  The functions currently affected by this are
@code{split-window}, @code{delete-window}, @code{delete-other-windows},
and @code{other-window}.

An application can bind this variable to a non-@code{nil} value around
calls to these functions.  If it does so, the application is fully
responsible for correctly assigning the parameters of all involved
windows when exiting that function.
@end defvar

The following parameters are currently used by the window management
code:

@table @code
@item delete-window
@vindex delete-window@r{, a window parameter}
This parameter affects the execution of @code{delete-window}
(@pxref{Deleting Windows}).

@item delete-other-windows
@vindex delete-other-windows@r{, a window parameter}
This parameter affects the execution of @code{delete-other-windows}
(@pxref{Deleting Windows}).

@item no-delete-other-windows
@vindex no-delete-other-windows@r{, a window parameter}
This parameter marks the window as not deletable by
@code{delete-other-windows} (@pxref{Deleting Windows}).

@item split-window
@vindex split-window@r{, a window parameter}
This parameter affects the execution of @code{split-window}
(@pxref{Splitting Windows}).

@item other-window
@vindex other-window@r{, a window parameter}
This parameter affects the execution of @code{other-window}
(@pxref{Cyclic Window Ordering}).

@item no-other-window
@vindex no-other-window@r{, a window parameter}
This parameter marks the window as not selectable by @code{other-window}
(@pxref{Cyclic Window Ordering}).

@item clone-of
@vindex clone-of@r{, a window parameter}
This parameter specifies the window that this one has been cloned
from.  It is installed by @code{window-state-get} (@pxref{Window
Configurations}).

@item window-preserved-size
@vindex window-preserved-size@r{, a window parameter}
This parameter specifies a buffer, a direction where @code{nil} means
vertical and @code{t} horizontal, and a size in pixels.  If this window
displays the specified buffer and its size in the indicated direction
equals the size specified by this parameter, then Emacs will try to
preserve the size of this window in the indicated direction.  This
parameter is installed and updated by the function
@code{window-preserve-size} (@pxref{Preserving Window Sizes}).

@item quit-restore
@vindex quit-restore@r{, a window parameter}
This parameter is installed by the buffer display functions
(@pxref{Choosing Window}) and consulted by @code{quit-restore-window}
(@pxref{Quitting Windows}).  It is a list of four elements, see the
description of @code{quit-restore-window} in @ref{Quitting Windows}
for details.

@item window-side
@itemx window-slot
@vindex window-side@r{, a window parameter}
@vindex window-slot@r{, a window parameter}
These parameters are used internally for implementing side windows
(@pxref{Side Windows}).

@item window-atom
@vindex window-atom@r{, a window parameter}
This parameter is used internally for implementing atomic windows, see
@ref{Atomic Windows}.

@item mode-line-format
@vindex mode-line-format@r{, a window parameter}
This parameter replaces the value of the buffer-local variable
@code{mode-line-format} (@pxref{Mode Line Basics}) of this window's
buffer whenever this window is displayed.  The symbol @code{none} means
to suppress display of a mode line for this window.  Display and
contents of the mode line on other windows showing this buffer are not
affected.

@item header-line-format
@vindex header-line-format@r{, a window parameter}
This parameter replaces the value of the buffer-local variable
@code{header-line-format} (@pxref{Mode Line Basics}) of this window's
buffer whenever this window is displayed.  The symbol @code{none} means
to suppress display of a header line for this window.  Display and
contents of the header line on other windows showing this buffer are not
affected.

@item tab-line-format
@vindex tab-line-format@r{, a window parameter}
This parameter replaces the value of the buffer-local variable
@code{tab-line-format} (@pxref{Mode Line Basics}) of this window's
buffer whenever this window is displayed.  The symbol @code{none} means
to suppress display of a tab line for this window.  Display and
contents of the tab line on other windows showing this buffer are not
affected.

@item min-margins
@vindex min-margins@r{, a window parameter}
The value of this parameter is a cons cell whose @sc{car} and
@sc{cdr}, if non-@code{nil}, specify the minimum values (in columns)
for the left and right margin of this window (@pxref{Display Margins}.
When present, Emacs will use these values instead of the actual margin
widths for determining whether a window can be split or shrunk
horizontally.

Emacs never auto-adjusts the margins of any window after splitting or
resizing it.  It is the sole responsibility of any application setting
this parameter to adjust the margins of this window as well as those of
any new window that inherits this window's margins due to a split.
Both @code{window-configuration-change-hook} and
@code{window-size-change-functions} (@pxref{Window Hooks}) should be
employed for this purpose.

This parameter was introduced in Emacs version 25.1 to support
applications that use large margins to center buffer text within a
window and should be used, with due care, exclusively by those
applications.  It might be replaced by an improved solution in future
versions of Emacs.
@end table


@node 窗口钩子
@section Hooks for Window Scrolling and Changes
@cindex hooks for window operations

This section describes how Lisp programs can take action after a
window has been scrolled or other window modifications occurred.  We
first consider the case where a window shows a different part of its
buffer.

@defvar window-scroll-functions
This variable holds a list of functions that Emacs should call before
redisplaying a window with scrolling.  Displaying a different buffer
in a window and making a new window also call these functions.

This variable is not a normal hook, because each function is called
with two arguments: the window, and its new display-start position.
At the time of the call, the display-start position of the argument
window is already set to its new value, and the buffer to be displayed
in the window is set as the current buffer.

These functions must take care when using @code{window-end}
(@pxref{Window Start and End}); if you need an up-to-date value, you
must use the @var{update} argument to ensure you get it.

@strong{Warning:} don't use this feature to alter the way the window
is scrolled.  It's not designed for that, and such use probably won't
work.
@end defvar

In addition, you can use @code{jit-lock-register} to register a Font
Lock fontification function, which will be called whenever parts of a
buffer are (re)fontified because a window was scrolled or its size
changed.  @xref{Other Font Lock Variables}.

@cindex window change functions
   The remainder of this section covers six hooks that are called
during redisplay provided a significant, non-scrolling change of a
window has been detected.  For simplicity, these hooks and the
functions they call will be collectively referred to as @dfn{window
change functions}.

@cindex window buffer change
The first of these hooks is run after a @dfn{window buffer change} is
detected, which means that a window was created, deleted or assigned
another buffer.

@defvar window-buffer-change-functions
This variable specifies functions called during redisplay when window
buffers have changed.  The value should be a list of functions that
take one argument.

Functions specified buffer-locally are called for any window showing
the corresponding buffer if that window has been created or assigned
that buffer since the last time window change functions were run.  In
this case the window is passed as argument.

Functions specified by the default value are called for a frame if at
least one window on that frame has been added, deleted or assigned
another buffer since the last time window change functions were run.
In this case the frame is passed as argument.
@end defvar

@cindex window size change
The second of these hooks is run when a @dfn{window size change} has
been detected which means that a window was created, assigned another
buffer, or changed its total size or that of its text area.

@defvar window-size-change-functions
This variable specifies functions called during redisplay when a
window size change occurred.  The value should be a list of functions
that take one argument.

Functions specified buffer-locally are called for any window showing
the corresponding buffer if that window has been added or assigned
another buffer or changed its total or body size since the last time
window change functions were run.  In this case the window is passed
as argument.

Functions specified by the default value are called for a frame if at
least one window on that frame has been added or assigned another
buffer or changed its total or body size since the last time window
change functions were run.  In this case the frame is passed as
argument.
@end defvar

@cindex window selection change
The third of these hooks is run when a @dfn{window selection change}
has selected another window since the last redisplay.

@defvar window-selection-change-functions
This variable specifies functions called during redisplay when the
selected window or a frame's selected window has changed.  The value
should be a list of functions that take one argument.

Functions specified buffer-locally are called for any window showing
the corresponding buffer if that window has been selected or
deselected (among all windows or among all windows on its frame) since
the last time window change functions were run.  In this case the
window is passed as argument.

Functions specified by the default value are called for a frame if
that frame has been selected or deselected or the frame's selected
window has changed since the last time window change functions were
run.  In this case the frame is passed as argument.
@end defvar

@cindex window state change
The fourth of these hooks is run when a @dfn{window state change} has
been detected, which means that at least one of the three preceding
window changes has occurred.

@defvar window-state-change-functions
This variable specifies functions called during redisplay when a
window buffer or size change occurred or the selected window or a
frame's selected window has changed.  The value should be a list of
functions that take one argument.

Functions specified buffer-locally are called for any window showing
the corresponding buffer if that window has been added or assigned
another buffer, changed its total or body size or has been selected or
deselected (among all windows or among all windows on its frame) since
the last time window change functions were run.  In this case the
window is passed as argument.

Functions specified by the default value are called for a frame if at
least one window on that frame has been added, deleted or assigned
another buffer, changed its total or body size or that frame has been
selected or deselected or the frame's selected window has changed
since the last time window change functions were run.  In this case
the frame is passed as argument.

Functions specified by the default value are also run for a frame when
that frame's window state change flag (see below) has been set since
last redisplay.
@end defvar

@cindex window configuration change
The fifth of these hooks is run when a @dfn{window configuration
change} has been detected which means that either the buffer or the
size of a window changed.  It differs from the four preceding hooks in
the way it is run.

@defvar window-configuration-change-hook
This variable specifies functions called during redisplay when either
the buffer or the size of a window has changed.  The value should be a
list of functions that take no argument.

Functions specified buffer-locally are called for any window showing
the corresponding buffer if at least one window on that frame has been
added, deleted or assigned another buffer or changed its total or
body size since the last time window change functions were run.  Each
call is performed with the window showing the buffer temporarily
selected and its buffer current.

Functions specified by the default value are called for each frame if
at least one window on that frame has been added, deleted or assigned
another buffer or changed its total or body size since the last time
window change functions were run.  Each call is performed with the
frame temporarily selected and the selected window's buffer current.
@end defvar

Finally, Emacs runs a normal hook that generalizes the behavior of
@code{window-state-change-functions}.

@defvar window-state-change-hook
The default value of this variable specifies functions called during
redisplay when a window state change has been detected or the window
state change flag has been set on at least one frame.  The value
should be a list of functions that take no argument.

Applications should put a function on this hook only if they want to
react to changes that happened on (or have been signaled for) two or
more frames since last redisplay.  In every other case, putting the
function on @code{window-state-change-functions} should be preferred.
@end defvar

Window change functions are called during redisplay for each frame as
follows: First, any buffer-local window buffer change function, window
size change function, selected window change and window state change
functions are called in this order.  Next, the default values for
these functions are called in the same order.  Then any buffer-local
window configuration change functions are called followed by functions
specified by the default value of those functions.  Finally, functions
on @code{window-state-change-hook} are run.

   Window change functions are run for a specific frame only if a
corresponding change was registered for that frame earlier.  Such
changes include the creation or deletion of a window or the assignment
of another buffer or size to a window.  Note that even when such a
change has been registered, this does not mean that any of the hooks
described above is run.  If, for example, a change was registered
within the scope of a window excursion (@pxref{Window
Configurations}), this will trigger a call of window change functions
only if that excursion still persists at the time change functions are
run.  If it is exited earlier, hooks will be run only if registered by
a change outside the scope of that excursion.

@cindex window state change flag
   The @dfn{window state change flag} of a frame, if set, will cause
the default values of @code{window-state-change-functions} (for that
frame) and @code{window-state-change-hook} to be run during next
redisplay regardless of whether a window state change actually
occurred for that frame or not.  After running any functions on these
hooks, the flag is reset for each frame.  Applications can set that
flag and inspect its value using the following functions.

@defun set-frame-window-state-change &optional frame arg
This function sets @var{frame}'s window state change flag if @var{arg}
is non-@code{nil} and resets it otherwise.  @var{frame} must be a live
frame and defaults to the selected one.
@end defun

@defun frame-window-state-change &optional frame
This functions returns @code{t} if @var{frame}'s window state change
flag is set and @code{nil} otherwise.  @var{frame} must be a live
frame and defaults to the selected one.
@end defun

   While window change functions are run, the functions described next
can be called to get more insight into what has changed for a specific
window or frame since the last redisplay.  All these functions take a
live window as single, optional argument, defaulting to the selected
window.

@defun window-old-buffer &optional window
This function returns the buffer shown in @var{window} at the last
time window change functions were run for @var{window}'s frame.  If it
returns @code{nil}, @var{window} has been created after that.  If it
returns @code{t}, @var{window} was not shown at that time but has been
restored from a previously saved window configuration afterwards.
Otherwise, the return value is the buffer shown by @code{window} at
that time.
@end defun

@defun window-old-pixel-width &optional window
This function returns the total pixel width of @var{window} the
last time window change functions found @code{window} live on its
frame.  It is zero if @code{window} was created after that.
@end defun

@defun window-old-pixel-height &optional window
This function returns the total pixel height of @var{window} the last
time window change functions found @code{window} live on its frame.
It is zero if @code{window} was created after that.
@end defun

@defun window-old-body-pixel-width &optional window
This function returns the pixel width of @var{window}'s text area the
last time window change functions found @code{window} live on its
frame.  It is zero if @code{window} was created after that.
@end defun

@defun window-old-body-pixel-height &optional window
This function returns the pixel height of @var{window}'s text area the
last time window change functions found @code{window} live on its
frame.  It is zero if @code{window} was created after that.
@end defun

In order to find out which window or frame was selected the last time
window change functions were run, the following functions can be used:

@defun frame-old-selected-window &optional frame
This function returns the selected window of @var{frame} at the last
time window change functions were run.  If omitted or @code{nil}
@var{frame} defaults to the selected frame.
@end defun

@defun old-selected-window
This function returns the selected window at the last time window
change functions were run.
@end defun

@defun old-selected-frame
This function returns the selected frame at the last time window
change functions were run.
@end defun

Note that window change functions provide no information about which
windows have been deleted since the last time they were run.  If
necessary, applications should remember any window showing a specific
buffer in a local variable of that buffer and update it in a function
run by the default values of any of the hooks that are run when a
window buffer change was detected.

   The following caveats should be considered when adding a function
to window change functions:

@itemize @bullet
@item
Some operations will not trigger a call of window change functions.
These include showing another buffer in a minibuffer window or any
change of a tooltip window.

@item
Window change functions should not create or delete windows or change
the buffer, size or selection status of any window because there is no
guarantee that the information about such a change will be propagated
to other window change functions.  If at all, any such change should
be executed only by the last function listed by the default value of
@code{window-state-change-hook}.

@item
Macros like @code{save-window-excursion}, @code{with-selected-window}
or @code{with-current-buffer} can be used when running window change
functions.

@item
Running window change functions does not save and restore match data.
Unless running @code{window-configuration-change-hook} it does not
save or restore the selected window or frame or the current buffer
either.

@item
Any redisplay triggering the run of window change functions may be
aborted.  If the abort occurs before window change functions have run
to their completion, they will be run again with the previous values,
that is, as if redisplay had not been performed.  If aborted later,
they will be run with the new values, that is, as if redisplay had
been actually performed.
@end itemize
