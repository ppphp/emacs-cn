@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990--1994, 1999, 2001--2020 Free Software Foundation,
@c Inc.
@c See the file elisp.texi for copying conditions.
@node 缩写
@chapter Abbrevs and Abbrev Expansion
@cindex abbrev
@c  @cindex abbrev table  Redundant with "abbrev".

  缩写或@dfn{abbrev}是可以扩充为一个较长的字符串的一串字符。用户可以插入缩写
字符串后会发现它被自动替换为缩写的扩展。它省去了打字的时间。

  当前有效的缩写语集记录在@dfn{缩写表}。每个缓冲区都有一个本地的缩写表，但通常
所有的缓冲区在同一主要模式下，共享一个缩写表。还有一个全局的缩写表。通常两者都被
使用。

  缩写表用一个obarray表示。@xref{创建符号}，了解有关obarrays的信息。每个缩写
在obarray中用一个符号表示。符号的名称是缩写；其值为展开；其函数定义是用于执行展
开的钩子函数（@pxref{定义缩写}）；其属性列表单元中包含了各种附加的属性，包括使
用次数和缩写展开次数。（@pxref{缩写属性}）。

@cindex 系统缩写
  某些缩写，称为@dfn{系统缩写}，是由一个主要的模式，而不是用户。 一个系统的缩写
是由它的非@code{nil} @code{:system} 属性 (@pxref{缩写属性})。当缩写被保存
到缩写文件中时，系统缩写将被省略。@xref{缩写文件}.

  因为用于缩写的符号并不在通常的obarray中保留，它们永远不会出现在读取Lisp表达式
的结果中；事实上，除了处理缩写的代码，他们永远不会被使用。因此，它们以非标准方式可
以安全地使用。

  如果启用了次要模式Abbrev模式，缓冲区本地变量@code{abbrev-mode}是非@code{nil}
，缩写会自动地在缓冲区中展开。 关于缩写的用户级命令，请参见
@ref{Abbrevs,, Abbrev Mode, emacs, The GNU Emacs Manual}.

@menu
* 表格: 缩写表.        创建并使用缩写表.
* 定义缩写::            定义缩写和展开.
* 文件: 缩写文件.          文件中保存缩写.
* 展开: 缩写展开.  控制展开; 展开子路线.
* 标准缩写表::      在多种主要模式中使用的缩写表.
* 缩写属性::           如何阅读和设置缩写属性.
                                什么属性有什么效果.
* 缩写表属性::     如何阅读和设置缩写表属性.
                                什么属性有什么效果.
@end menu

@node 缩写表
@section Abbrev Tables
@cindex abbrev tables

  本节介绍如何创建和操作缩写表。

@defun make-abbrev-table &optional props
这个函数创建并返回一个新的、空的缩写表-------一个不包含任何符号的obarray。
它是一个充满零的向量。@var{props}是应用于新表的属性列表。
(@pxref{缩写表属性}).
@end defun

@defun abbrev-table-p object
如果@var{object}是一个缩写表，则该函数返回一个非@code{nil}的值。
@end defun

@defun clear-abbrev-table abbrev-table
此函数取消定义@var{abbrev-table}中的所有缩写词，让它变成空的。
@c 不明白为什么要这么说。
@c 它总是返回@code{nil}。
@c Don't see why this needs saying.
@c It always returns @code{nil}.
@end defun

@defun copy-abbrev-table abbrev-table
这个函数返回@var{abbrev-table}的副本--一个新的缩写表，其中包含相同的缩写定义。它
@emph{不}复制任何属性列表；只有名称、值和函数。
@end defun

@defun define-abbrev-table tabname definitions &optional docstring &rest props
这个函数将@var{tabname}(一个符号)定义为一个缩写表名，比如作为一个变量，其值是一个缩
写表。它根据@var{definitions}定义了表格中的缩写，是一个形式
@code{(@var{abbrevname} @var{expansion}[@var{hook}] [@var{props}...])}的
元素的列表。这些元素作为参数传递到@code{define-abbrev}。 @c 返回值总是 @code{nil}。

可选的字符串@var{docstring}是变量@var{tabname}的文档字符串。属性列表@var{props}
应用于这个缩写表（@pxref{缩写表属性}）。

如果这个函数对同一个@var{tabname}被调用超过一次，后续调用将@var{definitions}中的定
义添加到@var{tabname}，而不是覆盖整个原始内容。(后续的调用只覆盖了明确重新定义的缩写或
是在@var{definitions}中未定义的）。)
@end defun

@defvar abbrev-table-name-list
这是一个值为缩写表的符号列表。@code{define-abbrev-table}将新的缩写表名称添加到这个列
表中。
@end defvar

@defun insert-abbrev-table-description name &optional human
该函数在点前插入名为@var{name}缩写表的描述。参数@var{name}是一个符号，它的值是个缩写表
。 @c 返回值总是@code{nil}。

如果@var{human}是非@code{nil}，则说明是面向人类的。系统缩略语会被列出来，并被识别为系统
缩略语。否则描述是一个Lisp表达式---对@code{define-abbrev-table}的调用会按照当前的定义
来定义@var{name}，但不包括的系统缩写。(使用 @var{name}的模式或软件包应该将这些内容分别
添加到@var{name}中）。)
@end defun

@node 定义缩写
@section Defining Abbrevs
@cindex defining abbrevs

  @code{define-abbrev}是一个底层的基本函数，用于定义缩写表中的一个缩写。

  当一个主要模式定义了一个系统缩写时，它应该调用@code{define-abbrev}并指定@code{:system}
属性为@code{t}。请注意，所有已保存的非系统缩写都会在启动时，比如一些主要模式加载之前被还原。
因此，主要模式被首次加载时不应假定其缩写表为空。

@defun define-abbrev abbrev-table name expansion &optional hook &rest props
这个函数定义了一个在@var{abbrev-table}内名为@var{name}的缩写，可以扩展到@var{expansion}
和调用属性为 @var{props}(@pxref{缩写属性})的@var{hook}。返回值为 @var{name}。
在@var{props}中的@code{:system}属性在这里得到了特殊的处理：如果它的值是@code{force}，那么
它就会覆盖已有的定义，即使是非系统缩写的相同的名字。

@var{name}应该是一个字符串。参数@var{expansion}通常是所需的扩展(一个字符串)，或者@code{nil}
来取消定义缩写。如果它不是字符串或@code{nil}，那么缩写仅通过运行@var{hook}展开。

参数@var{hook}是一个函数或@code{nil}。如果@var{hook}是non-@code{nil}，那么它在缩写被替换为
@var{expansion}时调用，没有参数；当@var{hook}被调用时，光标点位于@var{expansion}的末尾。

@cindex @code{no-self-insert}属性。
如果@var{hook}是非@code{nil}符号，而且这个符号的@code{no-self-insert}属性为非@code{nil}，
@var{hook}可以显式地控制是否要插入触发了该展开的自插入输入字符。如果@var{hook}这时候返回非
@code{nil}，则表示阻止该字符的插入。相反，如果@var{hook}返回@code{nil},@code{expand-abbrev}
(或@code{abbrev-insert})也将返回@code{nil}，就像没有展开过一样。

通常情况下，@code{define-abbrev}会将变量@code{abbrevs-changed}设置为@code{t}，如果它真的
改变了缩写。这是为了让一些命令能够保存缩写。 它不对系统缩写做这个操作，因为这些缩写是不会被保存的。
@end defun

@defopt only-global-abbrevs
如果这个变量是非@code{nil}，意味着用户打算只使用全局缩略语。这告诉了定义特定模式缩写的命令来定义
全局的缩略语。这个变量在本节中不会改变函数的行为；它是由它们的调用者检查。
@end defopt

@node 缩写文件
@section Saving Abbrevs in Files
@cindex save abbrevs in files

  保存缩写定义的文件实际上是一个Lisp代码文件。缩写是以Lisp程序的形式保存的，以在相同的内容内定义相
同的缩写表。因此，您可以使用@code{load}(@pxref{程序如何进行加载})加载文件。然而，函数
@code{quietly-read-abbrev-file}是提供一个更方便的界面。 Emacs会在启动时调用这个函数。

  用户层设施，如@code{save-some-buffers}在此处所述的变量控制下，自动将缩略语存入文件。

@defopt abbrev-file-name
这是读取和保存缩略语的默认文件名。默认情况下，Emacs会寻找@file{~/.emacs.d/abbrev_defs}，并且如
果未找到，寻找@file{~/.abbrev_defs}；如果两个文件都不存在，Emacs将创建
@file{~/.emacs.d/abbrev_defs}。
@end defopt

@defun quietly-read-abbrev-file &optional filename
此函数从名为@var{filename}的文件中读取缩写定义，这个文件之前用@code{write-abbrev-file}写如。如
果@var{filename}被省略或是@code{nil}，则使用@code{abbrev-file-name}中指定的文件。

顾名思义，这个函数不显示任何信息。
@c 它返回@code{nil}。
@end defun

@defopt save-abbrevs
非@code{nil}的@code{save-abbrevs}值意味着Emacs应该在文件保存时保存文件时的缩写（如果有任何改变）。
如果值是@code{silently}，Emacs就会保存缩写，而不询问用户。@code{abbrev-file-name}指定要保存缩写
所在的文件。默认值是@code{t}。
@end defopt

@defvar abbrevs-changed
通过定义或修改任何一个缩写（系统缩写除外），这个变量被设置为非@code{nil}缩写。这是一个标记来对各种Emacs
命令提供保存你的缩写。
@end defvar

@deffn Command write-abbrev-file &optional filename
保存在文件@var{filename}中，对@code{abbrev-table-name-list}中列出的缩写的所有缩写定义（除系统缩写外）
以Lisp程序的形式存在，加载后将会定义相同的缩略语。没有任何缩略语要保存的表格会被忽略。如果@var{filename}
是@code{nil}或是被忽略，使用@code{abbrev-file-name}。本函数返回@code{nil}。
@end deffn

@node 缩写展开
@section Looking Up and Expanding Abbreviations
@cindex looking up abbrevs
@cindex expanding abbrevs
@cindex abbrevs, looking up and expanding

  缩略语通常由某些交互式命令扩展。包括@code{self-insert-command}。本节将介绍
编写这些命令时使用的子路线，以及它们用于通信的变量。

@defun abbrev-symbol abbrev &optional table
本函数返回代表缩写@var{abbrev}的符号。如果没有定义abbrev，则返回@code{nil}。第二个可选参数@var{table}
是用来查找缩写表的表，如果@var{table}是 @code{nil}，则返回 @code{nil}。如果@var{table}是@code{nil}，
那么这个函数首先尝试查找当前缓冲区的本地abbrev表，然后再查找全局abbrev表。
@end defun

@defun abbrev-expansion abbrev &optional table
此函数返回@var{abbrev}将展开的字符串（由当前缓冲区使用的缩写表定义）。如果@var{abbrev}不是一个有效的缩写，
则返回@code{nil}。可选参数 @var{table}指定要使用的缩写表，如@code{abbrev-symbol}之内。
@end defun

@deffn Command expand-abbrev
如果有的话，这条命令会在点前展开缩写。如果点没有跟随一个缩写，这个命令什么都不做。如果要进行展开，它调用
变量@code{abbrev-expand-function}的值的函数，没有参数，并返回该函数的返回。

默认的展开函数当它做了展开，返回缩写符号，否则返回@code{nil}。如果缩写符号有一个钩子函数，而且其
@code{no-self-insert}属性为非@code{nil}，如果这个钩子函数返回@code{nil}，那么默认的扩展函数将返回
@code{nil}，即使确实发生了扩张。
@end deffn

@defun abbrev-insert abbrev &optional name start end
This function inserts the abbrev expansion of @code{abbrev}, replacing
the text between @code{start} and @code{end}.  If @code{start} is
omitted, it defaults to point.  @code{name}, if non-@code{nil}, should
be the name by which this abbrev was found (a string); it is used to
figure out whether to adjust the capitalization of the expansion.  The
function returns @code{abbrev} if the abbrev was successfully
inserted, otherwise it returns @code{nil}.
@end defun

@deffn Command abbrev-prefix-mark &optional arg
This command marks the current location of point as the beginning of
an abbrev.  The next call to @code{expand-abbrev} will use the text
from here to point (where it is then) as the abbrev to expand, rather
than using the previous word as usual.

First, this command expands any abbrev before point, unless @var{arg}
is non-@code{nil}.  (Interactively, @var{arg} is the prefix argument.)
Then it inserts a hyphen before point, to indicate the start of the
next abbrev to be expanded.  The actual expansion removes the hyphen.
@end deffn

@defopt abbrev-all-caps
When this is set non-@code{nil}, an abbrev entered entirely in upper
case is expanded using all upper case.  Otherwise, an abbrev entered
entirely in upper case is expanded by capitalizing each word of the
expansion.
@end defopt

@defvar abbrev-start-location
The value of this variable is a buffer position (an integer or a marker)
for @code{expand-abbrev} to use as the start of the next abbrev to be
expanded.  The value can also be @code{nil}, which means to use the
word before point instead.  @code{abbrev-start-location} is set to
@code{nil} each time @code{expand-abbrev} is called.  This variable is
also set by @code{abbrev-prefix-mark}.
@end defvar

@defvar abbrev-start-location-buffer
The value of this variable is the buffer for which
@code{abbrev-start-location} has been set.  Trying to expand an abbrev
in any other buffer clears @code{abbrev-start-location}.  This variable
is set by @code{abbrev-prefix-mark}.
@end defvar

@defvar last-abbrev
This is the @code{abbrev-symbol} of the most recent abbrev expanded.  This
information is left by @code{expand-abbrev} for the sake of the
@code{unexpand-abbrev} command (@pxref{Expanding Abbrevs,, Expanding
Abbrevs, emacs, The GNU Emacs Manual}).
@end defvar

@defvar last-abbrev-location
This is the location of the most recent abbrev expanded.  This contains
information left by @code{expand-abbrev} for the sake of the
@code{unexpand-abbrev} command.
@end defvar

@defvar last-abbrev-text
This is the exact expansion text of the most recent abbrev expanded,
after case conversion (if any).  Its value is @code{nil} if the abbrev
has already been unexpanded.  This contains information left by
@code{expand-abbrev} for the sake of the @code{unexpand-abbrev} command.
@end defvar

@defvar abbrev-expand-function
The value of this variable is a function that @code{expand-abbrev}
will call with no arguments to do the expansion.  The function can do
anything it wants before and after performing the expansion.
It should return the abbrev symbol if expansion took place.
@end defvar

  The following sample code shows a simple use of
@code{abbrev-expand-function}.  It assumes that @code{foo-mode} is a
mode for editing certain files in which lines that start with @samp{#}
are comments.  You want to use Text mode abbrevs for those lines.  The
regular local abbrev table, @code{foo-mode-abbrev-table} is
appropriate for all other lines.  @xref{Standard Abbrev Tables}, for the
definitions of @code{local-abbrev-table} and @code{text-mode-abbrev-table}.
@xref{Advising Functions}, for details of @code{add-function}.

@smallexample
(defun foo-mode-abbrev-expand-function (expand)
  (if (not (save-excursion (forward-line 0) (eq (char-after) ?#)))
      ;; Performs normal expansion.
      (funcall expand)
    ;; We're inside a comment: use the text-mode abbrevs.
    (let ((local-abbrev-table text-mode-abbrev-table))
      (funcall expand))))

(add-hook 'foo-mode-hook
          (lambda ()
            (add-function :around (local 'abbrev-expand-function)
                          #'foo-mode-abbrev-expand-function)))
@end smallexample

@node Standard Abbrev Tables
@section Standard Abbrev Tables
@cindex standard abbrev tables

  Here we list the variables that hold the abbrev tables for the
preloaded major modes of Emacs.

@defvar global-abbrev-table
This is the abbrev table for mode-independent abbrevs.  The abbrevs
defined in it apply to all buffers.  Each buffer may also have a local
abbrev table, whose abbrev definitions take precedence over those in the
global table.
@end defvar

@defvar local-abbrev-table
The value of this buffer-local variable is the (mode-specific)
abbreviation table of the current buffer.  It can also be a list of
such tables.
@end defvar

@defvar abbrev-minor-mode-table-alist
The value of this variable is a list of elements of the form
@code{(@var{mode} . @var{abbrev-table})} where @var{mode} is the name
of a variable: if the variable is bound to a non-@code{nil} value,
then the @var{abbrev-table} is active, otherwise it is ignored.
@var{abbrev-table} can also be a list of abbrev tables.
@end defvar

@defvar fundamental-mode-abbrev-table
This is the local abbrev table used in Fundamental mode; in other words,
it is the local abbrev table in all buffers in Fundamental mode.
@end defvar

@defvar text-mode-abbrev-table
This is the local abbrev table used in Text mode.
@end defvar

@defvar lisp-mode-abbrev-table
This is the local abbrev table used in Lisp mode.  It is the parent
of the local abbrev table used in Emacs Lisp mode.  @xref{Abbrev Table
Properties}.
@end defvar

@node Abbrev Properties
@section Abbrev Properties
@cindex abbrev properties

Abbrevs have properties, some of which influence the way they work.
You can provide them as arguments to @code{define-abbrev}, and
manipulate them with the following functions:

@defun abbrev-put abbrev prop val
Set the property @var{prop} of @var{abbrev} to value @var{val}.
@end defun

@defun abbrev-get abbrev prop
Return the property @var{prop} of @var{abbrev}, or @code{nil} if the
abbrev has no such property.
@end defun

The following properties have special meanings:

@table @code
@item :count
This property counts the number of times the abbrev has
been expanded.  If not explicitly set, it is initialized to 0 by
@code{define-abbrev}.

@item :system
If non-@code{nil}, this property marks the abbrev as a system abbrev.
Such abbrevs are not saved (@pxref{Abbrev Files}).

@item :enable-function
If non-@code{nil}, this property should be a function of no
arguments which returns @code{nil} if the abbrev should not be used
and @code{t} otherwise.

@item :case-fixed
If non-@code{nil}, this property indicates that the case of the
abbrev's name is significant and should only match a text with the
same pattern of capitalization.  It also disables the code that
modifies the capitalization of the expansion.
@end table

@node Abbrev Table Properties
@section Abbrev Table Properties
@cindex abbrev table properties

Like abbrevs, abbrev tables have properties, some of which influence
the way they work.  You can provide them as arguments to
@code{define-abbrev-table}, and manipulate them with the functions:

@defun abbrev-table-put table prop val
Set the property @var{prop} of abbrev table @var{table} to value @var{val}.
@end defun

@defun abbrev-table-get table prop
Return the property @var{prop} of abbrev table @var{table}, or @code{nil}
if @var{table} has no such property.
@end defun

The following properties have special meaning:

@table @code
@item :enable-function
This is like the @code{:enable-function} abbrev property except that
it applies to all abbrevs in the table.  It is used before even trying
to find the abbrev before point, so it can dynamically modify the
abbrev table.

@item :case-fixed
This is like the @code{:case-fixed} abbrev property except that it
applies to all abbrevs in the table.

@item :regexp
If non-@code{nil}, this property is a regular expression that
indicates how to extract the name of the abbrev before point, before
looking it up in the table.  When the regular expression matches
before point, the abbrev name is expected to be in submatch 1.
If this property is @code{nil}, the default is to use
@code{backward-word} and @code{forward-word} to find the name.  This
property allows the use of abbrevs whose name contains characters of
non-word syntax.

@item :parents
This property holds a list of tables from which to inherit
other abbrevs.

@item :abbrev-table-modiff
This property holds a counter incremented each time a new abbrev is
added to the table.

@end table
