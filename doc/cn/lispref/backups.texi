@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990--1995, 1999, 2001--2020 Free Software Foundation,
@c Inc.
@c See the file elisp.texi for copying conditions.
@node 备份和自动保存
@chapter Backups and Auto-Saving
@cindex backups and auto-saving

  备份文件和自动保存文件是Emacs试图保护用户免受崩溃或用户自己的错误影响的两种方法。
自动保存保存的是当前编辑会话中较早的文本；备份文件保存的是当前会话之前的文件内容。

@menu
* 备份文件::   备份文件如何制作；文件名称如何选择。
* 自动保存::    自动保存文件如何制作;文件名称如何选择。
* 恢复::      @code{revert-buffer}，如何定制行为。
@end menu

@node 备份文件
@section Backup Files
@cindex backup file

  一个@dfn{备份文件}是您正在编辑的文件的旧内容的副本。Emacs会在你第一次保存缓冲区到
其访问的文件中的时候制作一个备份文件。因此，通常情况下，备份文件包含了当前编辑会话之前
的文件内容。备份文件一旦存在，其内容通常不会改变。

  备份通常通过将访问的文件重命名为新的名称来进行。您可以选择指定通过复制访问的文件来
制作备份文件。这个选择对于具有多个名称的文件来说是有区别的；它也会影响到被编辑的文件
是仍然由原来的所有者拥有还是变成由编辑它的用户拥有。

  默认情况下，Emacs会为每个编辑过的文件制作一个备份文件。你可以选择请求编号备份；那么
每个新的备份文件都会得到一个新的名字。您可以在不需要旧的编号备份时删除它们，或者Emacs
可以自动删除它们。

  为了保证性能，操作系统可能不会立即将备份文件的内容写入二级存储，也可能会将备份数据与
原始数据进行别名，直到后来修改其中一个或另一个。 @xref{文件和存储}.

@menu
* 制作备份::    Emacs如何制作备份文件，以及何时制作。
* 重命名或复制::     两个选择：重命名旧文件或复制它。
* 编号备份:: 为每个源文件保留多个备份。  为每个源文件保留多个备份。
* 备份名称::      备份文件名的计算方式；自定义。
@end menu

@node 制作备份
@subsection Making Backup Files
@cindex making backup files

@defun backup-buffer
  这个函数会在合适的时候对当前缓冲区访问的文件进行备份，在第一次保存缓冲区之前，由
@code{save-buffer}调用。在第一次保存缓冲区之前，它被@code{save-buffer}调用。

如果备份是通过重命名进行的，那么返回值是一个形式为
(@var{modes} @var{extra-alist} @var{backupname})的cons单元格，其中
@var{modes}是原始文件的模式位，由@code{file-modes}返回。(
@pxref{Testing Accessibility})，@var{extra-alist}是一个描述原始文件扩展属性
的列表，由@code{file-extended-attributes}返回。(
@pxref{Extended Attributes})，@var{backupname}是备份的名称。

在所有其他情况下（例如，如果是通过复制进行的备份，或者没有进行备份），这个函数返回@code{nil}。

@end defun

@defvar buffer-backed-up
  这个缓冲区本地变量表示这个缓冲区的文件是否已经被备份到这个缓冲区上。如果是非
@code{nil}，则备份文件已经写入。否则，在下一次保存文件时，应该对文件进行备份（如果
启用了备份）。这是一个永久的局部，@code{kill-all-local-variables}不会改变@tie{}它。
@end defvar

@defopt make-backup-files
这个变量决定是否要制作备份文件。如果它是非@code{nil}，那么Emacs会在第一次保存文件
时为每个文件创建备份--前提是@code{backup-inhibited}是@code{nil}。(见下文)。

下面的例子显示了如何改变@code{make-backup-files}变量，它只在Rmail缓冲区中使用，
而不是在其他地方。将它设置为 @code{nil}，就会停止Emacs对这些文件进行备份，这样可以
节省磁盘空间。(你可以把这段代码放在你的init文件中。)

@smallexample
@group
(add-hook 'rmail-mode-hook
          (lambda () (setq-local make-backup-files nil)))
@end group
@end smallexample
@end defopt

@defvar backup-enable-predicate
这个变量的值是在某些场合调用的一个函数，用来决定一个文件是否应该有备份文件。该函数
接收一个参数，即一个要考虑的绝对文件名。如果函数返回@code{nil}，则该文件的备份被
禁用。否则，本节中的其他变量说明是否进行备份以及如何进行备份。

@findex normal-backup-enable-predicate
默认值是@code{normal-backup-enable-predicate}，检查是否是
@code{temporary-file-directory}和@code{small-temporary-file-directory}
的文件。
@end defvar

@defvar backup-inhibited
如果这个变量是非@code{nil}，则会禁止备份。它记录了对访问的文件名进行
@code{backup-enable-predicate}测试的结果。它也可以连贯地被其他根据访问哪个文件
来抑制备份机制使用。例如，VC将这个变量设置为非@code{nil}，以防止为使用版本控制系统
管理的文件做备份。

这是一个永久的局部变量，所以改变主要模式不会丢失它的值。主要模式不应该设置这个
变量---应该设置@code{make-backup-files}。
@end defvar

@defopt backup-directory-alist
这个变量的值是一个文件名模式和备份目录的列表。每个元素看起来像
@smallexample
(@var{regexp} . @var{directory})
@end smallexample

@noindent
名称与@var{regexp}匹配的文件的备份将在@var{directory}中进行。@var{directory}
可以是相对或绝对的。如果是绝对的，那么所有匹配的文件都会被备份到同一个目录中，这个
目录中的文件名将是备份文件的全名，所有的目录分隔符都改为@samp{!}，以防止冲突。如果
您的文件系统截断了所产生的名称，这将无法正常工作。

对于所有备份都进入一个目录的常见情况，alist应该包含一个单元素，将@samp{"."}与适当
的目录配对。

如果这个变量是@code{nil}（默认值），或者它不能匹配文件名，则备份将在原始文件的目录
中进行。

在没有长文件名的 MS-DOS 文件系统中，这个变量总是被忽略。
@end defopt

@defopt make-backup-file-name-function
这个变量的值是用来制作备份文件名的函数。函数@code{make-backup-file-name}调用它。
@xref{Backup Names,,Naming Backup Files}。

这可以是缓冲区本地为特定的文件做一些特殊的事情。如果你改变它，你可能也需要改变
@code{backup-file-name-p}和@code{file-name-sans-versions}。
@end defopt


@node 重命名或复制
@subsection Backup by Renaming or by Copying?
@cindex backup files, rename or copy

  Emacs有两种方式制作备份文件：

@itemize @bullet
@item
Emacs会重命名原始文件，使其成为备份文件，然后将要保存的缓冲区写入一个新的文件中。在这
个过程之后，原文件的任何其他名称（即硬链接）现在都是指备份文件。新文件由进行编辑的用户
拥有，其组是该目录下用户写入新文件的默认组。

@item
Emacs可以将原文件复制到备份文件中，然后用新内容覆盖原文件。 在这个过程之后，原始文件的
任何其他名称（即硬链接）都会继续引用文件的当前（更新）版本。 文件的所有者和组将保持不变。
@end itemize

  第一种方式，重命名，是默认方式。

  变量@code{backup-by-copying}如果是非@code{nil}，则表示使用第二种方法，即复制原
文件，并用新的缓冲区内容覆盖。变量@code{file-precious-flag}如果是非@code{nil}，也
有这样的效果（作为其主要意义的副作用）。@xref{保存缓冲区}。

@defopt backup-by-copying
如果这个变量是非@code{nil}，Emacs总是通过复制来制作备份文件。默认值为@code{nil}。
@end defopt

  以下三个变量，当非@code{nil}时，会导致第二种方法在某些特殊情况下被使用，它们对不属于
特殊情况的文件的处理没有影响。 它们对不属于这些特殊情况的文件的处理没有影响。

@defopt backup-by-copying-when-linked
如果这个变量是非@code{nil}，Emacs会通过复制对多个名字的文件（硬链接）进行备份。默认值
是@code{nil}。

只有当@code{backup-by-copying}是@code{nil}时，这个变量才有意义，因为当这个变量是非
@code{nil}时，总是使用复制。
@end defopt

@defopt backup-by-copying-when-mismatch
如果这个变量是非@code{nil}(默认值)，Emacs会在重命名会改变文件所有者或文件组的情况下
通过复制进行备份。

当重命名不会改变文件的所有者或组时，也就是对于用户拥有的文件，并且其组与用户创建的新文件
的默认值相匹配时，这个变量的值没有任何影响。

只有当@code{backup-by-copy}为@code{nil}时，这个变量才有意义，因为当这个变量为非
@code{nil}时，总是使用复制。
@end defopt

@defopt backup-by-copying-when-privileged-mismatch
这个变量如果是非@code{nil}，则指定与@code{backup-by-copying-when-mismatch}相同的
行为，但只适用于特定的user-id和group-id值：即小于或等于某个数字。
您将这个变量设置为该数字。

因此，如果您将@code{backup-by-copying-when-privileged-mismatch}设置为0，则只对超级
用户和0组进行复制备份，以防止文件的所有者发生变化。

默认为200。
@end defopt

@node 编号备份
@subsection Making and Deleting Numbered Backup Files
@cindex numbered backups

  如果一个文件的名字是@file{foo}，那么它的编号备份版本的名字就是@file{foo.~@var{v}~}，
@var{v}是不同的整数，像这样。@file{foo.~1~}、@file{foo.~2~}、@file{foo.~3~}、
@dots{}、@file{foo.~259~}等。

@defopt version-control
此变量控制制作单个非编号的备份文件还是多个编号的备份。

@table @asis
@item @code{nil}
如果访问的文件已经有编号备份，则进行编号备份；否则，不进行备份。 这是默认的。

@item @code{never}
不制作编号的备份。

@item @var{anything else}
制作编号的备份。
@end table
@end defopt

  使用编号备份最终会导致大量的备份版本，然后必须将其删除。 Emacs可以自动进行删除，也可以询问
用户是否要删除它们。

@defopt kept-new-versions
此变量的值是在进行新的编号备份时要保留的最新版本数。新做的备份包含在计数中。 默认值为@tie{}2。
@end defopt

@defopt kept-old-versions
此变量的值是在进行新的编号备份时，要保留的最旧版本的数量，默认值是@tie{}2。
@end defopt

  如果有编号为1、2、3、5、7的备份，且这两个变量的值都为2，那么编号为1、2的备份作为旧版本保留，
编号为5、7的备份作为新版本保留，备份版本3是多余的。函数@code{find-backup-file-name}
(@pxref{备份名称})负责确定要删除哪些备份版本，但自己不删除。

@defopt delete-old-versions
如果这个变量是@code{t}，那么保存文件就会默默删除多余的备份版本。如果是@code{nil}，则意味着在
删除多余的备份之前要求确认。否则，它们将不会被删除。
@end defopt

@defopt dired-kept-versions
这个变量指定在Dired命令中保留多少个最新的备份版本@kbd{.}。(@code{dired-clean-directory})。
这与@code{kept-new-versions}在制作新的备份文件时指定的内容相同。默认是@tie{}2。
@end defopt

@node 备份名称
@subsection Naming Backup Files
@cindex naming backup files

  记录本节中的功能，主要是因为您可以通过重新定义备份文件的命名约定来定制它们。如果您更改了一个，
您可能需要更改其余的功能。

@defun backup-file-name-p filename
如果@var{filename}是一个可能的备份文件名，则此函数返回一个非@code{nil}值。它只是检查文件名，
而不检查是否存在@var{filename}这个名字的文件。

@smallexample
@group
(backup-file-name-p "foo")
     @result{} nil
@end group
@group
(backup-file-name-p "foo~")
     @result{} 3
@end group
@end smallexample

这个函数的标准定义如下：

@smallexample
@group
(defun backup-file-name-p (file)
  "Return non-nil if FILE is a backup file \
name (numeric or not)..."
  (string-match "~\\'" file))
@end group
@end smallexample

@noindent
因此，如果文件名以@samp{~}结尾，函数返回一个非@code{nil}值。(我们使用反斜杠将文件字符串的第一
行在文本中分成两行，但在字符串本身中只产生一行)。

这个简单的表达式被放置在一个单独的函数中，以便于重新定义进行定制。
@end defun

@defun make-backup-file-name filename
此函数返回一个字符串，该字符串是文件@var{filename}的非编号备份文件的名称。在Unix系统中，它只不
过在@var{filename}后面加一个浪号。

在大多数操作系统上，此函数的标准定义如下：

@smallexample
@group
(defun make-backup-file-name (file)
  "Create the non-numeric backup file name for FILE..."
  (concat file "~"))
@end group
@end smallexample

您可以通过重新定义这个函数来改变备份文件的命名约定。下面的例子重新定义了
@code{make-backup-file-name}，除了附加一个浪号外，还在前面加上 @samp{.}：

@smallexample
@group
(defun make-backup-file-name (filename)
  (expand-file-name
    (concat "." (file-name-nondirectory filename) "~")
    (file-name-directory filename)))
@end group

@group
(make-backup-file-name "backups.texi")
     @result{} ".backups.texi~"
@end group
@end smallexample

Emacs的某些部分，包括一些Dired命令，假定备份文件名以@samp{~}结尾。如果你不遵循这一惯例，不会造成严重
的问题，但这些命令可能会产生不理想的结果。
@end defun

@defun find-backup-file-name filename
此函数为@var{filename}计算新备份文件的文件名。它也可以建议删除某些现有的备份文件。
@code{find-backup-file-name}返回一个列表，其中@sc{car}是新备份文件的名称，@sc{cdr}是建议删除的
备份文件列表。该值也可以是@code{nil}，表示不做备份。

两个变量@code{kept-old-versions}和@code{kept-new-versions}决定了应该保留哪些备份版本。这个函数
通过将这些版本从@sc{cdr}的值中排除，来保留这些版本。
@xref{编号备份}。

在这个例子中，该值表示@file{~rms/foo.~5~}是新的备份文件的名称，@file{~rms/foo.~3~}是一个多余的
版本，调用者现在应该考虑删除。

@smallexample
@group
(find-backup-file-name "~rms/foo")
     @result{} ("~rms/foo.~5~" "~rms/foo.~3~")
@end group
@end smallexample
@end defun

@c Emacs 19 feature
@defun file-newest-backup filename
此函数返回@var{filename}最近的备份文件名，如果该文件没有备份文件，则返回@code{nil}。

一些文件比较命令会使用此函数以便自动地比较一份文件与它最近的备份文件。
@end defun

@node 自动保存
@section Auto-Saving
@c @cindex auto-saving   Lots of symbols starting with auto-save here.

  Emacs 会定期保存您正在访问的所有文件，这被称为@dfn{自动保存}。自动保存可以防止你在系统崩溃时丢失超过
有限数量的工作。默认情况下，每按300次键，或者在30秒左右的空闲时间后，就会自动保存。@xref{Auto Save, Auto
Save, Auto-Saving: Protection Against Disasters, emacs, The GNU Emacs Manual}，为用户提供自动
保存的信息。 这里我们介绍一下实现自动保存的函数以及控制这些函数的变量。

@defvar buffer-auto-save-file-name
这个缓冲区本地变量是用来自动保存当前缓冲区的文件名。如果缓冲区不应该被自动保存，那么这个变量就是@code{nil}。

@example
@group
buffer-auto-save-file-name
     @result{} "/xcssun/users/rms/lewis/#backups.texi#"
@end group
@end example
@end defvar

@deffn Command auto-save-mode arg
这是自动保存模式的模式命令，是一种缓冲区本地次要模式。启用自动保存模式后，缓冲区内的自动保存功能将被启用。调用
约定与其他次要模式命令相同（@pxref{次要模式约定}）。

与大多数次要模式不同，这里没有@code{auto-save-mode}变量。如果@code{buffer-auto-save-file-name}是非
@code{nil}，并且@code{buffer-saved-size}(见下文)为非零，则启用自动保存模式。
@end deffn

@defun auto-save-file-name-p filename
如果@var{filename}是一个可能是自动保存文件名的字符串，则此函数返回一个非@code{nil}值。它假定自动保存文件的
命名惯例：井号(@samp{#})开头和结尾的文件名是一个可能的自动保存文件名。参数@var{filename}不应包含目录部分。

@example
@group
(make-auto-save-file-name)
     @result{} "/xcssun/users/rms/lewis/#backups.texi#"
@end group
@group
(auto-save-file-name-p "#backups.texi#")
     @result{} 0
@end group
@group
(auto-save-file-name-p "backups.texi")
     @result{} nil
@end group
@end example

这个函数的标准定义如下：

@example
@group
(defun auto-save-file-name-p (filename)
  "Return non-nil if FILENAME can be yielded by..."
  (string-match "^#.*#$" filename))
@end group
@end example

这个函数的存在，是为了让您在想改变自动保存文件的命名习惯时，可以自定义它。如果您重新定义它，请务必相应地重新定义函数
@code{make-auto-save-file-name}。
@end defun

@defun make-auto-save-file-name
该函数返回用于自动保存当前缓冲区的文件名。这只是一个带上了井号（@samp{#}）的文件名。本函数不查看变量
@code{auto-save-visited-file-name}（如下所述）；本函数的调用方应该首先检查该变量。

@example
@group
(make-auto-save-file-name)
     @result{} "/xcssun/users/rms/lewis/#backups.texi#"
@end group
@end example

这是一个这个函数的标准定义的简化版：

@example
@group
(defun make-auto-save-file-name ()
  "Return file name to use for auto-saves \
of current buffer.."
  (if buffer-file-name
@end group
@group
      (concat
       (file-name-directory buffer-file-name)
       "#"
       (file-name-nondirectory buffer-file-name)
       "#")
    (expand-file-name
     (concat "#%" (buffer-name) "#"))))
@end group
@end example

这是一个独立的函数，您可以重新定义它来定制自动保存文件的命名规则。请务必以相应的方式修改@code{auto-save-file-name-p}。
@end defun

@defopt auto-save-visited-file-name
如果这个变量是非@code{nil}，Emacs就会自动保存缓冲区在其访问的文件中。也就是说，自动保存是在你正在编辑的同一个文件中进行
的。通常情况下，这个变量是@code{nil}，所以自动保存的文件有不同的文件名，这些文件名是由
@code{make-auto-save-file-name}创建。

当你改变这个变量的值时，直到下次重启自动保存模式前，新的值不会在现有的缓冲区中生效。如果已经启用了自动保存模式，那么自动保存
将继续以相同的文件名进行，直到再次调用@code{auto-save-mode}。

请注意，将这个变量设置为非@code{nil}值并不会改变自动保存与保存缓冲区不同的事实；例如，当缓冲区被自动保存时，
@ref{保存缓冲区}中描述的钩子是@emph{不}运行的。

@end defopt

@defun recent-auto-save-p
如果当前缓冲区在上次读入或保存后被自动保存，该函数返回@code{t}。
@end defun

@defun set-buffer-auto-saved
该功能将当前的缓冲区标记为自动保存。除非缓冲区的文字被再次修改，否则缓冲区不会再被自动保存。该函数返回@code{nil}。
@end defun

@defopt auto-save-interval
这个变量的值指定了自动保存的频率，以输入事件的数量为单位。每次读取这么多额外的输入事件时，Emacs就会对所有启用自动保存的缓冲区
进行自动保存。将其设置为0，则根据输入的字符数禁止自动保存。
@end defopt

@defopt auto-save-timeout
这个变量的值是导致自动保存的空闲时间的秒数。每当用户暂停这么长的时间，Emacs就会对所有启用自动保存的缓冲区进行自动保存。如果
当前缓冲区很大，指定的超时时间会乘以一个系数，这个系数会随着缓冲区大小的增加而增加；对于百万字节的缓冲区，这个系数几乎是4。

如果该值为0或@code{nil}，则不会因为空闲而自动保存，只有在@code{auto-save-interval}指定的输入事件达到一定数量后才会自动保存。
@end defopt

@defvar auto-save-hook
每当自动保存即将发生时，就会运行这个正常的钩子。
@end defvar

@defopt auto-save-default
如果这个变量是非@code{nil}，那么正在访问文件的缓冲区默认启用自动保存功能。否则，它们不会。
@end defopt

@deffn Command do-auto-save &optional no-message current-only
该功能自动保存所有需要自动保存的缓冲区。它保存所有启用了自动保存功能并且在上次自动保存后发生了变化的缓冲区。

如果有缓冲区被自动保存，@code{do-auto-save}通常会在自动保存时在回声区显示@samp{Auto-saving...}的消息。但是，如果
@var{no-message}是非@code{nil}，则消息会被抑制。

如果@var{current-only}是非@code{nil}，则只自动保存当前的缓冲区。
@end deffn

@defun delete-auto-save-file-if-necessary &optional force
如果@code{delete-auto-save-files}是非@code{nil}，则该函数将删除当前缓冲区的自动保存文件。每次保存缓冲区时都会调用这个函数。

除非@var{force}是非@code{nil}，否则只有当文件在上次真正保存后被当前Emacs会话写入时，这个函数才会删除文件。
@end defun

@defopt delete-auto-save-files
这个变量被函数@code{delete-auto-save-file-if-necessary}使用。如果它是非@code{nil}，Emacs会在真正保存时（在访问的文件
中）删除自动保存文件。 这样可以节省磁盘空间，并解除目录的混乱。
@end defopt

@defun rename-auto-save-file
如果访问的文件名发生了变化，该函数将调整当前缓冲区的自动保存文件名。如果在当前Emacs会话中创建了自动保存文件，它还会重命名现有的
自动保存文件。如果访问的文件名没有改变，这个函数什么也不做。
@end defun

@defvar buffer-saved-size
这个缓冲区局部变量的值是当最后一次读入、保存或自动保存的时候当前缓冲区的长度。这个值用于检测缓冲区的大小是否大幅减少，并关闭
自动保存。

如果是@minus{}1，则表示该缓冲区的自动保存功能因大小大幅减少而暂时关闭。显式地保存缓冲区会在这个变量中存储一个正值，从而重新
启用自动保存。关闭或开启自动保存模式也会更新这个变量，这样就会忘记缓冲区大小的大幅减少。

如果是@minus{}2，意味着这个缓冲区应该无视缓冲区大小的变化，特别是不应该因为缓冲区大小的变化而暂时关闭自动保存。
@end defvar

@defvar auto-save-list-file-name
这个变量(如果非@code{nil})指定了一个用于记录所有自动保存文件的名称的文件。每次Emacs进行自动保存时，它都会为每个启用了自动
保存功能的缓冲区写入两行到这个文件中。第一行给出了被访问的文件名（如果缓冲区没有文件名的话是空的），第二个给出了自动保存的
文件名。

当Emacs正常退出时，它会删除这个文件；如果Emacs崩溃，你可以在文件中查找所有可能包含工作的自动保存文件，否则就会丢失。
@code{recover-session}命令使用这个文件来查找它们。

这个文件的默认名称指定了你的主目录，并以@samp{.saves-}开头。它还包含Emacs进程@acronym{ID}和主机名。

@end defvar

@defopt auto-save-list-file-prefix
Emacs读取您的init文件后，它会根据这个前缀初始化@code{auto-save-list-file-name}(如果您还没有将其设置为非
@code{nil})，并添加主机名和进程ID@。如果您在初始化文件中设置为@code{nil}，那么Emacs不会初始化
@code{auto-save-list-file-name}。
@end defopt

@node 恢复
@section Reverting
@cindex reverting buffers

  如果您对一个文件做了大量的修改，然后又改变了主意，您可以使用@code{revert-buffer}命令读取文件的前一版本来
删除它们。@xref{Reverting, , Reverting a Buffer, emacs, The GNU Emacs Manual}.

@deffn Command revert-buffer &optional ignore-auto noconfirm preserve-modes
该命令将缓冲区文本替换为磁盘上被访问文件的文本。这个操作会撤销自文件被访问或保存以来的所有更改。

默认情况下，如果最新的自动保存文件比被访问的文件更近，并且@var{ignore-auto}参数是@code{nil}，
@code{revert-buffer}会询问用户是否使用该自动保存文件。当你交互式调用这个命令时，如果没有数字前缀参数，
@var{ignore-auto}就是@code{t}；因此，交互式默认是不检查自动保存文件。

通常情况下，@code{revert-buffer}在更改缓冲区之前会要求确认；但如果参数@var{noconfirm}是非
@code{nil}，@code{revert-buffer}就不会要求确认。

通常情况下，这条命令会使用@code{normal-mode}重新初始化缓冲区的主模式和次要模式。但如果
@var{preserve-modes}是非@code{nil}，则模式保持不变。

恢复通过使用@code{insert-file-contents}的替换功能来尝试保留缓冲区中的标记位置。如果在
还原操作前，缓冲区内容和文件内容相同，则还原将保留所有的标记。如果它们不一样，则还原操作就
会改变缓冲区；在这种情况下，它将保留缓冲区开始和结束处未改变的文本（如果有的话）中的标记。
保留任何额外的标记可能有问题。

@end deffn

@defvar revert-buffer-in-progress-p
@code{revert-buffer}在执行时将这个变量绑定到一个非@code{nil}值。
@end defvar

你可以通过设置本节其余部分描述的变量来定制@code{revert-buffer}的工作方式。

@defopt revert-without-query
这个变量保存了一个无需查询就能还原的文件列表。其值是一个正则表达式的列表。如果访问的文件名
与这些正则表达式中的一个相匹配，并且文件在磁盘上发生了变化，但缓冲区没有被修改，那么
@code{revert-buffer}就会还原文件，而不需要用户确认。
@end defopt

  一些主要模式通过为这些变量做缓冲区本地绑定来自定义@code{revert-buffer}。

@defvar revert-buffer-function
@anchor{Definition of revert-buffer-function}
这个变量的值是用来还原这个缓冲区的函数。它应该是一个带有两个可选参数的函数来完成还原的工作。
这两个可选参数@var{ignore-auto}和@var{noconfirm}就是@code{revert-buffer}收到的参数。

如Dired这样的模式，在这种模式下，被编辑的文本并不由文件内容组成，而是可以通过其他方式再生成，
可以给这个变量一个缓冲区本地的值，是再生成内容的特殊函数。
@end defvar

@defvar revert-buffer-insert-file-contents-function
这个变量的值指定了在还原这个缓冲区时要使用的函数来插入更新的内容。该函数接收两个参数：首先
是要使用的文件名；其次是@code{t}，如果用户要求读取自动保存的文件。

一个模式之所以要改变这个变量而不是@code{revert-buffer-function}，是为了避免重复或替换
@code{revert-buffer}所做的其他工作：请求确认、清除撤销列表、决定合适的主要模式，以及运行
下面列出的钩子。
@end defvar

@defvar before-revert-hook
这个正常钩子是由默认的@code{revert-buffer-function}在插入修改内容之前运行的。自定义
的@code{revert-buffer-function}可以运行这个钩子，也可以不运行。
@end defvar

@defvar after-revert-hook
这个正常钩子是由默认的@code{revert-buffer-function}在插入修改内容之后运行的。自定义
的@code{revert-buffer-function}可以运行这个钩子，也可以不运行。
@end defvar

Emacs可以自动还原缓冲区。对于访问文件的缓冲区，它默认是这样做的。下面介绍了如何添加对自动
还原新类型缓冲区的支持。

首先，这类缓冲区必须定义一个合适的@code{revert-buffer-function}和
@code{buffer-stale-function}。

@defvar buffer-stale-function
这个变量的值指定了一个要调用的函数来检查缓冲区是否需要还原。默认值只处理正在访问文件的缓冲
区，通过检查它们的修改时间。不访问文件的缓冲区需要一个自定义的函数，该函数有一个可选的参数
@var{noconfirm}。如果缓冲区应该被还原，该函数应该返回非@code{nil}。当这个函数被调用
时，缓冲区是当前的。

虽然这个函数主要用于自动还原，但它也可以用于其他目的。例如，如果没有启用自动还原功能，它
可以用来警告用户需要还原缓冲区。@var{noconfirm}参数背后的想法是，如果缓冲区不需要询问
用户就会被还原，那么它应该是@code{t}，如果函数只是用来警告用户缓冲区已经过期，那么它应该
是@code{nil}。特别是在自动还原中使用时，@var{noconfirm}就是@code{t}。如果函数只用于
自动还原，你可以忽略@var{noconfirm}参数。

如果你只是想每隔@code{auto-revert-interval}秒就自动进行一次自动还原（就像缓冲区菜单
一样），可以使用：

@example
(setq-local buffer-stale-function
     (lambda (&optional noconfirm) 'fast))
@end example

@noindent
在缓冲区的模式函数里。

特殊的返回值@samp{fast}告诉调用者，还没有检查是否需要还原，但还原缓冲区的速度很快。
它还告诉自动还原不会打印任何还原信息，即使@code{auto-revert-verbose}是非
@code{nil}。这一点很重要，因为每隔@code{auto-revert-interval}秒钟就会收到一次
恢复信息，这可能会让人很烦。如果函数被用于自动回复以外的其他目的，那么这个返回值提供
的信息也会很有用。
@end defvar

一旦缓冲区有了合适的@code{revert-buffer-function}和
@code{buffer-stale-function}，通常还会有几个问题。

只有当缓冲区被标记为未修改时，它才会自动还原。因此，您必须确保各种函数在下列情况下才
会标记缓冲区为修改状态：缓冲区中包含的信息可能会因为还原而丢失，或者有理由相信用户
可能会因为自动还原而感到不便，因为他正在积极地处理缓冲区。用户总是可以通过手动调整
缓冲区的修改状态来覆盖这一点。为了支持这一点，在一个被标记为未修改的缓冲区上调用
@code{revert-buffer-function}，应该始终保持缓冲区的未修改状态。

保证点不会因为自动还原的结果而连续跳转是很重要的。 当然，如果缓冲区发生了根本性的变化
，移动点可能是不可避免的。

你应该确保@code{revert-buffer-function}不会打印出不必要的重复自动恢复自身的消息
，如果@code{auto-revert-verbose}是@code{t}，则显示的消息，并且有效地覆盖了
@code{auto-revert-verbose}的一个@code{nil}值。因此，采用自动恢复的模式往往涉及
到摆脱这种消息。 这对于每@code{auto-revert-interval}秒钟自动还原一次的缓冲区尤其
重要。

如果新的自动还原是Emacs的一部分，你应该在
@code{global-auto-revert-non-file-buffers}的文档字符串中提到它。

同样，你应该在Emacs手册中记录新增的内容。
