@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990--1995, 1998--1999, 2001--2020 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node 缓冲区
@chapter Buffers
@cindex buffer

  一个@dfn{buffer}是一个包含要编辑的文本的Lisp对象。缓冲区用来保存正在访问
的文件的内容，也可能存在不访问文件的缓冲区。虽然在同一时间可能存在多个缓冲区
，但在任何时候只有一个缓冲区被指定为@dfn{current buffer}。大多数编辑命令都
会对当前缓冲区的内容进行操作。每一个缓冲区，包括当前缓冲区，可以在任何窗口中
显示，也可以不显示。

@menu
* 缓冲区基础::   什么是缓冲区？
* 当前缓冲区::   指定缓冲区为当前缓冲区以便原语能够访问其内容。
* 缓冲区名称::   访问和更改缓冲区名称。
* 缓冲区文件名:: 指示被缓冲区访问的文件的文件名。
* 缓冲区修改::   如果需要保存缓冲区，则是@dfn{modified}的。
* 修改时间::    判断被访问的文件是否在Emacs之外被修改。
* 只读缓冲区::  只读缓冲区中不允许修改文本。
* 缓冲区列表::  如何查看所有现有的缓冲区。
* 创建缓冲区::  创建缓冲区的函数。
* 杀死缓冲区::  缓冲区一直存在，直到被明确杀死。
* 间接缓冲区::  间接缓冲区与其他缓冲区共享文本。
* 交换文本::    在两个缓冲区之间交换文本。
* 缓冲区间隙::  缓冲区的间隙。
@end menu

@node 缓冲区基础
@section Buffer Basics

@ifnottex
  一个@dfn{buffer}是一个包含要编辑的文本的Lisp对象。缓冲区用来保存正在访问
的文件的内容，也可能存在不访问文件的缓冲区。虽然通常存在多个缓冲区，但无论何
时只有一个缓冲区会指定为@dfn{current buffer}。大多数编辑命令都是在当前缓冲
区的内容上执行。每一个缓冲区，包括当前缓冲区，可以也可以不显示在任意一个窗口
中。
@end ifnottex

  Emacs编辑中的缓冲区是指具有独一无二名称的对象，存放着可以编辑的文本。在
Lisp程序中，缓冲区是作为一种特殊的数据类型出现的。你可以把缓冲区的内容看作是一个可以扩展的字符串；在缓冲区的任何部分都可以进行插入和删除。@xref{Text}。

  一个Lisp缓冲区对象包含了许多信息。其中一些信息可以通过变量被程序员直接访
问，而另一些信息只能通过特殊用途的函数来访问。例如，被访问的文件名可以通过变
量直接访问，而点的值只能通过一个原语函数访问。

  可以直接访问的特定缓冲区信息存储在@dfn{buffer-local}变量绑定中，这些变量
值只在特定缓冲区中有效。这个功能允许每个缓冲区覆盖某些变量的值。大多数主要模式都以这种方式覆盖了@code{fill-column}或@code{comment-column}等变量。关于缓冲区局部变量和相关函数的更多信息，参见@ref{缓冲区局部变量}。

  有关访问缓冲区中文件的函数和变量，参见@ref{Visiting Files}和
@ref{Saving Buffers}。有关在窗口中显示缓冲区的函数和变量，请参见
@ref{缓冲区和窗口}。

@defun bufferp object
如果@var{object}是缓冲区返回@code{t}，否则返回@code{nil}。
@end defun

@node 当前缓冲区
@section The Current Buffer
@cindex selecting a buffer
@cindex changing to another buffer
@cindex current buffer

  一般来说，Emacs 会话中有很多缓冲区。在任何时候，其中的一个缓冲区被指定为
@dfn{current buffer}--也就是进行大部分编辑的缓冲区。大多数用于检查或更改
文本的原语都是在当前缓冲区(@pxref{Text})上隐式操作的。

  通常情况下，所选窗口中显示的缓冲区是当前缓冲区，但并非总是如此：Lisp程序
可以临时指定任何缓冲区为当前缓冲区，以便对其内容进行操作，而不改变屏幕上显示
的内容。指定当前缓冲区的最基本功能是@code{set-buffer}。

@defun current-buffer
这个函数返回当前缓冲区。

@example
@group
(current-buffer)
     @result{} #<buffer buffers.texi>
@end group
@end example
@end defun

@defun set-buffer buffer-or-name
这个函数使@var{buffer-or-name}成为当前缓冲区。@var{buffer-or-name}必须是
一个现有的缓冲区，或者是一个现有缓冲区的名称。返回值是当前缓冲区的值。

这个函数不会在任何窗口中显示缓冲区，所以用户不一定能看到缓冲区。
但现在Lisp程序将对它进行操作。
@end defun

  当一个编辑命令返回到编辑器命令循环时，Emacs会自动调用@code{set-buffer}在所
选窗口中显示的缓冲区上。这是为了防止迷惑：它确保当Emacs读取一条命令时，光标
所在的缓冲区就是该命令适用的缓冲区（@pxref{Command Loop}）。因此，您不应该
使用@code{set-buffer}来明显地切换到不同的缓冲区；为此，请使用
@ref{切换缓冲区}中描述的函数。

  在编写Lisp函数时，请@emph{not}依赖命令循环的这种行为以便操作后恢复当前缓冲
区。编辑命令也可以被其他程序作为Lisp函数调用，而不仅仅是从命令循环中调用；如
果子程序不改变当前是哪个缓冲区，对调用者来说是很方便的（当然，除非这就是子程
序的目的）。

  如果要临时对另一个缓冲区进行操作，可以把@code{set-buffer}放在
@code{save-current-buffer}形式中。这里有一个例子，是命令
@code{append-to-buffer}的简化版本。

@example
@group
(defun append-to-buffer (buffer start end)
  "Append the text of the region to BUFFER."
  (interactive "BAppend to buffer: \nr")
  (let ((oldbuf (current-buffer)))
    (save-current-buffer
      (set-buffer (get-buffer-create buffer))
      (insert-buffer-substring oldbuf start end))))
@end group
@end example

@noindent
这里，我们绑定了一个本地变量来记录当前的缓冲区，然后
@code{save-current-buffer}安排它在以后再次成为当前的缓冲区。接下来，
@code{set-buffer}使指定的缓冲区成为当前缓冲区，
@code{insert-buffer-substring}将字符串从原始缓冲区复制到指定的（现在是当前
）缓冲区。

  另一种方法是，我们也可以使用@code{with-current-buffer}宏。

@example
@group
(defun append-to-buffer (buffer start end)
  "Append the text of the region to BUFFER."
  (interactive "BAppend to buffer: \nr")
  (let ((oldbuf (current-buffer)))
    (with-current-buffer (get-buffer-create buffer)
      (insert-buffer-substring oldbuf start end))))
@end group
@end example

  在这两种情况下，如果附加到的缓冲区恰好显示在某个窗口中，下一次重新显示将显
示其文本的变化情况。如果它没有在任何窗口中显示，你不会立即在屏幕上看到变化。
该命令会使缓冲区暂时成为当前状态，但不会使其显示。

  如果您为一个变量做了本地绑定（使用@code{let}或函数参数），而这个变量可能
也有缓冲区本地绑定，请确保在本地绑定的作用域的开始和结束时，当前缓冲区是同一个。 否则你可能在一个缓冲区中绑定了它，而在另一个缓冲区中取消了绑定。

  不要依赖使用@code{set-buffer}将当前的缓冲区改回来，因为如果在错误的缓冲区
处于当前状态时发生了退出，那将无法完成任务。例如，在前面的例子中，这样做是错
误的：

@example
@group
  (let ((oldbuf (current-buffer)))
    (set-buffer (get-buffer-create buffer))
    (insert-buffer-substring oldbuf start end)
    (set-buffer oldbuf))
@end group
@end example

@noindent
使用@code{save-current-buffer}或@code{with-current-buffer}，就像我们所做
的那样，正确地处理了退出、错误和 @code{throw}，以及普通的求值。

@defspec save-current-buffer body@dots{}
@code{save-current-buffer}特殊表单保存当前缓冲区的标识，求值@var{body}表单
，最后将该缓冲区恢复为当前状态。返回值是@var{body}中最后一个表单的值。即使
在通过@code{throw}或错误(@pxref{Nonlocal Exits})异常退出的情况下，也会恢
复当前缓冲区。

如果在@code{save-current-buffer}退出时，曾经是当前的缓冲区已经被杀死了，那
么它当然不会再次成为当前缓冲区。相反，在退出前处于当前状态的缓冲区将保持当前
状态。
@end defspec

@defmac with-current-buffer buffer-or-name body@dots{}
@code{with-current-buffer}宏保存当前缓冲区的标识，使@var{buffer-or-name}
成为当前缓冲区，评估@var{body}形式，最后恢复当前缓冲区。
@var{buffer-or-name}必须指定一个现有的缓冲区或一个现有缓冲区的名称。

返回值是@var{body}中最后一个表单的值。即使在通过@code{throw}异常退出或出错
（@pxref{Nonlocal Exits}）的情况下，也会恢复当前缓冲区。

@end defmac

@defmac with-temp-buffer body@dots{}
@anchor{Definition of with-temp-buffer}
@code{with-temp-buffer}宏以临时缓冲区作为当前缓冲区求值@var{body}表单。
它保存当前缓冲区的标识，创建一个临时缓冲区并使其成为当前缓冲区，求值
@var{body}表单，最后恢复之前的当前缓冲区，同时杀死临时缓冲区。默认情况下，
撤消信息（@pxref{Undo}）不会记录在这个宏创建的缓冲区中（但如果需要，
@var{body}可以启用）。

返回值是@var{body}中最后一个表格的值。您可以使用@code{(buffer-string)}作为
最后的表单来返回临时缓冲区的内容。

即使在通过@code{throw}异常退出或出错（
@pxref{Nonlocal Exits}）的情况下，当前缓冲区也会被恢复。

也请参见@ref{Definition of with-temp-file,,Writeing to Files}中的
@code{with-temp-file}。
@end defmac

@node 缓冲区名称
@section Buffer Names
@cindex buffer names

  每个缓冲区都有一个独特的名称，是一个字符串。许多在缓冲区上工作的函数都接受一个缓冲
区或缓冲区名作为参数。任何调用@var{buffer-or-name}的参数都是这种类型，如果它既不
是字符串也不是缓冲区，则会发出错误信号。任何调用@var{buffer}的参数必须是一个实际的
缓冲区对象，而不是一个名称。

@cindex hidden buffers
@cindex buffers without undo information
  短暂的，通常用户对它不感兴趣的缓冲区，其名称以空格开头，因此@code{list-buffers}
和@code{buffer-menu}命令不会提及它们（但如果这样的缓冲区访问一个文件，它就会
@strong{is}提及）。以空格开头的名字也会在一开始就禁止记录撤销信息；参见@ref{Undo}
。

@defun buffer-name &optional buffer
本函数以字符串形式返回@var{buffer}的名称。@var{buffer}默认为当前的缓冲区。

如果@code{buffer-name}返回@code{nil}，表示@var{buffer}已经被杀死。
@xref{Killing Buffers}。

@example
@group
(buffer-name)
     @result{} "buffers.texi"
@end group

@group
(setq foo (get-buffer "temp"))
     @result{} #<buffer temp>
@end group
@group
(kill-buffer foo)
     @result{} nil
@end group
@group
(buffer-name foo)
     @result{} nil
@end group
@group
foo
     @result{} #<killed buffer>
@end group
@end example
@end defun

@deffn Command rename-buffer newname &optional unique
此函数将当前缓冲区重命名为@var{newname}。如果@var{newname}不是一个字符串，则会发
出错误信号。

@c Emacs 19 feature
通常，如果@var{newname}已经被使用，@code{rename-buffer}会发出错误信号。但是，
如果@var{unique}是非@code{nil}，它就会修改@var{newname}，使其成为一个未使用的
名字。您可以通过一个数字前缀参数使 @var{unique}非@code{nil}。这就是
@code{rename-unique}命令的实现方式）。

这个函数返回实际赋予缓冲区的名称。
@end deffn

@defun get-buffer buffer-or-name
本函数返回由@var{buffer-or-name}指定的缓冲区。如果@var{buffer-or-name}是一个
字符串，并且没有同名的缓冲区，那么返回的值是@code{nil}。如果
@var{buffer-or-name}是一个缓冲区，则返回输入；这不是很有用，所以参数通常是一个名
称。例如：

@example
@group
(setq b (get-buffer "lewis"))
     @result{} #<buffer lewis>
@end group
@group
(get-buffer b)
     @result{} #<buffer lewis>
@end group
@group
(get-buffer "Frazzle-nots")
     @result{} nil
@end group
@end example

也请参见@ref{创建缓冲区}中的函数@code{get-buffer-create}。
@end defun

@c Emacs 19 feature
@defun generate-new-buffer-name starting-name &optional ignore
这个函数返回一个新的缓冲区的唯一名称--但并不创建缓冲区。它从@var{starting-name}开
始，通过在@samp{<@dots{}>}内添加一个数字来产生一个当前没有使用的缓冲区名称。它从2
开始，并不断递增数字，直到它不是现有缓冲区的名称。

如果可选的第二个参数@var{ignore}是非@code{nil}，它应该是一个字符串，一个潜在的缓
冲区名称。它的意思是，如果尝试了这个潜在的缓冲区，即使它是一个现有缓冲区的名称（通常会
被拒绝），也会认为它是可以接受的。因此，如果存在名为@samp{foo}、@samp{foo<2>}、@samp{foo<3>}和@samp{foo<4>}的缓冲区。

@example
(generate-new-buffer-name "foo")
     @result{} "foo<5>"
(generate-new-buffer-name "foo" "foo<3>")
     @result{} "foo<3>"
(generate-new-buffer-name "foo" "foo<6>")
     @result{} "foo<5>"
@end example

参见@ref{创建缓冲区}中的相关函数@code{generate-new-buffer}。
@end defun

@node 缓冲区文件名
@section Buffer File Name
@cindex visited file
@cindex buffer file name
@cindex file name of buffer

  @dfn{buffer file name}是该缓冲区中被访问的文件名。当一个缓冲区不访问某个文件
时，它的缓冲区文件名是@code{nil}。大多数情况下，缓冲区文件名与缓冲区文件名的非目录
部分是一样的，但缓冲区文件名和缓冲区名称是不同的，可以独立设置。
@xref{Visiting Files}.

@defun buffer-file-name &optional buffer
这个函数返回@var{buffer}正在访问的文件的绝对文件名。如果@var{buffer}没有访问任何
文件，那么@code{buffer-file-name}返回@code{nil}。如果没有提供@var{buffer}，
则默认为当前的缓冲区。

@example
@group
(buffer-file-name (other-buffer))
     @result{} "/usr/user/lewis/manual/files.texi"
@end group
@end example
@end defun

@defvar buffer-file-name
这个缓冲区本地变量包含了当前缓冲区中被访问的文件名，如果没有访问文件的话，则包含
@code{nil}。它是一个永久的局部变量，不受@code{kill-all-local-variables}影响
。

@example
@group
buffer-file-name
     @result{} "/usr/user/lewis/manual/buffers.texi"
@end group
@end example

在不做其他各种事情的情况下改变这个变量的值是有风险的。通常最好使用
@code{set-visited-file-name}(见下文)；在那里做的一些事情，比如改变缓冲区的名称
，严格来说并不是必须的，但其他的事情对于避免Emacs的混乱是必不可少的。
@end defvar

@defvar buffer-file-truename
这个缓冲区本地变量保存了当前缓冲区中被访问的缩写文件名，如果没有文件被访问，则保存
@code{nil}。它是一个永久的局部变量，不受@code{kill-all-local-variables}
的影响。 @xref{Truenames}, 和 @ref{abbreviate-file-name}.
@end defvar

@defvar buffer-file-number
这个缓冲区本地变量保存了当前缓冲区中被访问的文件的文件号和目录设备号，如果没有文件或者
访问了不存在的文件，则保存@code{nil}，它是一个永久的局部变量，不受
@code{kill-all-local-variables}影响。

这个值通常是一个形式为@code{(@var{filenum} @var{devnum})}的列表。这对数字在系
统上所有可访问的文件中唯一地标识该文件。参见，在 @ref{File Attributes}中的函数
@code{file-attributes}，了解更多关于它们的信息。

如果@code{buffer-file-name}是一个符号链接的名称，那么这两个数字都指的是递归目标。
@end defvar

@defun get-file-buffer filename
该函数返回访问文件@var{filename}的缓冲区，如果没有缓冲区，则返回@code{nil}。如果
没有这样的缓冲区，则返回@code{nil}。参数@var{filename}必须是一个字符串，它会被展
开（@pxref{File Name Expansion}），然后与所有实时缓冲区的访问文件名进行比较。注
意，缓冲区的@code{buffer-file-name}必须与@var{filename}的扩展名完全匹配。这个
函数不会识别同一文件的其他名称。

@example
@group
(get-file-buffer "buffers.texi")
    @result{} #<buffer buffers.texi>
@end group
@end example

在不寻常的情况下，可能会有多个缓冲区访问同一个文件名，在这种情况下，本函数返回缓冲区列
表中的第一个缓冲区。
@end defun

@defun find-buffer-visiting filename &optional predicate
这和@code{get-file-buffer}类似，只是它可以返回访问文件@emph{可能用不同的名字}的
任何缓冲区。也就是说，缓冲区的@code{buffer-file-name}不需要与@var{filename}的
扩展名完全匹配，它只需要引用同一个文件。如果@var{predicate}是非@code{nil}，它应该是函数，其中只有一个参数，是访问@var{filename}的缓冲区。只有当@var{predicate}
返回非@code{nil}时，缓冲区才被认为是一个合适的返回值。如果找不到合适的缓冲区来返回
，@code{find-buffer-visiting}返回@code{nil}。
@end defun

@deffn Command set-visited-file-name filename &optional no-query along-with-file
如果@var{filename}是一个非空字符串，这个函数将当前缓冲区中被访问的文件名改为
@var{filename}。(如果缓冲区没有被访问过的文件，则给它一个。)
@emph{next time}保存缓冲区时，它将被放在新指定的文件中。

这条命令将缓冲区标记为已修改，因为它与@var{filename}的内容不匹配(据Emacs所知)，即
使它与以前访问过的文件符合。它也会重新命名缓冲区以对应新的文件名，除非新的文件名已经被
使用。

如果@var{filename}是@code{nil}或空字符串，则代表"no visited file"。在这种情
况下，@code{set-visited-file-name}将缓冲区标记为没有访问过的文件，而不会改变缓
冲区的修改标志。

通常情况下，这个函数会要求用户确认是否已经有一个缓冲区在访问@var{filename}。如果
@var{no-query}是非@code{nil}，则无法询问这个问题。如果已经有一个缓冲区访问
@var{filename}，并且用户进行了确认，或者@var{no-query}是非@code{nil}，那么这
个函数通过在@samp{<@dots{}>}里面添加一个数字到@var{filename}中，使新的缓冲区名
称变得独一无二。

如果@var{along-with-file}是非@code{nil}，则意味着假设以前访问过的文件已经重命名
为@var{filename}。在这种情况下，命令不会改变缓冲区的修改标志，也不会改变由
@code{visited-file-modtime}报告的缓冲区最后一次修改文件的时间。(
@pxref{Modification Time})。如果@var{along-with-file}为@code{nil}，则该
函数将清除记录的最后一次文件修改时间，之后@code{visited-file-modtime}返回0。

当交互式调用函数@code{set-visited-file-name}时，它在minibuffer中会提示
@var{filename}。

@end deffn

@defvar list-buffers-directory
这个缓冲区本地变量对于没有被访问的文件名的缓冲区指定了一个字符串，用于在缓冲区列表中显
示被访问的文件名。Dired缓冲区使用这个变量。
@end defvar

@node 缓冲区修改
@section Buffer Modification
@cindex buffer modification
@cindex modification flag (of buffer)

  Emacs 为每个缓冲区保留了一个名为@dfn{modified flag}的标志，以记录你是否修改了
缓冲区的文本。每当你修改缓冲区的内容时，这个标志就会被设置为@code{t}，而当你保存缓冲
区时，这个标志就会被清空为@code{nil}。因此，该标志显示是否有未保存的修改。该标志值
通常显示在模式行中（@pxref{Mode Line Variables}），并控制保存（
@pxref{Saving Buffers}）和自动保存（@pxref{Auto-Saving}）。

  有些Lisp程序会显式地设置标志。例如，函数@code{set-visited-file-name}将标志设
置为@code{t}，因为文本与新访问的文件不匹配，即使它与以前访问的文件没有变化。

  修改缓冲区内容的函数在@ref{Text}中描述。

@defun buffer-modified-p &optional buffer
如果@var{buffer}在最后一次从文件读入或保存后被修改，则该函数返回@code{t}，否则返
回@code{nil}。如果@var{buffer}没有提供，则测试当前的缓冲区。
@end defun

@defun set-buffer-modified-p flag
如果@var{flag}是非@code{nil}，则该函数将当前缓冲区标记为已修改，如果flag为
@code{nil}，则标记为未修改。

调用这个函数的另一个效果是使当前缓冲区的模式行无条件的重新显示。事实上，函数
@code{force-mode-line-update}的工作原理就是这样:

@example
@group
(set-buffer-modified-p (buffer-modified-p))
@end group
@end example
@end defun

@defun restore-buffer-modified-p flag
如同@code{set-buffer-modified-p}但是强制重新显示模式行。
@end defun

@deffn Command not-modified &optional arg
该命令将当前缓冲区标记为未修改，不需要保存。如果@var{arg}是非@code{nil}，则将缓冲
区标记为已修改，以便在下一个合适的场合保存。在交互式中，@var{arg}是前缀参数。

不要在程序中使用这个函数，因为它会在回声区中打印一条信息；请使用
@code{set-buffer-modified-p}(上面)代替。

@end deffn

@defun buffer-modified-tick &optional buffer
这个函数返回@var{buffer}的修改次数。这是一个每次修改缓冲区时都会递增的计数器。如果
@var{buffer}是@code{nil}，则使用当前的缓冲区。
@end defun

@defun buffer-chars-modified-tick &optional buffer
这个函数返回@var{buffer}的字符修改计数。对文本属性的修改会使这个计数器保持不变；但
是，每次从缓冲区中插入或删除文本时，计数器都会被重置为由
@code{buffer-modified-tick}返回的值。通过比较两次
@code{buffer-chars-modified-tick}调用返回的值，您可以判断在两次调用之间该缓冲
区是否发生了字符变化。如果@var{buffer}是@code{nil}(或省略)，使用当前的缓冲区。
@end defun

有时需要以一种不真正改变其文本的方式来修改缓冲区，比如只改变其文本属性。如果您的程序需
要在不触发任何对缓冲区修改有反应的钩子和功能的情况下修改缓冲区，请使用
@code{with-silent-modifications}宏。

@defmac with-silent-modifications body@dots{}
执行@var{body}，假装不修改缓冲区。这包括检查缓冲区的文件是否被锁定（
@pxref{File Locks}），运行缓冲区修改钩子（@pxref{Change Hooks}）等。需要注意
的是，如果@var{body}真的修改了缓冲区文本，其undo数据可能会被破坏。
@end defmac

@node 修改时间
@section Buffer Modification Time
@cindex comparing file modification time
@cindex modification time of buffer

  假设你访问了一个文件，并在它的缓冲区中做了修改，同时文件本身在磁盘上也做了修改，这
时，保存缓冲区会覆盖文件中的修改。此时，保存缓冲区会覆盖文件中的变化。偶尔这可能是你想
要的，但通常会丢失有价值的信息。因此，Emacs在保存文件之前，会使用下面描述的函数检查文
件的修改时间。(@xref{File Attributes}，了解如何检查文件的修改时间。)

@defun verify-visited-file-modtime &optional buffer
这个函数比较了@var{buffer}(默认情况下，是当前缓冲区)记录的被访问文件的修改时间与操
作系统记录的文件实际修改时间。两者应该是一致的，除非Emacs访问或保存文件后，有其他进程
写过文件。

如果最后的实际修改时间和Emacs记录的修改时间相同，函数返回@code{t}，否则返回
@code{nil}。如果缓冲区没有记录的最后修改时间，也就是
@code{visited-file-modtime}将返回0，那么它也返回@code{t}。

对于没有访问文件的缓冲区，它总是返回@code{t}，即使@code{visited-file-modtime}
返回一个非零值。例如，对于dired缓冲区，它总是返回@code{t}。对于访问不存在的文件的缓
冲区，它返回@code{t}；对于被删除的访问文件的缓冲区，它返回@code{nil}。
@end defun

@defun clear-visited-file-modtime
这个功能清除了当前缓冲区所访问的文件的最后修改时间的记录。因此，下一次尝试保存这个缓冲
区时，不会抱怨文件修改时间不一致。

这个函数在@code{set-visited-file-name}和其他特殊的地方被调用，在这些地方不应该
做通常的测试，以避免覆盖被修改的文件。
@end defun

@defun visited-file-modtime
这个函数以Lisp时间戳（@pxref{Time of Day}）的形式返回当前缓冲区记录的最后一次文
件修改时间。

如果缓冲区没有记录的最后一次修改时间，这个函数返回0。这种情况会发生，例如，如果缓冲区
没有访问文件，或者时间已经被@code{clear-visited-file-modtime}显式地清除了。然
而，请注意，@code{visited-file-modtime}也会为一些非文件缓冲区返回一个时间戳。 例如，在Dired缓冲区中列出一个目录，它返回Dired记录的该目录的最后修改时间。

如果缓冲区访问的是一个不存在的文件，这个函数会返回@minus{}1。

@end defun

@defun set-visited-file-modtime &optional time
如果@var{time}不是@code{nil}，则更新缓冲区中被访问文件的最后一次修改时间为
@var{time}指定的值，否则更新为被访问文件的最后一次修改时间。

如果@var{time}既不是@code{nil}，也不是@code{visited-file-modtime}返回的整数
标志，那么它应该是一个Lisp时间值（@pxref{Time of Day}）。

如果缓冲区不是正常地从文件中读取的，或者文件本身因为某些已知的良性原因被改变，那么这个
函数就很有用。
@end defun

@defun ask-user-about-supersession-threat filename
这个函数用于询问用户在尝试修改缓冲区访问文件@var{filename}后，当文件比缓冲区文本新
时，如何继续。Emacs检测到这一点是因为磁盘上的文件的修改时间比上次保存时间要新，而且它
的内容发生了变化。这意味着可能有其他程序修改了文件。

@kindex file-supersession
根据用户的回答，函数可能会正常返回，在这种情况下，缓冲区的修改将继续进行，或者它可能会
发出@code{file-supersession}错误信号，数据为@code{(@var{filename})}，在这种
情况下，发起的缓冲区修改是不允许的。

这个函数会在适当的场合被Emacs自动调用。它的存在是为了你可以通过重新定义它来定制
Emacs。标准定义参见文件@file{userlock.el}。

也可以参考@ref{File Locks}中的文件锁定机制。
@end defun

@node 只读缓冲区
@section Read-Only Buffers
@cindex read-only buffer
@cindex buffer, read-only

  如果一个缓冲区是@dfn{read-only}，那么你就不能改变它的内容，尽管你可以通过滚动和
缩小来改变内容的视图。

  只读缓冲区在两种情况下使用：

@itemize @bullet
@item
访问写保护文件的缓冲区通常是只读的。

这里的目的是告诉用户，编辑缓冲区并将其保存在文件中可能是徒劳的或不可取的。如果用户想修
改缓冲区的文本，可以在用@kbd{C-x C-q}清除只读标志后进行修改。

@item
Dired和Rmail等模式将缓冲区设为只读，如果用一般的编辑命令来改变缓冲区的内容，很可能
是个错误。

这些模式的特殊命令在他们修改文本的地方周围将@code{buffer-read-only}绑定到
@code{nil}(用@code{let})，或者将@code{inhibit-read-only}绑定到@code{t}。
@end itemize

@defvar buffer-read-only
这个缓冲区本地变量指定缓冲区是否为只读。如果这个变量是非@code{nil}，则缓冲区是只读
的。但是，具有@code{inhibit-read-only}文本属性的字符仍然可以被修改。
@xref{Special Properties，inhibit-read-only}。
@end defvar

@defvar inhibit-read-only
如果这个变量是非@code{nil}，那么只读缓冲区和，根据实际值，部分或全部只读字符可以被
修改。缓冲区中的只读字符是指那些具有@code{read-only}文本属性非@code{nil}的字符。
关于文本属性的更多信息，请参见@xref{Special Properties}。

如果@code{inhibit-read-only}是@code{t}，那么所有@code{read-only}字符属性都
没有效果。如果@code{inhibit-read-only}是一个列表，那么@code{read-only}字符属
性如果是列表中的成员，那么这些属性就没有任何作用 (使用@code{eq} 进行比较)。

@end defvar

@deffn Command read-only-mode &optional arg
这是Read Only次要模式的模式命令，是缓冲区本地的次要模式。当启用该模式时，
@code{buffer-read-only}在缓冲区中为非@code{nil}；当禁用该模式时，
@code{buffer-read-only}在缓冲区中为@code{nil}。调用惯例与其他小模式命令相同（
@pxref{Minor Mode Conventions}）。

这个次要模式主要是作为@code{buffer-read-only}的封装；与大多数次要模式不同，没有
单独的@code{read-only-mode}变量。即使禁用了Read Only模式，带有非@code{nil}的
@code{read-only}文本属性的字符也会保持只读状态。要暂时忽略所有的只读状态，请如上所
述，绑定@code{inhibit-read-only}。

当启用Read Only模式时，如果@code{view-read-only}选项是非@code{nil}，则该模式
命令也会启用视图模式。
@xref{Misc Buffer,,Miscellaneous Buffer Operations, emacs, The GNU
Emacs Manual}。当禁用只读模式时，如果启用了View模式，则禁用View模式。
@end deffn

@defun barf-if-buffer-read-only &optional position。
如果当前的缓冲区是只读的，这个函数会发出@code{buffer-read-only}错误信号。如果在
@var{position}处的文本(默为point)设置了@code{inhibit-read-only}文本属性，则
不会引发错误。

如果当前的缓冲区是只读的，那么@xref{Using Interactive}将以另一种方式发出错误信号
。
@end defun

@node 缓冲区列表
@section The Buffer List
@cindex buffer list
@cindex listing all buffers

  @dfn{buffer list}是实时所有缓冲区的列表。列表中缓冲区的顺序主要是基于每个缓冲区
最近在窗口中显示的时间。有几个函数，特别是@code{other-buffer}，使用了这个顺序。为
用户显示的缓冲区列表也遵循这个顺序。

  创建一个缓冲区会将其添加到缓冲区列表的最后，而杀死一个缓冲区则会将其从列表中移除。
每当一个缓冲区被选择在窗口中显示（@pxref{Switching Buffers}）或选择了显示它的窗
口（@pxref{Selecting Windows}）时，它就会移动到这个列表的前面。埋藏缓冲区时，缓
冲区会移动到列表的末尾（参见下面的@code{bury-buffer}）。对于Lisp程序员来说，没有
直接操作缓冲区列表的函数。

  除了刚才描述的基本缓冲区列表之外，Emacs还为每一窗帧维护一个本地缓冲区列表，在这个
列表中，在该帧中已经显示（或者已经选择了它们的窗口）的缓冲区排在前面。(这个顺序记录在
帧的@code{buffer-list}帧参数中；参见@ref{缓冲区参数}。)从未在该帧中显示的缓冲区
则按照基本缓冲区列表的顺序排在后面。

@defun buffer-list &optional frame
该函数返回缓冲区列表，包括所有缓冲区，即使是那些名字以空格开头的缓冲区。这些元素是实际
的缓冲区，而不是它们的名字。

如果@var{frame}是一个frame，则返回@var{frame}的本地缓冲区列表。如果
@var{frame}是@code{nil}或被省略，则使用基本的缓冲区列表：缓冲区按照最近显示或选择
的顺序显示，而不管它们是显示在哪个帧上。

@example
@group
(buffer-list)
     @result{} (#<buffer buffers.texi>
         #<buffer  *Minibuf-1*> #<buffer buffer.c>
         #<buffer *Help*> #<buffer TAGS>)
@end group

@group
;; @r{Note that the name of the minibuffer}
;;   @r{begins with a space!}
(mapcar #'buffer-name (buffer-list))
    @result{} ("buffers.texi" " *Minibuf-1*"
        "buffer.c" "*Help*" "TAGS")
@end group
@end example
@end defun

  The list returned by @code{buffer-list} is constructed specifically;
it is not an internal Emacs data structure, and modifying it has no
effect on the order of buffers.  If you want to change the order of
buffers in the fundamental buffer list, here is an easy way:

@example
(defun reorder-buffer-list (new-list)
  (while new-list
    (bury-buffer (car new-list))
    (setq new-list (cdr new-list))))
@end example

  With this method, you can specify any order for the list, but there is
no danger of losing a buffer or adding something that is not a valid
live buffer.

  To change the order or value of a specific frame's buffer list, set
that frame's @code{buffer-list} parameter with
@code{modify-frame-parameters} (@pxref{Parameter Access}).

@defun other-buffer &optional buffer visible-ok frame
This function returns the first buffer in the buffer list other than
@var{buffer}.  Usually, this is the buffer appearing in the most
recently selected window (in frame @var{frame} or else the selected
frame, @pxref{Input Focus}), aside from @var{buffer}.  Buffers whose
names start with a space are not considered at all.

If @var{buffer} is not supplied (or if it is not a live buffer), then
@code{other-buffer} returns the first buffer in the selected frame's
local buffer list.  (If @var{frame} is non-@code{nil}, it returns the
first buffer in @var{frame}'s local buffer list instead.)

If @var{frame} has a non-@code{nil} @code{buffer-predicate} parameter,
then @code{other-buffer} uses that predicate to decide which buffers to
consider.  It calls the predicate once for each buffer, and if the value
is @code{nil}, that buffer is ignored.  @xref{Buffer Parameters}.

@c Emacs 19 feature
If @var{visible-ok} is @code{nil}, @code{other-buffer} avoids returning
a buffer visible in any window on any visible frame, except as a last
resort.  If @var{visible-ok} is non-@code{nil}, then it does not matter
whether a buffer is displayed somewhere or not.

If no suitable buffer exists, the buffer @file{*scratch*} is returned
(and created, if necessary).
@end defun

@defun last-buffer &optional buffer visible-ok frame
This function returns the last buffer in @var{frame}'s buffer list other
than @var{buffer}.  If @var{frame} is omitted or @code{nil}, it uses the
selected frame's buffer list.

The argument @var{visible-ok} is handled as with @code{other-buffer},
see above.  If no suitable buffer can be found, the buffer
@file{*scratch*} is returned.
@end defun

@deffn Command bury-buffer &optional buffer-or-name
This command puts @var{buffer-or-name} at the end of the buffer list,
without changing the order of any of the other buffers on the list.
This buffer therefore becomes the least desirable candidate for
@code{other-buffer} to return.  The argument can be either a buffer
itself or the name of one.

This function operates on each frame's @code{buffer-list} parameter as
well as the fundamental buffer list; therefore, the buffer that you bury
will come last in the value of @code{(buffer-list @var{frame})} and in
the value of @code{(buffer-list)}.  In addition, it also puts the buffer
at the end of the list of buffers of the selected window (@pxref{Window
History}) provided it is shown in that window.

If @var{buffer-or-name} is @code{nil} or omitted, this means to bury the
current buffer.  In addition, if the current buffer is displayed in the
selected window, this makes sure that the window is either deleted or
another buffer is shown in it.  More precisely, if the selected window
is dedicated (@pxref{Dedicated Windows}) and there are other windows on
its frame, the window is deleted.  If it is the only window on its frame
and that frame is not the only frame on its terminal, the frame is
dismissed by calling the function specified by
@code{frame-auto-hide-function} (@pxref{Quitting Windows}).  Otherwise,
it calls @code{switch-to-prev-buffer} (@pxref{Window History}) to show
another buffer in that window.  If @var{buffer-or-name} is displayed in
some other window, it remains displayed there.

To replace a buffer in all the windows that display it, use
@code{replace-buffer-in-windows}, @xref{Buffers and Windows}.
@end deffn

@deffn Command unbury-buffer
This command switches to the last buffer in the local buffer list of
the selected frame.  More precisely, it calls the function
@code{switch-to-buffer} (@pxref{Switching Buffers}), to display the
buffer returned by @code{last-buffer} (see above), in the selected
window.
@end deffn

@defvar buffer-list-update-hook
This is a normal hook run whenever the buffer list changes.  Functions
(implicitly) running this hook are @code{get-buffer-create}
(@pxref{Creating Buffers}), @code{rename-buffer} (@pxref{Buffer Names}),
@code{kill-buffer} (@pxref{Killing Buffers}), @code{bury-buffer} (see
above) and @code{select-window} (@pxref{Selecting Windows}).

Functions run by this hook should avoid calling @code{select-window}
with a nil @var{norecord} argument or @code{with-temp-buffer} since
either may lead to infinite recursion.
@end defvar

@node Creating Buffers
@section Creating Buffers
@cindex creating buffers
@cindex buffers, creating

  This section describes the two primitives for creating buffers.
@code{get-buffer-create} creates a buffer if it finds no existing buffer
with the specified name; @code{generate-new-buffer} always creates a new
buffer and gives it a unique name.

  Other functions you can use to create buffers include
@code{with-output-to-temp-buffer} (@pxref{Temporary Displays}) and
@code{create-file-buffer} (@pxref{Visiting Files}).  Starting a
subprocess can also create a buffer (@pxref{Processes}).

@defun get-buffer-create buffer-or-name
This function returns a buffer named @var{buffer-or-name}.  The buffer
returned does not become the current buffer---this function does not
change which buffer is current.

@var{buffer-or-name} must be either a string or an existing buffer.  If
it is a string and a live buffer with that name already exists,
@code{get-buffer-create} returns that buffer.  If no such buffer exists,
it creates a new buffer.  If @var{buffer-or-name} is a buffer instead of
a string, it is returned as given, even if it is dead.

@example
@group
(get-buffer-create "foo")
     @result{} #<buffer foo>
@end group
@end example

The major mode for a newly created buffer is set to Fundamental mode.
(The default value of the variable @code{major-mode} is handled at a higher
level; see @ref{Auto Major Mode}.)  If the name begins with a space, the
buffer initially disables undo information recording (@pxref{Undo}).
@end defun

@defun generate-new-buffer name
This function returns a newly created, empty buffer, but does not make
it current.  The name of the buffer is generated by passing @var{name}
to the function @code{generate-new-buffer-name} (@pxref{Buffer
Names}).  Thus, if there is no buffer named @var{name}, then that is
the name of the new buffer; if that name is in use, a suffix of the
form @samp{<@var{n}>}, where @var{n} is an integer, is appended to
@var{name}.

An error is signaled if @var{name} is not a string.

@example
@group
(generate-new-buffer "bar")
     @result{} #<buffer bar>
@end group
@group
(generate-new-buffer "bar")
     @result{} #<buffer bar<2>>
@end group
@group
(generate-new-buffer "bar")
     @result{} #<buffer bar<3>>
@end group
@end example

The major mode for the new buffer is set to Fundamental mode.  The default
value of the variable @code{major-mode} is handled at a higher level.
@xref{Auto Major Mode}.
@end defun

@node Killing Buffers
@section Killing Buffers
@cindex killing buffers
@cindex buffers, killing

  @dfn{Killing a buffer} makes its name unknown to Emacs and makes the
memory space it occupied available for other use.

  The buffer object for the buffer that has been killed remains in
existence as long as anything refers to it, but it is specially marked
so that you cannot make it current or display it.  Killed buffers retain
their identity, however; if you kill two distinct buffers, they remain
distinct according to @code{eq} although both are dead.

  If you kill a buffer that is current or displayed in a window, Emacs
automatically selects or displays some other buffer instead.  This
means that killing a buffer can change the current buffer.  Therefore,
when you kill a buffer, you should also take the precautions
associated with changing the current buffer (unless you happen to know
that the buffer being killed isn't current).  @xref{Current Buffer}.

  If you kill a buffer that is the base buffer of one or more indirect
@iftex
buffers,
@end iftex
@ifnottex
buffers (@pxref{Indirect Buffers}),
@end ifnottex
the indirect buffers are automatically killed as well.

@cindex live buffer
  The @code{buffer-name} of a buffer is @code{nil} if, and only if,
the buffer is killed.  A buffer that has not been killed is called a
@dfn{live} buffer.  To test whether a buffer is live or killed, use
the function @code{buffer-live-p} (see below).

@deffn Command kill-buffer &optional buffer-or-name
This function kills the buffer @var{buffer-or-name}, freeing all its
memory for other uses or to be returned to the operating system.  If
@var{buffer-or-name} is @code{nil} or omitted, it kills the current
buffer.

Any processes that have this buffer as the @code{process-buffer} are
sent the @code{SIGHUP} (hangup) signal, which normally causes them
to terminate.  @xref{Signals to Processes}.

If the buffer is visiting a file and contains unsaved changes,
@code{kill-buffer} asks the user to confirm before the buffer is killed.
It does this even if not called interactively.  To prevent the request
for confirmation, clear the modified flag before calling
@code{kill-buffer}.  @xref{Buffer Modification}.

This function calls @code{replace-buffer-in-windows} for cleaning up
all windows currently displaying the buffer to be killed.

Killing a buffer that is already dead has no effect.

This function returns @code{t} if it actually killed the buffer.  It
returns @code{nil} if the user refuses to confirm or if
@var{buffer-or-name} was already dead.

@smallexample
(kill-buffer "foo.unchanged")
     @result{} t
(kill-buffer "foo.changed")

---------- Buffer: Minibuffer ----------
Buffer foo.changed modified; kill anyway? (yes or no) @kbd{yes}
---------- Buffer: Minibuffer ----------

     @result{} t
@end smallexample
@end deffn

@defvar kill-buffer-query-functions
Before confirming unsaved changes, @code{kill-buffer} calls the functions
in the list @code{kill-buffer-query-functions}, in order of appearance,
with no arguments.  The buffer being killed is the current buffer when
they are called.  The idea of this feature is that these functions will
ask for confirmation from the user.  If any of them returns @code{nil},
@code{kill-buffer} spares the buffer's life.
@end defvar

@defvar kill-buffer-hook
This is a normal hook run by @code{kill-buffer} after asking all the
questions it is going to ask, just before actually killing the buffer.
The buffer to be killed is current when the hook functions run.
@xref{Hooks}.  This variable is a permanent local, so its local binding
is not cleared by changing major modes.
@end defvar

@defopt buffer-offer-save
This variable, if non-@code{nil} in a particular buffer, tells
@code{save-buffers-kill-emacs} to offer to save that buffer, just as
it offers to save file-visiting buffers.  If @code{save-some-buffers}
is called with the second optional argument set to @code{t}, it will
also offer to save the buffer.  Lastly, if this variable is set to the
symbol @code{always}, both @code{save-buffers-kill-emacs} and
@code{save-some-buffers} will always offer to save.  @xref{Definition
of save-some-buffers}.  The variable @code{buffer-offer-save}
automatically becomes buffer-local when set for any reason.
@xref{Buffer-Local Variables}.
@end defopt

@defvar buffer-save-without-query
This variable, if non-@code{nil} in a particular buffer, tells
@code{save-buffers-kill-emacs} and @code{save-some-buffers} to save
this buffer (if it's modified) without asking the user.  The variable
automatically becomes buffer-local when set for any reason.
@end defvar

@defun buffer-live-p object
This function returns @code{t} if @var{object} is a live buffer (a
buffer which has not been killed), @code{nil} otherwise.
@end defun

@node Indirect Buffers
@section Indirect Buffers
@cindex indirect buffers
@cindex base buffer

  An @dfn{indirect buffer} shares the text of some other buffer, which
is called the @dfn{base buffer} of the indirect buffer.  In some ways it
is the analogue, for buffers, of a symbolic link among files.  The base
buffer may not itself be an indirect buffer.

  The text of the indirect buffer is always identical to the text of its
base buffer; changes made by editing either one are visible immediately
in the other.  This includes the text properties as well as the characters
themselves.

  In all other respects, the indirect buffer and its base buffer are
completely separate.  They have different names, independent values of
point, independent narrowing, independent markers and overlays (though
inserting or deleting text in either buffer relocates the markers and
overlays for both), independent major modes, and independent
buffer-local variable bindings.

  An indirect buffer cannot visit a file, but its base buffer can.  If
you try to save the indirect buffer, that actually saves the base
buffer.

  Killing an indirect buffer has no effect on its base buffer.  Killing
the base buffer effectively kills the indirect buffer in that it cannot
ever again be the current buffer.

@deffn Command make-indirect-buffer base-buffer name &optional clone
This creates and returns an indirect buffer named @var{name} whose
base buffer is @var{base-buffer}.  The argument @var{base-buffer} may
be a live buffer or the name (a string) of an existing buffer.  If
@var{name} is the name of an existing buffer, an error is signaled.

If @var{clone} is non-@code{nil}, then the indirect buffer originally
shares the state of @var{base-buffer} such as major mode, minor
modes, buffer local variables and so on.  If @var{clone} is omitted
or @code{nil} the indirect buffer's state is set to the default state
for new buffers.

If @var{base-buffer} is an indirect buffer, its base buffer is used as
the base for the new buffer.  If, in addition, @var{clone} is
non-@code{nil}, the initial state is copied from the actual base
buffer, not from @var{base-buffer}.
@end deffn

@deffn Command clone-indirect-buffer newname display-flag &optional norecord
This function creates and returns a new indirect buffer that shares
the current buffer's base buffer and copies the rest of the current
buffer's attributes.  (If the current buffer is not indirect, it is
used as the base buffer.)

If @var{display-flag} is non-@code{nil}, as it always is in
interactive calls, that means to display the new buffer by calling
@code{pop-to-buffer}.  If @var{norecord} is non-@code{nil}, that means
not to put the new buffer to the front of the buffer list.
@end deffn

@defun buffer-base-buffer &optional buffer
This function returns the base buffer of @var{buffer}, which defaults
to the current buffer.  If @var{buffer} is not indirect, the value is
@code{nil}.  Otherwise, the value is another buffer, which is never an
indirect buffer.
@end defun

@node Swapping Text
@section Swapping Text Between Two Buffers
@cindex swap text between buffers
@cindex virtual buffers

  Specialized modes sometimes need to let the user access from the
same buffer several vastly different types of text.  For example, you
may need to display a summary of the buffer text, in addition to
letting the user access the text itself.

  This could be implemented with multiple buffers (kept in sync when
the user edits the text), or with narrowing (@pxref{Narrowing}).  But
these alternatives might sometimes become tedious or prohibitively
expensive, especially if each type of text requires expensive
buffer-global operations in order to provide correct display and
editing commands.

  Emacs provides another facility for such modes: you can quickly swap
buffer text between two buffers with @code{buffer-swap-text}.  This
function is very fast because it doesn't move any text, it only
changes the internal data structures of the buffer object to point to
a different chunk of text.  Using it, you can pretend that a group of
two or more buffers are actually a single virtual buffer that holds
the contents of all the individual buffers together.

@defun buffer-swap-text buffer
This function swaps the text of the current buffer and that of its
argument @var{buffer}.  It signals an error if one of the two buffers
is an indirect buffer (@pxref{Indirect Buffers}) or is a base buffer
of an indirect buffer.

All the buffer properties that are related to the buffer text are
swapped as well: the positions of point and mark, all the markers, the
overlays, the text properties, the undo list, the value of the
@code{enable-multibyte-characters} flag (@pxref{Text Representations,
enable-multibyte-characters}), etc.

@strong{Warning:} If this function is called from within a
@code{save-excursion} form, the current buffer will be set to
@var{buffer} upon leaving the form, since the marker used by
@code{save-excursion} to save the position and buffer will be swapped
as well.
@end defun

  If you use @code{buffer-swap-text} on a file-visiting buffer, you
should set up a hook to save the buffer's original text rather than
what it was swapped with.  @code{write-region-annotate-functions}
works for this purpose.  You should probably set
@code{buffer-saved-size} to @minus{}2 in the buffer, so that changes
in the text it is swapped with will not interfere with auto-saving.

@node Buffer Gap
@section The Buffer Gap
@cindex buffer gap

  Emacs buffers are implemented using an invisible @dfn{gap} to make
insertion and deletion faster.  Insertion works by filling in part of
the gap, and deletion adds to the gap.  Of course, this means that the
gap must first be moved to the locus of the insertion or deletion.
Emacs moves the gap only when you try to insert or delete.  This is why
your first editing command in one part of a large buffer, after
previously editing in another far-away part, sometimes involves a
noticeable delay.

  This mechanism works invisibly, and Lisp code should never be affected
by the gap's current location, but these functions are available for
getting information about the gap status.

@defun gap-position
This function returns the current gap position in the current buffer.
@end defun

@defun gap-size
This function returns the current gap size of the current buffer.
@end defun
