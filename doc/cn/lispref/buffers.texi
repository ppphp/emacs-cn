@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990--1995, 1998--1999, 2001--2020 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node 缓冲区
@chapter Buffers
@cindex buffer

  一个@dfn{buffer}是一个包含要编辑的文本的Lisp对象。缓冲区用来保存正在访问
的文件的内容，也可能存在不访问文件的缓冲区。虽然在同一时间可能存在多个缓冲区
，但在任何时候只有一个缓冲区被指定为@dfn{current buffer}。大多数编辑命令都
会对当前缓冲区的内容进行操作。每一个缓冲区，包括当前缓冲区，可以在任何窗口中
显示，也可以不显示。

@menu
* 缓冲区基础::   什么是缓冲区？
* 当前缓冲区::   指定缓冲区为当前缓冲区以便原语能够访问其内容。
* 缓冲区名称::   访问和更改缓冲区名称。
* 缓冲区文件名:: 指示被缓冲区访问的文件的文件名。
* 缓冲区修改::   如果需要保存缓冲区，则是@dfn{modified}的。
* 修改时间::    判断被访问的文件是否在Emacs之外被修改。
* 只读缓冲区::  只读缓冲区中不允许修改文本。
* 缓冲区列表::  如何查看所有现有的缓冲区。
* 创建缓冲区::  创建缓冲区的函数。
* 杀死缓冲区::  缓冲区一直存在，直到被明确杀死。
* 间接缓冲区::  间接缓冲区与其他缓冲区共享文本。
* 交换文本::    在两个缓冲区之间交换文本。
* 缓冲区间隙::  缓冲区的间隙。
@end menu

@node 缓冲区基础
@section Buffer Basics

@ifnottex
  一个@dfn{buffer}是一个包含要编辑的文本的Lisp对象。缓冲区用来保存正在访问
的文件的内容，也可能存在不访问文件的缓冲区。虽然通常存在多个缓冲区，但无论何
时只有一个缓冲区会指定为@dfn{current buffer}。大多数编辑命令都是在当前缓冲
区的内容上执行。每一个缓冲区，包括当前缓冲区，可以也可以不显示在任意一个窗口
中。
@end ifnottex

  Emacs编辑中的缓冲区是指具有独一无二名称的对象，存放着可以编辑的文本。在
Lisp程序中，缓冲区是作为一种特殊的数据类型出现的。你可以把缓冲区的内容看作是一个可以扩展的字符串；在缓冲区的任何部分都可以进行插入和删除。@xref{Text}。

  一个Lisp缓冲区对象包含了许多信息。其中一些信息可以通过变量被程序员直接访
问，而另一些信息只能通过特殊用途的函数来访问。例如，被访问的文件名可以通过变
量直接访问，而点的值只能通过一个原语函数访问。

  可以直接访问的特定缓冲区信息存储在@dfn{buffer-local}变量绑定中，这些变量
值只在特定缓冲区中有效。这个功能允许每个缓冲区覆盖某些变量的值。大多数主要模式都以这种方式覆盖了@code{fill-column}或@code{comment-column}等变量。关于缓冲区局部变量和相关函数的更多信息，参见@ref{缓冲区局部变量}。

  有关访问缓冲区中文件的函数和变量，参见@ref{Visiting Files}和
@ref{Saving Buffers}。有关在窗口中显示缓冲区的函数和变量，请参见
@ref{缓冲区和窗口}。

@defun bufferp object
如果@var{object}是缓冲区返回@code{t}，否则返回@code{nil}。
@end defun

@node 当前缓冲区
@section The Current Buffer
@cindex selecting a buffer
@cindex changing to another buffer
@cindex current buffer

  一般来说，Emacs 会话中有很多缓冲区。在任何时候，其中的一个缓冲区被指定为
@dfn{current buffer}--也就是进行大部分编辑的缓冲区。大多数用于检查或更改
文本的原语都是在当前缓冲区(@pxref{Text})上隐式操作的。

  通常情况下，所选窗口中显示的缓冲区是当前缓冲区，但并非总是如此：Lisp程序
可以临时指定任何缓冲区为当前缓冲区，以便对其内容进行操作，而不改变屏幕上显示
的内容。指定当前缓冲区的最基本功能是@code{set-buffer}。

@defun current-buffer
这个函数返回当前缓冲区。

@example
@group
(current-buffer)
     @result{} #<buffer buffers.texi>
@end group
@end example
@end defun

@defun set-buffer buffer-or-name
这个函数使@var{buffer-or-name}成为当前缓冲区。@var{buffer-or-name}必须是
一个现有的缓冲区，或者是一个现有缓冲区的名称。返回值是当前缓冲区的值。

这个函数不会在任何窗口中显示缓冲区，所以用户不一定能看到缓冲区。
但现在Lisp程序将对它进行操作。
@end defun

  当一个编辑命令返回到编辑器命令循环时，Emacs会自动调用@code{set-buffer}在所
选窗口中显示的缓冲区上。这是为了防止迷惑：它确保当Emacs读取一条命令时，光标
所在的缓冲区就是该命令适用的缓冲区（@pxref{Command Loop}）。因此，您不应该
使用@code{set-buffer}来明显地切换到不同的缓冲区；为此，请使用
@ref{切换缓冲区}中描述的函数。

  在编写Lisp函数时，请@emph{not}依赖命令循环的这种行为以便操作后恢复当前缓冲
区。编辑命令也可以被其他程序作为Lisp函数调用，而不仅仅是从命令循环中调用；如
果子程序不改变当前是哪个缓冲区，对调用者来说是很方便的（当然，除非这就是子程
序的目的）。

  如果要临时对另一个缓冲区进行操作，可以把@code{set-buffer}放在
@code{save-current-buffer}形式中。这里有一个例子，是命令
@code{append-to-buffer}的简化版本。

@example
@group
(defun append-to-buffer (buffer start end)
  "Append the text of the region to BUFFER."
  (interactive "BAppend to buffer: \nr")
  (let ((oldbuf (current-buffer)))
    (save-current-buffer
      (set-buffer (get-buffer-create buffer))
      (insert-buffer-substring oldbuf start end))))
@end group
@end example

@noindent
这里，我们绑定了一个本地变量来记录当前的缓冲区，然后
@code{save-current-buffer}安排它在以后再次成为当前的缓冲区。接下来，
@code{set-buffer}使指定的缓冲区成为当前缓冲区，
@code{insert-buffer-substring}将字符串从原始缓冲区复制到指定的（现在是当前
）缓冲区。

  另一种方法是，我们也可以使用@code{with-current-buffer}宏。

@example
@group
(defun append-to-buffer (buffer start end)
  "Append the text of the region to BUFFER."
  (interactive "BAppend to buffer: \nr")
  (let ((oldbuf (current-buffer)))
    (with-current-buffer (get-buffer-create buffer)
      (insert-buffer-substring oldbuf start end))))
@end group
@end example

  在这两种情况下，如果附加到的缓冲区恰好显示在某个窗口中，下一次重新显示将显
示其文本的变化情况。如果它没有在任何窗口中显示，你不会立即在屏幕上看到变化。
该命令会使缓冲区暂时成为当前状态，但不会使其显示。

  如果您为一个变量做了本地绑定（使用@code{let}或函数参数），而这个变量可能
也有缓冲区本地绑定，请确保在本地绑定的作用域的开始和结束时，当前缓冲区是同一个。 否则你可能在一个缓冲区中绑定了它，而在另一个缓冲区中取消了绑定。

  不要依赖使用@code{set-buffer}将当前的缓冲区改回来，因为如果在错误的缓冲区
处于当前状态时发生了退出，那将无法完成任务。例如，在前面的例子中，这样做是错
误的：

@example
@group
  (let ((oldbuf (current-buffer)))
    (set-buffer (get-buffer-create buffer))
    (insert-buffer-substring oldbuf start end)
    (set-buffer oldbuf))
@end group
@end example

@noindent
使用@code{save-current-buffer}或@code{with-current-buffer}，就像我们所做
的那样，正确地处理了退出、错误和 @code{throw}，以及普通的求值。

@defspec save-current-buffer body@dots{}
@code{save-current-buffer}特殊表单保存当前缓冲区的标识，求值@var{body}表单
，最后将该缓冲区恢复为当前状态。返回值是@var{body}中最后一个表单的值。即使
在通过@code{throw}或错误(@pxref{Nonlocal Exits})异常退出的情况下，也会恢
复当前缓冲区。

如果在@code{save-current-buffer}退出时，曾经是当前的缓冲区已经被杀死了，那
么它当然不会再次成为当前缓冲区。相反，在退出前处于当前状态的缓冲区将保持当前
状态。
@end defspec

@defmac with-current-buffer buffer-or-name body@dots{}
@code{with-current-buffer}宏保存当前缓冲区的标识，使@var{buffer-or-name}
成为当前缓冲区，评估@var{body}形式，最后恢复当前缓冲区。
@var{buffer-or-name}必须指定一个现有的缓冲区或一个现有缓冲区的名称。

返回值是@var{body}中最后一个表单的值。即使在通过@code{throw}异常退出或出错
（@pxref{Nonlocal Exits}）的情况下，也会恢复当前缓冲区。

@end defmac

@defmac with-temp-buffer body@dots{}
@anchor{Definition of with-temp-buffer}
@code{with-temp-buffer}宏以临时缓冲区作为当前缓冲区求值@var{body}表单。
它保存当前缓冲区的标识，创建一个临时缓冲区并使其成为当前缓冲区，求值
@var{body}表单，最后恢复之前的当前缓冲区，同时杀死临时缓冲区。默认情况下，
撤消信息（@pxref{Undo}）不会记录在这个宏创建的缓冲区中（但如果需要，
@var{body}可以启用）。

返回值是@var{body}中最后一个表格的值。您可以使用@code{(buffer-string)}作为
最后的表单来返回临时缓冲区的内容。

即使在通过@code{throw}异常退出或出错（
@pxref{Nonlocal Exits}）的情况下，当前缓冲区也会被恢复。

也请参见@ref{Definition of with-temp-file,,Writeing to Files}中的
@code{with-temp-file}。
@end defmac

@node 缓冲区名称
@section Buffer Names
@cindex buffer names

  每个缓冲区都有一个独特的名称，是一个字符串。许多在缓冲区上工作的函数都接受一个缓冲
区或缓冲区名作为参数。任何调用@var{buffer-or-name}的参数都是这种类型，如果它既不
是字符串也不是缓冲区，则会发出错误信号。任何调用@var{buffer}的参数必须是一个实际的
缓冲区对象，而不是一个名称。

@cindex hidden buffers
@cindex buffers without undo information
  短暂的，通常用户对它不感兴趣的缓冲区，其名称以空格开头，因此@code{list-buffers}
和@code{buffer-menu}命令不会提及它们（但如果这样的缓冲区访问一个文件，它就会
@strong{is}提及）。以空格开头的名字也会在一开始就禁止记录撤销信息；参见@ref{Undo}
。

@defun buffer-name &optional buffer
本函数以字符串形式返回@var{buffer}的名称。@var{buffer}默认为当前的缓冲区。

如果@code{buffer-name}返回@code{nil}，表示@var{buffer}已经被杀死。
@xref{Killing Buffers}。

@example
@group
(buffer-name)
     @result{} "buffers.texi"
@end group

@group
(setq foo (get-buffer "temp"))
     @result{} #<buffer temp>
@end group
@group
(kill-buffer foo)
     @result{} nil
@end group
@group
(buffer-name foo)
     @result{} nil
@end group
@group
foo
     @result{} #<killed buffer>
@end group
@end example
@end defun

@deffn Command rename-buffer newname &optional unique
此函数将当前缓冲区重命名为@var{newname}。如果@var{newname}不是一个字符串，则会发
出错误信号。

@c Emacs 19 feature
通常，如果@var{newname}已经被使用，@code{rename-buffer}会发出错误信号。但是，
如果@var{unique}是非@code{nil}，它就会修改@var{newname}，使其成为一个未使用的
名字。您可以通过一个数字前缀参数使 @var{unique}非@code{nil}。这就是
@code{rename-unique}命令的实现方式）。

这个函数返回实际赋予缓冲区的名称。
@end deffn

@defun get-buffer buffer-or-name
本函数返回由@var{buffer-or-name}指定的缓冲区。如果@var{buffer-or-name}是一个
字符串，并且没有同名的缓冲区，那么返回的值是@code{nil}。如果
@var{buffer-or-name}是一个缓冲区，则返回输入；这不是很有用，所以参数通常是一个名
称。例如：

@example
@group
(setq b (get-buffer "lewis"))
     @result{} #<buffer lewis>
@end group
@group
(get-buffer b)
     @result{} #<buffer lewis>
@end group
@group
(get-buffer "Frazzle-nots")
     @result{} nil
@end group
@end example

也请参见@ref{创建缓冲区}中的函数@code{get-buffer-create}。
@end defun

@c Emacs 19 feature
@defun generate-new-buffer-name starting-name &optional ignore
这个函数返回一个新的缓冲区的唯一名称--但并不创建缓冲区。它从@var{starting-name}开
始，通过在@samp{<@dots{}>}内添加一个数字来产生一个当前没有使用的缓冲区名称。它从2
开始，并不断递增数字，直到它不是现有缓冲区的名称。

如果可选的第二个参数@var{ignore}是非@code{nil}，它应该是一个字符串，一个潜在的缓
冲区名称。它的意思是，如果尝试了这个潜在的缓冲区，即使它是一个现有缓冲区的名称（通常会
被拒绝），也会认为它是可以接受的。因此，如果存在名为@samp{foo}、@samp{foo<2>}、@samp{foo<3>}和@samp{foo<4>}的缓冲区。

@example
(generate-new-buffer-name "foo")
     @result{} "foo<5>"
(generate-new-buffer-name "foo" "foo<3>")
     @result{} "foo<3>"
(generate-new-buffer-name "foo" "foo<6>")
     @result{} "foo<5>"
@end example

参见@ref{创建缓冲区}中的相关函数@code{generate-new-buffer}。
@end defun

@node 缓冲区文件名
@section Buffer File Name
@cindex visited file
@cindex buffer file name
@cindex file name of buffer

  @dfn{buffer file name}是该缓冲区中被访问的文件名。当一个缓冲区不访问某个文件
时，它的缓冲区文件名是@code{nil}。大多数情况下，缓冲区文件名与缓冲区文件名的非目录
部分是一样的，但缓冲区文件名和缓冲区名称是不同的，可以独立设置。
@xref{Visiting Files}.

@defun buffer-file-name &optional buffer
这个函数返回@var{buffer}正在访问的文件的绝对文件名。如果@var{buffer}没有访问任何
文件，那么@code{buffer-file-name}返回@code{nil}。如果没有提供@var{buffer}，
则默认为当前的缓冲区。

@example
@group
(buffer-file-name (other-buffer))
     @result{} "/usr/user/lewis/manual/files.texi"
@end group
@end example
@end defun

@defvar buffer-file-name
这个缓冲区本地变量包含了当前缓冲区中被访问的文件名，如果没有访问文件的话，则包含
@code{nil}。它是一个永久的局部变量，不受@code{kill-all-local-variables}影响
。

@example
@group
buffer-file-name
     @result{} "/usr/user/lewis/manual/buffers.texi"
@end group
@end example

在不做其他各种事情的情况下改变这个变量的值是有风险的。通常最好使用
@code{set-visited-file-name}(见下文)；在那里做的一些事情，比如改变缓冲区的名称
，严格来说并不是必须的，但其他的事情对于避免Emacs的混乱是必不可少的。
@end defvar

@defvar buffer-file-truename
这个缓冲区本地变量保存了当前缓冲区中被访问的缩写文件名，如果没有文件被访问，则保存
@code{nil}。它是一个永久的局部变量，不受@code{kill-all-local-variables}
的影响。 @xref{Truenames}, 和 @ref{abbreviate-file-name}.
@end defvar

@defvar buffer-file-number
这个缓冲区本地变量保存了当前缓冲区中被访问的文件的文件号和目录设备号，如果没有文件或者
访问了不存在的文件，则保存@code{nil}，它是一个永久的局部变量，不受
@code{kill-all-local-variables}影响。

这个值通常是一个形式为@code{(@var{filenum} @var{devnum})}的列表。这对数字在系
统上所有可访问的文件中唯一地标识该文件。参见，在 @ref{File Attributes}中的函数
@code{file-attributes}，了解更多关于它们的信息。

如果@code{buffer-file-name}是一个符号链接的名称，那么这两个数字都指的是递归目标。
@end defvar

@defun get-file-buffer filename
该函数返回访问文件@var{filename}的缓冲区，如果没有缓冲区，则返回@code{nil}。如果
没有这样的缓冲区，则返回@code{nil}。参数@var{filename}必须是一个字符串，它会被展
开（@pxref{File Name Expansion}），然后与所有实时缓冲区的访问文件名进行比较。注
意，缓冲区的@code{buffer-file-name}必须与@var{filename}的扩展名完全匹配。这个
函数不会识别同一文件的其他名称。

@example
@group
(get-file-buffer "buffers.texi")
    @result{} #<buffer buffers.texi>
@end group
@end example

在不寻常的情况下，可能会有多个缓冲区访问同一个文件名，在这种情况下，本函数返回缓冲区列
表中的第一个缓冲区。
@end defun

@defun find-buffer-visiting filename &optional predicate
这和@code{get-file-buffer}类似，只是它可以返回访问文件@emph{可能用不同的名字}的
任何缓冲区。也就是说，缓冲区的@code{buffer-file-name}不需要与@var{filename}的
扩展名完全匹配，它只需要引用同一个文件。如果@var{predicate}是非@code{nil}，它应该是函数，其中只有一个参数，是访问@var{filename}的缓冲区。只有当@var{predicate}
返回非@code{nil}时，缓冲区才被认为是一个合适的返回值。如果找不到合适的缓冲区来返回
，@code{find-buffer-visiting}返回@code{nil}。
@end defun

@deffn Command set-visited-file-name filename &optional no-query along-with-file
如果@var{filename}是一个非空字符串，这个函数将当前缓冲区中被访问的文件名改为
@var{filename}。(如果缓冲区没有被访问过的文件，则给它一个。)
@emph{next time}保存缓冲区时，它将被放在新指定的文件中。

这条命令将缓冲区标记为已修改，因为它与@var{filename}的内容不匹配(据Emacs所知)，即
使它与以前访问过的文件符合。它也会重新命名缓冲区以对应新的文件名，除非新的文件名已经被
使用。

如果@var{filename}是@code{nil}或空字符串，则代表"no visited file"。在这种情
况下，@code{set-visited-file-name}将缓冲区标记为没有访问过的文件，而不会改变缓
冲区的修改标志。

通常情况下，这个函数会要求用户确认是否已经有一个缓冲区在访问@var{filename}。如果
@var{no-query}是非@code{nil}，则无法询问这个问题。如果已经有一个缓冲区访问
@var{filename}，并且用户进行了确认，或者@var{no-query}是非@code{nil}，那么这
个函数通过在@samp{<@dots{}>}里面添加一个数字到@var{filename}中，使新的缓冲区名
称变得独一无二。

如果@var{along-with-file}是非@code{nil}，则意味着假设以前访问过的文件已经重命名
为@var{filename}。在这种情况下，命令不会改变缓冲区的修改标志，也不会改变由
@code{visited-file-modtime}报告的缓冲区最后一次修改文件的时间。(
@pxref{Modification Time})。如果@var{along-with-file}为@code{nil}，则该
函数将清除记录的最后一次文件修改时间，之后@code{visited-file-modtime}返回0。

当交互式调用函数@code{set-visited-file-name}时，它在minibuffer中会提示
@var{filename}。

@end deffn

@defvar list-buffers-directory
这个缓冲区本地变量对于没有被访问的文件名的缓冲区指定了一个字符串，用于在缓冲区列表中显
示被访问的文件名。Dired缓冲区使用这个变量。
@end defvar

@node 缓冲区修改
@section Buffer Modification
@cindex buffer modification
@cindex modification flag (of buffer)

  Emacs 为每个缓冲区保留了一个名为@dfn{modified flag}的标志，以记录你是否修改了
缓冲区的文本。每当你修改缓冲区的内容时，这个标志就会被设置为@code{t}，而当你保存缓冲
区时，这个标志就会被清空为@code{nil}。因此，该标志显示是否有未保存的修改。该标志值
通常显示在模式行中（@pxref{Mode Line Variables}），并控制保存（
@pxref{Saving Buffers}）和自动保存（@pxref{Auto-Saving}）。

  有些Lisp程序会显式地设置标志。例如，函数@code{set-visited-file-name}将标志设
置为@code{t}，因为文本与新访问的文件不匹配，即使它与以前访问的文件没有变化。

  修改缓冲区内容的函数在@ref{Text}中描述。

@defun buffer-modified-p &optional buffer
如果@var{buffer}在最后一次从文件读入或保存后被修改，则该函数返回@code{t}，否则返
回@code{nil}。如果@var{buffer}没有提供，则测试当前的缓冲区。
@end defun

@defun set-buffer-modified-p flag
如果@var{flag}是非@code{nil}，则该函数将当前缓冲区标记为已修改，如果flag为
@code{nil}，则标记为未修改。

调用这个函数的另一个效果是使当前缓冲区的模式行无条件的重新显示。事实上，函数
@code{force-mode-line-update}的工作原理就是这样:

@example
@group
(set-buffer-modified-p (buffer-modified-p))
@end group
@end example
@end defun

@defun restore-buffer-modified-p flag
Like @code{set-buffer-modified-p}, but does not force redisplay
of mode lines.
@end defun

@deffn Command not-modified &optional arg
This command marks the current buffer as unmodified, and not needing
to be saved.  If @var{arg} is non-@code{nil}, it marks the buffer as
modified, so that it will be saved at the next suitable occasion.
Interactively, @var{arg} is the prefix argument.

Don't use this function in programs, since it prints a message in the
echo area; use @code{set-buffer-modified-p} (above) instead.
@end deffn

@defun buffer-modified-tick &optional buffer
This function returns @var{buffer}'s modification-count.  This is a
counter that increments every time the buffer is modified.  If
@var{buffer} is @code{nil} (or omitted), the current buffer is used.
@end defun

@defun buffer-chars-modified-tick &optional buffer
This function returns @var{buffer}'s character-change modification-count.
Changes to text properties leave this counter unchanged; however, each
time text is inserted or removed from the buffer, the counter is reset
to the value that would be returned by @code{buffer-modified-tick}.
By comparing the values returned by two @code{buffer-chars-modified-tick}
calls, you can tell whether a character change occurred in that buffer
in between the calls.  If @var{buffer} is @code{nil} (or omitted), the
current buffer is used.
@end defun

Sometimes there's a need for modifying buffer in a way that doesn't
really change its text, like if only its text properties are changed.
If your program needs to modify a buffer without triggering any hooks
and features that react to buffer modifications, use the
@code{with-silent-modifications} macro.

@defmac with-silent-modifications body@dots{}
Execute @var{body} pretending it does not modify the buffer.  This
includes checking whether the buffer's file is locked (@pxref{File
Locks}), running buffer modification hooks (@pxref{Change Hooks}),
etc.  Note that if @var{body} actually modifies the buffer text, its
undo data may become corrupted.
@end defmac

@node Modification Time
@section Buffer Modification Time
@cindex comparing file modification time
@cindex modification time of buffer

  Suppose that you visit a file and make changes in its buffer, and
meanwhile the file itself is changed on disk.  At this point, saving the
buffer would overwrite the changes in the file.  Occasionally this may
be what you want, but usually it would lose valuable information.  Emacs
therefore checks the file's modification time using the functions
described below before saving the file.  (@xref{File Attributes},
for how to examine a file's modification time.)

@defun verify-visited-file-modtime &optional buffer
This function compares what @var{buffer} (by default, the
current-buffer) has recorded for the modification time of its visited
file against the actual modification time of the file as recorded by the
operating system.  The two should be the same unless some other process
has written the file since Emacs visited or saved it.

The function returns @code{t} if the last actual modification time and
Emacs's recorded modification time are the same, @code{nil} otherwise.
It also returns @code{t} if the buffer has no recorded last
modification time, that is if @code{visited-file-modtime} would return
zero.

It always returns @code{t} for buffers that are not visiting a file,
even if @code{visited-file-modtime} returns a non-zero value.  For
instance, it always returns @code{t} for dired buffers.  It returns
@code{t} for buffers that are visiting a file that does not exist and
never existed, but @code{nil} for file-visiting buffers whose file has
been deleted.
@end defun

@defun clear-visited-file-modtime
This function clears out the record of the last modification time of
the file being visited by the current buffer.  As a result, the next
attempt to save this buffer will not complain of a discrepancy in
file modification times.

This function is called in @code{set-visited-file-name} and other
exceptional places where the usual test to avoid overwriting a changed
file should not be done.
@end defun

@defun visited-file-modtime
This function returns the current buffer's recorded last file
modification time, as a Lisp timestamp (@pxref{Time of Day}).

If the buffer has no recorded last modification time, this function
returns zero.  This case occurs, for instance, if the buffer is not
visiting a file or if the time has been explicitly cleared by
@code{clear-visited-file-modtime}.  Note, however, that
@code{visited-file-modtime} returns a timestamp for some non-file buffers
too.  For instance, in a Dired buffer listing a directory, it returns
the last modification time of that directory, as recorded by Dired.

If the buffer is visiting a file that doesn't exist, this function
returns @minus{}1.
@end defun

@defun set-visited-file-modtime &optional time
This function updates the buffer's record of the last modification time
of the visited file, to the value specified by @var{time} if @var{time}
is not @code{nil}, and otherwise to the last modification time of the
visited file.

If @var{time} is neither @code{nil} nor an integer flag returned
by @code{visited-file-modtime}, it should be a Lisp time value
(@pxref{Time of Day}).

This function is useful if the buffer was not read from the file
normally, or if the file itself has been changed for some known benign
reason.
@end defun

@defun ask-user-about-supersession-threat filename
This function is used to ask a user how to proceed after an attempt to
modify a buffer visiting file @var{filename} when the file is newer
than the buffer text.  Emacs detects this because the modification
time of the file on disk is newer than the last save-time and its contents
have changed.
This means some other program has probably altered the file.

@kindex file-supersession
Depending on the user's answer, the function may return normally, in
which case the modification of the buffer proceeds, or it may signal a
@code{file-supersession} error with data @code{(@var{filename})}, in which
case the proposed buffer modification is not allowed.

This function is called automatically by Emacs on the proper
occasions.  It exists so you can customize Emacs by redefining it.
See the file @file{userlock.el} for the standard definition.

See also the file locking mechanism in @ref{File Locks}.
@end defun

@node Read Only Buffers
@section Read-Only Buffers
@cindex read-only buffer
@cindex buffer, read-only

  If a buffer is @dfn{read-only}, then you cannot change its contents,
although you may change your view of the contents by scrolling and
narrowing.

  Read-only buffers are used in two kinds of situations:

@itemize @bullet
@item
A buffer visiting a write-protected file is normally read-only.

Here, the purpose is to inform the user that editing the buffer with the
aim of saving it in the file may be futile or undesirable.  The user who
wants to change the buffer text despite this can do so after clearing
the read-only flag with @kbd{C-x C-q}.

@item
Modes such as Dired and Rmail make buffers read-only when altering the
contents with the usual editing commands would probably be a mistake.

The special commands of these modes bind @code{buffer-read-only} to
@code{nil} (with @code{let}) or bind @code{inhibit-read-only} to
@code{t} around the places where they themselves change the text.
@end itemize

@defvar buffer-read-only
This buffer-local variable specifies whether the buffer is read-only.
The buffer is read-only if this variable is non-@code{nil}.  However,
characters that have the @code{inhibit-read-only} text property can
still be modified.  @xref{Special Properties, inhibit-read-only}.
@end defvar

@defvar inhibit-read-only
If this variable is non-@code{nil}, then read-only buffers and,
depending on the actual value, some or all read-only characters may be
modified.  Read-only characters in a buffer are those that have a
non-@code{nil} @code{read-only} text property.  @xref{Special
Properties}, for more information about text properties.

If @code{inhibit-read-only} is @code{t}, all @code{read-only} character
properties have no effect.  If @code{inhibit-read-only} is a list, then
@code{read-only} character properties have no effect if they are members
of the list (comparison is done with @code{eq}).
@end defvar

@deffn Command read-only-mode &optional arg
This is the mode command for Read Only minor mode, a buffer-local
minor mode.  When the mode is enabled, @code{buffer-read-only} is
non-@code{nil} in the buffer; when disabled, @code{buffer-read-only}
is @code{nil} in the buffer.  The calling convention is the same as
for other minor mode commands (@pxref{Minor Mode Conventions}).

This minor mode mainly serves as a wrapper for
@code{buffer-read-only}; unlike most minor modes, there is no separate
@code{read-only-mode} variable.  Even when Read Only mode is disabled,
characters with non-@code{nil} @code{read-only} text properties remain
read-only.  To temporarily ignore all read-only states, bind
@code{inhibit-read-only}, as described above.

When enabling Read Only mode, this mode command also enables View mode
if the option @code{view-read-only} is non-@code{nil}.  @xref{Misc
Buffer,,Miscellaneous Buffer Operations, emacs, The GNU Emacs Manual}.
When disabling Read Only mode, it disables View mode if View mode was
enabled.
@end deffn

@defun barf-if-buffer-read-only &optional position
This function signals a @code{buffer-read-only} error if the current
buffer is read-only.  If the text at @var{position} (which defaults to
point) has the @code{inhibit-read-only} text property set, the error
will not be raised.

@xref{Using Interactive}, for another way to signal an error if the
current buffer is read-only.
@end defun

@node Buffer List
@section The Buffer List
@cindex buffer list
@cindex listing all buffers

  The @dfn{buffer list} is a list of all live buffers.  The order of the
buffers in this list is based primarily on how recently each buffer has
been displayed in a window.  Several functions, notably
@code{other-buffer}, use this ordering.  A buffer list displayed for the
user also follows this order.

  Creating a buffer adds it to the end of the buffer list, and killing
a buffer removes it from that list.  A buffer moves to the front of
this list whenever it is chosen for display in a window
(@pxref{Switching Buffers}) or a window displaying it is selected
(@pxref{Selecting Windows}).  A buffer moves to the end of the list
when it is buried (see @code{bury-buffer}, below).  There are no
functions available to the Lisp programmer which directly manipulate
the buffer list.

  In addition to the fundamental buffer list just described, Emacs
maintains a local buffer list for each frame, in which the buffers that
have been displayed (or had their windows selected) in that frame come
first.  (This order is recorded in the frame's @code{buffer-list} frame
parameter; see @ref{Buffer Parameters}.)  Buffers never displayed in
that frame come afterward, ordered according to the fundamental buffer
list.

@defun buffer-list &optional frame
This function returns the buffer list, including all buffers, even those
whose names begin with a space.  The elements are actual buffers, not
their names.

If @var{frame} is a frame, this returns @var{frame}'s local buffer list.
If @var{frame} is @code{nil} or omitted, the fundamental buffer list is
used: the buffers appear in order of most recent display or selection,
regardless of which frames they were displayed on.

@example
@group
(buffer-list)
     @result{} (#<buffer buffers.texi>
         #<buffer  *Minibuf-1*> #<buffer buffer.c>
         #<buffer *Help*> #<buffer TAGS>)
@end group

@group
;; @r{Note that the name of the minibuffer}
;;   @r{begins with a space!}
(mapcar #'buffer-name (buffer-list))
    @result{} ("buffers.texi" " *Minibuf-1*"
        "buffer.c" "*Help*" "TAGS")
@end group
@end example
@end defun

  The list returned by @code{buffer-list} is constructed specifically;
it is not an internal Emacs data structure, and modifying it has no
effect on the order of buffers.  If you want to change the order of
buffers in the fundamental buffer list, here is an easy way:

@example
(defun reorder-buffer-list (new-list)
  (while new-list
    (bury-buffer (car new-list))
    (setq new-list (cdr new-list))))
@end example

  With this method, you can specify any order for the list, but there is
no danger of losing a buffer or adding something that is not a valid
live buffer.

  To change the order or value of a specific frame's buffer list, set
that frame's @code{buffer-list} parameter with
@code{modify-frame-parameters} (@pxref{Parameter Access}).

@defun other-buffer &optional buffer visible-ok frame
This function returns the first buffer in the buffer list other than
@var{buffer}.  Usually, this is the buffer appearing in the most
recently selected window (in frame @var{frame} or else the selected
frame, @pxref{Input Focus}), aside from @var{buffer}.  Buffers whose
names start with a space are not considered at all.

If @var{buffer} is not supplied (or if it is not a live buffer), then
@code{other-buffer} returns the first buffer in the selected frame's
local buffer list.  (If @var{frame} is non-@code{nil}, it returns the
first buffer in @var{frame}'s local buffer list instead.)

If @var{frame} has a non-@code{nil} @code{buffer-predicate} parameter,
then @code{other-buffer} uses that predicate to decide which buffers to
consider.  It calls the predicate once for each buffer, and if the value
is @code{nil}, that buffer is ignored.  @xref{Buffer Parameters}.

@c Emacs 19 feature
If @var{visible-ok} is @code{nil}, @code{other-buffer} avoids returning
a buffer visible in any window on any visible frame, except as a last
resort.  If @var{visible-ok} is non-@code{nil}, then it does not matter
whether a buffer is displayed somewhere or not.

If no suitable buffer exists, the buffer @file{*scratch*} is returned
(and created, if necessary).
@end defun

@defun last-buffer &optional buffer visible-ok frame
This function returns the last buffer in @var{frame}'s buffer list other
than @var{buffer}.  If @var{frame} is omitted or @code{nil}, it uses the
selected frame's buffer list.

The argument @var{visible-ok} is handled as with @code{other-buffer},
see above.  If no suitable buffer can be found, the buffer
@file{*scratch*} is returned.
@end defun

@deffn Command bury-buffer &optional buffer-or-name
This command puts @var{buffer-or-name} at the end of the buffer list,
without changing the order of any of the other buffers on the list.
This buffer therefore becomes the least desirable candidate for
@code{other-buffer} to return.  The argument can be either a buffer
itself or the name of one.

This function operates on each frame's @code{buffer-list} parameter as
well as the fundamental buffer list; therefore, the buffer that you bury
will come last in the value of @code{(buffer-list @var{frame})} and in
the value of @code{(buffer-list)}.  In addition, it also puts the buffer
at the end of the list of buffers of the selected window (@pxref{Window
History}) provided it is shown in that window.

If @var{buffer-or-name} is @code{nil} or omitted, this means to bury the
current buffer.  In addition, if the current buffer is displayed in the
selected window, this makes sure that the window is either deleted or
another buffer is shown in it.  More precisely, if the selected window
is dedicated (@pxref{Dedicated Windows}) and there are other windows on
its frame, the window is deleted.  If it is the only window on its frame
and that frame is not the only frame on its terminal, the frame is
dismissed by calling the function specified by
@code{frame-auto-hide-function} (@pxref{Quitting Windows}).  Otherwise,
it calls @code{switch-to-prev-buffer} (@pxref{Window History}) to show
another buffer in that window.  If @var{buffer-or-name} is displayed in
some other window, it remains displayed there.

To replace a buffer in all the windows that display it, use
@code{replace-buffer-in-windows}, @xref{Buffers and Windows}.
@end deffn

@deffn Command unbury-buffer
This command switches to the last buffer in the local buffer list of
the selected frame.  More precisely, it calls the function
@code{switch-to-buffer} (@pxref{Switching Buffers}), to display the
buffer returned by @code{last-buffer} (see above), in the selected
window.
@end deffn

@defvar buffer-list-update-hook
This is a normal hook run whenever the buffer list changes.  Functions
(implicitly) running this hook are @code{get-buffer-create}
(@pxref{Creating Buffers}), @code{rename-buffer} (@pxref{Buffer Names}),
@code{kill-buffer} (@pxref{Killing Buffers}), @code{bury-buffer} (see
above) and @code{select-window} (@pxref{Selecting Windows}).

Functions run by this hook should avoid calling @code{select-window}
with a nil @var{norecord} argument or @code{with-temp-buffer} since
either may lead to infinite recursion.
@end defvar

@node Creating Buffers
@section Creating Buffers
@cindex creating buffers
@cindex buffers, creating

  This section describes the two primitives for creating buffers.
@code{get-buffer-create} creates a buffer if it finds no existing buffer
with the specified name; @code{generate-new-buffer} always creates a new
buffer and gives it a unique name.

  Other functions you can use to create buffers include
@code{with-output-to-temp-buffer} (@pxref{Temporary Displays}) and
@code{create-file-buffer} (@pxref{Visiting Files}).  Starting a
subprocess can also create a buffer (@pxref{Processes}).

@defun get-buffer-create buffer-or-name
This function returns a buffer named @var{buffer-or-name}.  The buffer
returned does not become the current buffer---this function does not
change which buffer is current.

@var{buffer-or-name} must be either a string or an existing buffer.  If
it is a string and a live buffer with that name already exists,
@code{get-buffer-create} returns that buffer.  If no such buffer exists,
it creates a new buffer.  If @var{buffer-or-name} is a buffer instead of
a string, it is returned as given, even if it is dead.

@example
@group
(get-buffer-create "foo")
     @result{} #<buffer foo>
@end group
@end example

The major mode for a newly created buffer is set to Fundamental mode.
(The default value of the variable @code{major-mode} is handled at a higher
level; see @ref{Auto Major Mode}.)  If the name begins with a space, the
buffer initially disables undo information recording (@pxref{Undo}).
@end defun

@defun generate-new-buffer name
This function returns a newly created, empty buffer, but does not make
it current.  The name of the buffer is generated by passing @var{name}
to the function @code{generate-new-buffer-name} (@pxref{Buffer
Names}).  Thus, if there is no buffer named @var{name}, then that is
the name of the new buffer; if that name is in use, a suffix of the
form @samp{<@var{n}>}, where @var{n} is an integer, is appended to
@var{name}.

An error is signaled if @var{name} is not a string.

@example
@group
(generate-new-buffer "bar")
     @result{} #<buffer bar>
@end group
@group
(generate-new-buffer "bar")
     @result{} #<buffer bar<2>>
@end group
@group
(generate-new-buffer "bar")
     @result{} #<buffer bar<3>>
@end group
@end example

The major mode for the new buffer is set to Fundamental mode.  The default
value of the variable @code{major-mode} is handled at a higher level.
@xref{Auto Major Mode}.
@end defun

@node Killing Buffers
@section Killing Buffers
@cindex killing buffers
@cindex buffers, killing

  @dfn{Killing a buffer} makes its name unknown to Emacs and makes the
memory space it occupied available for other use.

  The buffer object for the buffer that has been killed remains in
existence as long as anything refers to it, but it is specially marked
so that you cannot make it current or display it.  Killed buffers retain
their identity, however; if you kill two distinct buffers, they remain
distinct according to @code{eq} although both are dead.

  If you kill a buffer that is current or displayed in a window, Emacs
automatically selects or displays some other buffer instead.  This
means that killing a buffer can change the current buffer.  Therefore,
when you kill a buffer, you should also take the precautions
associated with changing the current buffer (unless you happen to know
that the buffer being killed isn't current).  @xref{Current Buffer}.

  If you kill a buffer that is the base buffer of one or more indirect
@iftex
buffers,
@end iftex
@ifnottex
buffers (@pxref{Indirect Buffers}),
@end ifnottex
the indirect buffers are automatically killed as well.

@cindex live buffer
  The @code{buffer-name} of a buffer is @code{nil} if, and only if,
the buffer is killed.  A buffer that has not been killed is called a
@dfn{live} buffer.  To test whether a buffer is live or killed, use
the function @code{buffer-live-p} (see below).

@deffn Command kill-buffer &optional buffer-or-name
This function kills the buffer @var{buffer-or-name}, freeing all its
memory for other uses or to be returned to the operating system.  If
@var{buffer-or-name} is @code{nil} or omitted, it kills the current
buffer.

Any processes that have this buffer as the @code{process-buffer} are
sent the @code{SIGHUP} (hangup) signal, which normally causes them
to terminate.  @xref{Signals to Processes}.

If the buffer is visiting a file and contains unsaved changes,
@code{kill-buffer} asks the user to confirm before the buffer is killed.
It does this even if not called interactively.  To prevent the request
for confirmation, clear the modified flag before calling
@code{kill-buffer}.  @xref{Buffer Modification}.

This function calls @code{replace-buffer-in-windows} for cleaning up
all windows currently displaying the buffer to be killed.

Killing a buffer that is already dead has no effect.

This function returns @code{t} if it actually killed the buffer.  It
returns @code{nil} if the user refuses to confirm or if
@var{buffer-or-name} was already dead.

@smallexample
(kill-buffer "foo.unchanged")
     @result{} t
(kill-buffer "foo.changed")

---------- Buffer: Minibuffer ----------
Buffer foo.changed modified; kill anyway? (yes or no) @kbd{yes}
---------- Buffer: Minibuffer ----------

     @result{} t
@end smallexample
@end deffn

@defvar kill-buffer-query-functions
Before confirming unsaved changes, @code{kill-buffer} calls the functions
in the list @code{kill-buffer-query-functions}, in order of appearance,
with no arguments.  The buffer being killed is the current buffer when
they are called.  The idea of this feature is that these functions will
ask for confirmation from the user.  If any of them returns @code{nil},
@code{kill-buffer} spares the buffer's life.
@end defvar

@defvar kill-buffer-hook
This is a normal hook run by @code{kill-buffer} after asking all the
questions it is going to ask, just before actually killing the buffer.
The buffer to be killed is current when the hook functions run.
@xref{Hooks}.  This variable is a permanent local, so its local binding
is not cleared by changing major modes.
@end defvar

@defopt buffer-offer-save
This variable, if non-@code{nil} in a particular buffer, tells
@code{save-buffers-kill-emacs} to offer to save that buffer, just as
it offers to save file-visiting buffers.  If @code{save-some-buffers}
is called with the second optional argument set to @code{t}, it will
also offer to save the buffer.  Lastly, if this variable is set to the
symbol @code{always}, both @code{save-buffers-kill-emacs} and
@code{save-some-buffers} will always offer to save.  @xref{Definition
of save-some-buffers}.  The variable @code{buffer-offer-save}
automatically becomes buffer-local when set for any reason.
@xref{Buffer-Local Variables}.
@end defopt

@defvar buffer-save-without-query
This variable, if non-@code{nil} in a particular buffer, tells
@code{save-buffers-kill-emacs} and @code{save-some-buffers} to save
this buffer (if it's modified) without asking the user.  The variable
automatically becomes buffer-local when set for any reason.
@end defvar

@defun buffer-live-p object
This function returns @code{t} if @var{object} is a live buffer (a
buffer which has not been killed), @code{nil} otherwise.
@end defun

@node Indirect Buffers
@section Indirect Buffers
@cindex indirect buffers
@cindex base buffer

  An @dfn{indirect buffer} shares the text of some other buffer, which
is called the @dfn{base buffer} of the indirect buffer.  In some ways it
is the analogue, for buffers, of a symbolic link among files.  The base
buffer may not itself be an indirect buffer.

  The text of the indirect buffer is always identical to the text of its
base buffer; changes made by editing either one are visible immediately
in the other.  This includes the text properties as well as the characters
themselves.

  In all other respects, the indirect buffer and its base buffer are
completely separate.  They have different names, independent values of
point, independent narrowing, independent markers and overlays (though
inserting or deleting text in either buffer relocates the markers and
overlays for both), independent major modes, and independent
buffer-local variable bindings.

  An indirect buffer cannot visit a file, but its base buffer can.  If
you try to save the indirect buffer, that actually saves the base
buffer.

  Killing an indirect buffer has no effect on its base buffer.  Killing
the base buffer effectively kills the indirect buffer in that it cannot
ever again be the current buffer.

@deffn Command make-indirect-buffer base-buffer name &optional clone
This creates and returns an indirect buffer named @var{name} whose
base buffer is @var{base-buffer}.  The argument @var{base-buffer} may
be a live buffer or the name (a string) of an existing buffer.  If
@var{name} is the name of an existing buffer, an error is signaled.

If @var{clone} is non-@code{nil}, then the indirect buffer originally
shares the state of @var{base-buffer} such as major mode, minor
modes, buffer local variables and so on.  If @var{clone} is omitted
or @code{nil} the indirect buffer's state is set to the default state
for new buffers.

If @var{base-buffer} is an indirect buffer, its base buffer is used as
the base for the new buffer.  If, in addition, @var{clone} is
non-@code{nil}, the initial state is copied from the actual base
buffer, not from @var{base-buffer}.
@end deffn

@deffn Command clone-indirect-buffer newname display-flag &optional norecord
This function creates and returns a new indirect buffer that shares
the current buffer's base buffer and copies the rest of the current
buffer's attributes.  (If the current buffer is not indirect, it is
used as the base buffer.)

If @var{display-flag} is non-@code{nil}, as it always is in
interactive calls, that means to display the new buffer by calling
@code{pop-to-buffer}.  If @var{norecord} is non-@code{nil}, that means
not to put the new buffer to the front of the buffer list.
@end deffn

@defun buffer-base-buffer &optional buffer
This function returns the base buffer of @var{buffer}, which defaults
to the current buffer.  If @var{buffer} is not indirect, the value is
@code{nil}.  Otherwise, the value is another buffer, which is never an
indirect buffer.
@end defun

@node Swapping Text
@section Swapping Text Between Two Buffers
@cindex swap text between buffers
@cindex virtual buffers

  Specialized modes sometimes need to let the user access from the
same buffer several vastly different types of text.  For example, you
may need to display a summary of the buffer text, in addition to
letting the user access the text itself.

  This could be implemented with multiple buffers (kept in sync when
the user edits the text), or with narrowing (@pxref{Narrowing}).  But
these alternatives might sometimes become tedious or prohibitively
expensive, especially if each type of text requires expensive
buffer-global operations in order to provide correct display and
editing commands.

  Emacs provides another facility for such modes: you can quickly swap
buffer text between two buffers with @code{buffer-swap-text}.  This
function is very fast because it doesn't move any text, it only
changes the internal data structures of the buffer object to point to
a different chunk of text.  Using it, you can pretend that a group of
two or more buffers are actually a single virtual buffer that holds
the contents of all the individual buffers together.

@defun buffer-swap-text buffer
This function swaps the text of the current buffer and that of its
argument @var{buffer}.  It signals an error if one of the two buffers
is an indirect buffer (@pxref{Indirect Buffers}) or is a base buffer
of an indirect buffer.

All the buffer properties that are related to the buffer text are
swapped as well: the positions of point and mark, all the markers, the
overlays, the text properties, the undo list, the value of the
@code{enable-multibyte-characters} flag (@pxref{Text Representations,
enable-multibyte-characters}), etc.

@strong{Warning:} If this function is called from within a
@code{save-excursion} form, the current buffer will be set to
@var{buffer} upon leaving the form, since the marker used by
@code{save-excursion} to save the position and buffer will be swapped
as well.
@end defun

  If you use @code{buffer-swap-text} on a file-visiting buffer, you
should set up a hook to save the buffer's original text rather than
what it was swapped with.  @code{write-region-annotate-functions}
works for this purpose.  You should probably set
@code{buffer-saved-size} to @minus{}2 in the buffer, so that changes
in the text it is swapped with will not interfere with auto-saving.

@node Buffer Gap
@section The Buffer Gap
@cindex buffer gap

  Emacs buffers are implemented using an invisible @dfn{gap} to make
insertion and deletion faster.  Insertion works by filling in part of
the gap, and deletion adds to the gap.  Of course, this means that the
gap must first be moved to the locus of the insertion or deletion.
Emacs moves the gap only when you try to insert or delete.  This is why
your first editing command in one part of a large buffer, after
previously editing in another far-away part, sometimes involves a
noticeable delay.

  This mechanism works invisibly, and Lisp code should never be affected
by the gap's current location, but these functions are available for
getting information about the gap status.

@defun gap-position
This function returns the current gap position in the current buffer.
@end defun

@defun gap-size
This function returns the current gap size of the current buffer.
@end defun
